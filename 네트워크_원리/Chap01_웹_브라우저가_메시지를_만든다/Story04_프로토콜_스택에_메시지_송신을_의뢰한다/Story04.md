# Story04 - 프로토콜 스택에 메시지 송신을 의뢰한다.
## 1. 데이터 송수신 동작의 개요
IP 주소를 조사했으면 액세스 대상 웹 서버에 메시지를 송신하도록 OS 내부에 있는 프로토콜 스택에 의뢰
* 네트워크를 이용하는 애플리케이션 전체에 대해 공통

여기서도 Socket 라이브러리의 부품을 이용
* 복수의 부품을 결정된 순번대로 호출해야 하므로 조금 복잡
* 파이프에 비유하면 편하다.

소켓
* 파이프 양 끝의 데이터의 출입구

통신 과정
1. 서버 측에서 소켓을 생성
2. 이 소켓에 클라이언트가 파이프를 연결하기를 대기 - 클라이언트에서도 소켓을 만듬
3. 양측의 소켓이 연결되면 데이터를 쏟아붓듯이 데이터 송수신을 실행

송수신 동작이 끝난 후의 동작
* 파이프를 분리 - 어느 측에서 분리하든 상관없다.
* 파이프를 분리하면 소켓을 말소하여 통신 동작을 종료

데이터 통신 단계의 요약
1. 소켓 생성
2. 서버측 소켓에 파이프를 연결(접속)
3. 데이터 송수신
4. 파이프를 분리하고 소켓 말소(연결 끊기)

이 동작을 추적하기 전 보충할 것
* 앞의 4가지 동작을 실행하는 것은 OS 내부의 프로토콜 스택
* 브라우저 등의 애플리케이션은 프로토콜 스택에 의뢰해서 동작을 수행
* Socket 라이브러리는 프로토콜 스택과 애플리케이션의 중개역

## 2. 소켓의 작성 단계
소켓을 만드는 단계
1. 소켓 라이브러리의 socket을 호출
2. socket을 호출하면 socket 내부에 제어가 넘어가 소켓을 만드는 동작 실행
3. 동작을 마친 후에는 다시 애플리케이션에 제어가 돌아옴

소켓을 생성하면 디스크립터라는 것이 돌아옴
* 소켓을 식별하는 번호와 같은 것
* 이것을 이용해 어떤 소켓에 접속할지 송수신할지 판단

## 3. 파이프를 연결하는 접속 단계
Socket 라이브러리의 connect라는 프로그램 부품을 호출 이 의뢰 동작을 실행
* 여기서 요점 connect의 매개변수 디스크립터, IP, 포트 세 가지

포트는 상대측에서 소켓을 식별하기 위해 사용
* URL에는 포트가 없다. - 미리 지정해둔 것을 사용
* HTTP 80 포트

디스크립터 : 애플리케이션이 소켓을 식별하는 것

IP 주소와 포트 번호 : 클라이언트와 서버 간에 상대의 소켓을 식별하는 것

## 4. 메시지를 주고받는 송수신 단계
연결 이후에는 write라는 함수를 사용

다음과 같은 과정으로 수행
1. 애플리케이션은 송신 데이터를 메모리에 준비
   * 송신 데이터 : HTTP 리퀘스트 메시지
2. write를 호출할 때 디스크립터와 송신 데이터를 지정
3. 프로토콜 스택이 송신 데이터를 서버에 송신

이후 서버에서 적절한 처리를 마치고 반송


메시지를 수신할 때는 read라는 함수 사용
1. 수신 버퍼 : 수신한 응답 메시지를 저장하는 메모리 영역
2. read가 수신 버퍼에 응답 메시지를 저장
3. 수신 버퍼에 메시지를 저장한 시점에서 메시지를 애플리케이션에 건네줌

## 5. 연결 끊기 단계에서 송수신이 종료된다.
close 함수를 호출하여 연결을 끊는다.
* 소켓 사이의 파이프가 분리되고 소켓이 말소

HTTP에서는 응답 메시지의 송신을 완료했을 때 연결을 끊는다.
1. 웹 서버측에서 close를 호출
2. 클라이언트 측에 전달되어 클라이언트 소켓이 연결 끊기 작업에 들어간다.
3. 클라이언트가 read로 수신 동작을 의뢰할 때 연결이 끊겼다는 것을 브라우저에 통지