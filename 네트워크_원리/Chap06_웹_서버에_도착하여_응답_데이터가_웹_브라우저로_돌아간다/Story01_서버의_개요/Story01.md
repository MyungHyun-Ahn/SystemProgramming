# Story01 - 서버의 개요
## 1. 클라이언트와 서버의 차이점
서버 머신
* 용도에 따라 다양한 종류 - 하드웨어나 OS는 클라이언트와 다를 수도
* 그러나 네트워크 부분은 똑같다. - TCP/IP의 기능은 통일되었다고 생각해도 무방

사용하는 방법까지 같은 것은 아니다.
* Socket 라이브러리의 사용법이 달라짐
* 따라서 서버와 클라이언트 구조가 다름

## 2. 서버 애플리케이션의 구조
클라이언트와 서버가 1대1로 대화하는 방법
* 클라이언트가 접속할 때마다 새로 서버 프로그램을 작동

어떻게 만드는가?
* 서버 접속을 기다리는 부분
* 클라이언트와 대화하는 부분
* 두 부분으로 나누어 만듬
* 새 클라이언트가 접속할 때마다 1대1로 대응

멀티스레드를 이용한 프로그래밍 기법
* 클라이언트와 대화하는 몇 개의 부분을 작동시켜 둠
* 클라이언트가 접속했을 때 비어있는 부분을 찾아서 여기에 소켓을 건네줌

## 3. 서버측의 소켓과 포트 번호
서버 애플리케이션이 Socket 라이브러리를 호출하는 부분의 개요

클라이언트와 서버의 차이점을 한번 더 정리
* 데이터 송수신 관점에서 클라이언트와 서버라는 역할을 고정시키는 것은 좋은 방법이 아님
* 좌우 대칭으로 어디에서나 데이터를 송신할 수 있어야 함
* TCP의 배경에는 이런 개념이 있다.

좌우 대칭으로 만들 수 없는 부분 - 접속 동작
* 기다리고 있는 한쪽에 한쪽을 연결
* 접속하는 측과 기다리는 측이라는 역할 분담이 필요
* 여기에 클라이언트와 서버의 차이점이 있다.
* 접속하는 측 : 클라이언트, 기다리는 측 : 서버

클라이언트의 데이터 송수신 동작
1. 소켓 작성 단계
2. 접속 단계
3. 송수신 단계
4. 연결 끊기 단계

서버 측의 데이터 송수신 동작
1. 소켓 작성 단계 - socket, bind (포트 번호 기록)
2. 접속 대기 상태 - listen
3. 접속 접수 단계 - accept
4. 송수신 단계
5. 연결 끊기 단계

소켓을 식별하기 위해 디스크립터를 사용
* 접속 대기의 소켓에는 클라이언트측의 IP 주소와 포트 번호가 기록되어 있지 않다.
* 디스크립터라는 한 개의 정보로 식별하는 쪽이 간단하기 때문