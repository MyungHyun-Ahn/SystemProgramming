# Story05 - IP와 이더넷의 패킷 송수신 동작
## 1. 패킷의 기본
IP 담당 부분이 어떻게 패킷을 상대방에게 송신하는지

패킷의 기본형
* 헤더
  * 제어 정보가 들어감
* 데이터

TCP/IP의 패킷
* MAC 헤더 - 이더넷의 패킷
* IP 헤더 - IP의 패킷
* TCP 헤더 - TCP의 패킷
* 데이터 조각

패킷의 송신처가 되는 기기가 패킷을 만든다.
* 헤더에는 적절한 제어 정보 기록
* 데이터 부분에는 데이터
* 가장 가까운 중계 장치에 송신
* 도착하면, 도착한 패킷의 헤더를 조사하여 패킷의 목적지 판단
  * 이때 수신처가 어느 방향에 있는지 기록된 표를 사용
* 다음 중계 장치로 송신
* 반복하여 수신처의 기기까지 패킷이 도착

송신처에서 수신처로 패킷을 보내면 수신처에서 송신처로 회답 패킷이 돌아옴
* 수신처와 송신처가 바뀌는 현상
* 수신처와 송신처를 구분하지 않는 것이 편리
* 엔드노드 : 수신처와 송신처를 묶어 표현

서브넷은 라우터와 허브라는 두 종류의 패킷 중계 장체에서 다음과 같은 역할을 분담하여 패킷을 운반
1. 라우터가 목적지를 확인하여 다음 라우터를 나타냄
2. 허브가 서브넷 안에서 패킷을 운반하여 다음 라우터에 도착

라우터는 IP의 규칙에 따라 패킷을 운반하므로 설명을 바꿔보면
1. IP가 목적지를 확인하여 다음 IP의 중계 장치를 나타냄
2. 서브넷 안에 있는 이더넷이 중계 장치까지 패킷을 운반

TCP/IP의 패킷에는 다음 두 개의 헤더가 붙어있다.
* MAC 헤더(이더넷용 헤더)
* IP 헤더(IP용 헤더)

서버에서 클라이언트로의 패킷 송신과정
1. 클라이언트에서 서버의 IP 주소를 IP 헤더의 수신처에 기록
2. IP는 수신처가 어느 방향에 있는지를 조사하고, 그 방향에 있는 다음 라우터를 조사
3. 거기로 패킷이 도착하도록 MAC 헤더를 부착
4. 다음 라우터에 도착하고 MAC 헤더를 다음 라우터로 교체
5. 반복하며 서버에 도착

## 2. 패킷 송수신 동작의 개요
프로토콜 스택의 IP 담당 부분의 패킷 송신 동작
* IP 담당 부분은 패킷을 상대에게 송출만 함
* 나머지는 허브나 라우터 같은 네트워크 기기의 역할

패킷 송수신 동작의 출발점
* TCP 담당 부분이 IP 담당 부분에 패킷 송신을 의뢰하는 곳부터 시작
* TCP 담당 부분은 데이터의 조각에 TCP 헤더를 추가한 것을 IP 담당 부분에 건네줌
* 상대에게 패킷을 보내달라고 요청한 것

IP 헤더
* IP 프로토콜에 규정된 규칙에 따라 IP 주소로 표시된 목적지까지 패킷을 전달할 때 사용하는 제어 정보를 기록한 것

MAC 헤더
* 이더넷 등의 LAN을 사용하여 가장 가까운 라우터까지 패킷을 운반할 때 사용하는 제어 정보를 기록

이제 패킷을 네트워크용 하드웨어에 건네줌
* 이더넷이나 무선 LAN을 말함
* 0과 1의 디지털 데이터
* LAN 어댑터에 의해 전기나 빛의 신호 상태로 바뀌어 케이블에 송출

## 3. 수신처 IP 주소를 기록한 IP 헤더를 만든다
IP 담당 부분의 동작을 추적
* TCP 담당 부분의 의뢰를 받으면 IP 헤더를 만들어 TCP 헤더의 앞에 부착

IP 헤더
* 버전 : 4비트
   * 현재 사용하는 버전 - 4
* 헤더 길이 : 4비트
   * IP 헤더의 길이
* 서비스 유형(ToS) : 8비트
   * 패킷을 운반할 때의 우선 순위
   * 최근에는 DiffServ라는 사양으로 필드 사용법 재정의
* 전체 길이 : 16비트
   * IP 메시지의 전체 길이
* ID 정보(Identification) : 16비트
   * 패킷을 식별하는 번호
   * 보통 패킷의 참조 번호가 여기에 기록
   * IP 클라이언트에 따라 분할된 패킷은 모두 값이 같음
* 플래그 : 3비트
   * 유효한 것은 2비트
   * 1비트 프래그먼테이션 가능 여부
   * 1비트 조각으로 나눈 것인지
* 프래그먼트 오프셋 : 13비트
   * IP 메시지의 맨 앞부분부터 몇 번째 바이트에 위치하는지 기록
* 생존 기간(TTL) : 8비트
   * 영구적인 순환을 방지
   * 라우터를 경유할 때마다 1씩 감소
   * 0이되면 폐기
* 프로토콜 번호 : 8비트
   * TCP : 06
   * UPD : 11
   * ICMP : 01
* 헤더 체크섬 : 16비트
   * 오류 검사용 - 현재는 사용하지 않음
* 송신처 IP 주소 : 32비트
* 수신처 IP 주소 : 32비트
* 옵션 : 가변 길이
   * 추가 제어 정보
   * 거의 사용하지 않음

가장 중요한 것은 수신처 IP 주소
* 잘못지정하더라도 어플리케이션의 잘못
* 애플리케이션이 전달한 것을 그대로 통지

송신처 IP 주소
* 컴퓨터의 할당된 IP 주소로 이해하면 약간 틀리다.
* 1개의 LAN 어댑터의 여러개의 클라이언트 PC가 연결될 수 있기 때문
* LAN 어댑터의 IP 주소가 맞다.

IP용 표를 사용하여 패킷을 건네줄 상대를 판단
* 경로표라고 한다.
* route print 명령으로 내용 표기 가능
* 경로표의 왼쪽 끝에 있는 Network Destination 항목과 비교하여 어느 행에 해당하는지 찾아냄
* IP 주소의 왼쪽 부분이 일치하는 것을 찾아냄
  * 192.168.1.12 -> 192.168.1이 일치하는 것

이후 오른쪽에서 두 번째에 있는 Interface 항목을 확인
* LAN 어댑터 등의 네트워크용 인터페이스를 나타냄
* 인터페이스에서 패킷을 송신하면 상대에 패킷을 전해줄 수 있다는 의미

오른쪽에서 세 번째의 Gateway 항목
* 다음 라우터의 IP 주소를 기록
* IP 주소를 가진 라우터에 패킷을 건네주면 라우터가 목적지에 패킷을 중계

경로표의 맨 위 행에는 목적지 넷마스크가 0.0.0.0으로 등록
* 기본 게이트웨이를 나타냄

이렇게 어느 LAN 어댑터에서 패킷을 송신해야 하는지 알아낸다.
* LAN 어댑터에 할당되어 있는 IP 주소를 IP 헤더의 송신처 IP 주소로 설정

프로토콜 번호라는 필드에도 값을 설정
* TCP, UDP 규칙 설정

기타 항목은 3장에서

## 4. 이더넷용 MAC 헤더를 만든다.
IP 헤더 앞에 MAC 헤더를 붙인다.
* 이더넷은 TCP/IP와는 다른 구조로 패킷의 수신처를 판단.
* 이것의 판단 기준이 MAC 헤더

MAC 헤더
* 수신처 MAC 주소 : 48비트
* 송신처 MAC 주소 : 48비트
* 이더 타입(EtherType) : 16비트
  * IEEE 802.3 : 0000-05DC
  * 0800 : IP 프로토콜
  * 0806 : ARP 프로토콜
  * 86DD : IPv6

MAC 주소는 48비트 값을 한 개의 값으로 판단

이더 타입
* IP 헤더의 프로토콜 번호와 비슷

수신처 MAC 주소
* 경로표의 Gateway 항목의 IP 주소의 기기가 패킷을 건네줄 상대
* IP 주소에서 MAC 주소를 조사하는 동작을 실행

## 5. ARP로 수신처 라우터의 MAC 주소를 조사
ARP
* 브로드캐스트를 이용하여 MAC 주소를 조사
* 같은 네트워크에 존재하는 모든 장치에게 보냄

패킷을 보낼때마다 수행하면 패킷이 불어남
* ARP 캐시를 두어 다시 이용
* IP 주소가 변동되면 값이 바뀔 수 있음
* 따라서 타임아웃 값을 두어 주기적으로 삭제
* ARP 캐시에서 삭제되면 조회 동작을 실행

MAC 헤더를 IP 헤더의 앞부분에 붙이면 패킷이 완성
* LAN 어댑터에 건네주기 전 IP 부분에서 패킷을 완성한다.
* LAN 어댑터는 완성된 패킷을 송신하면 된다.
  * 이렇게 하면 IP 이외의 특수한 패킷도 한개의 LAN 어댑터로 대응 가능

## 6. 이더넷의 기본
이더넷
* 다수의 컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술
* 네트워크의 실체는 케이블만 있다.

트랜시버라는 작은 기기
* 연결한 케이블 사이에 신호를 흘리기만 함
* 케이블과 같은 것
* 모든 연결된 PC에 패킷을 보내고 수신처 정보만 기록
* 해당하는 기기만 패킷을 수신하고 다른 기기는 패킷을 폐기

리피터 허브
* 위와 같은 방식

스위칭 허브
* 원하는 상대에게만 신호가 흐른다.
* 그러나 MAC 헤더의 개념은 그대로

## 7. IP 패킷을 전기나 빛의 신호로 변환하여 송신
LAN 어댑터
* 디지털 데이터를 전기나 빛의 신호로 변환하여 네트워크의 케이블에 송출
* 송수신 동작의 본질
* LAN 어댑터 드라이버가 필요하다.

LAN 어댑터 초기화 과정
* 전원을 공급하면 즉시 사용할 수 있는 것이 아니다.
* 초기화 작업이 필요
* 하드웨어 이상 검사, 초기 설정 등 하드웨어 공통 작업도 있고
* MAC 주소를 설정하는 이더넷 특유의 작업이 있다.
  * MAC 주소는 세계적으로 중복되지 않도록 제조할 때 기록
* 초기화 작업을 마친 후 IP의 의뢰를 대기

## 8. 패킷에 3개의 제어용 데이터를 추가한다.
패킷을 전기 신호로 변환하여 실제로 케이블에 송출
* LAN 드라이버는 패킷을 받으면 LAN 어댑터의 버퍼 메모리에 복사
* 복사를 마친 후 패킷을 송신하도록 MAC 회로에 명령을 보내면 MAC 회로의 작업이 시작

LAN 어댑터에서 송출하는 패킷
* 프리앰블과 스타트 프레임 딜리미터를 앞에 붙인다.
* 맨 끝에는 프레임 체크 시퀀스라는 오류 검출용 데이터를 붙인다.

프리앰블
* 송신하는 패킷을 읽을 때의 타이밍을 잡기 위한 것 : 56비트
* 수신측은 신호를 수신할 때 파형에서 타이밍을 판단

디지털 데이터를 전기 신호로 나타낼 때
* 0과 1의 비트 값을 전압이나 전류의 값에 대응
* 신호를 읽을 때는 대응을 반대로 실행
* 그러나 0과 1이 이어지면 신호의 변화가 없어져 비트 구분을 판단할 수 없다는 문제 발생

위 문제를 해결하기 위한 방법
* 클록이라는 신호를 보내는 방법
* 클록 신호가 아래서 위로 변화할 때 0과 1로 대응시키면 된다.
* 그러나 이 방법에도 문제가 있다.
  * 데이터 신호와 클록 신호가 전달되는 시간의 차이가 발생하면 클록이 틀어진다.

클록과 데이터 신호를 합성하여 한 개의 신호로 만들어 해결
* 이로 한번에 변화의 타이밍까지 보낼 수 있다.

클록 신호의 타이밍을 잡기 위한 특별한 신호를 패킷 앞에 부가하는 것이 프리앰블의 역할

스타트 프래밍 딜리미터
* 패킷의 시작을 나타내는 표시

FCS 프레임 체크 시퀀스
* 잡음으로 인해 데이터가 손상된 것을 검출하기 위해 사용
* 32비트의 비트열
* CRC 오류 검사 코드와 같은 종류
* 데이터가 손상되면 수신측에서 계산한 FCS가 송신할 때 계산한 것과 다른 값이 된다.

## 9. 허브를 향해 패킷을 송신한다.
신호를 송신하는 동작 두 가지
* 리피터 허브를 사용하는 반이중 모드
* 스위칭 허브를 사용한 전이중 모드

반이중 모드
* 신호의 충돌을 피하기 위해 다음과 같이 동작
  * 먼저 케이블에 다른 기기가 송신한 신호가 흐르고 있는지 조사
  * 신호가 흐르고 있다면 끝날 때까지 대기
  * 신호가 정지했거나 애초부터 신호가 흐르고 있지 않았다면 송신 동작을 시작
* 송신 동작
  * MAC 회로가 프리앰블의 맨 앞부터 1비트씩 차례로 디지털 데이터를 전기 신호로 변환
  * PHY, MAU라는 송수신 신호 부분에 보냄
  * 이때 디지털 데이터를 신호로 변환하는 속도가 전송 속도

PHY(MAU) 회로
* 이 신호를 케이블에 송출하는 형식으로 변환
* 이더넷은 형식의 차이에 신경쓰지 않고 공통 형식의 신호를 PHY 회로에 보냄
* PHY 회로에서 실제로 케이블에 송출하는 형식으로 변환하여 송신

PHY 회로는 송신 동작만 실행하지 않는다.
* 송신 개시 전 신호가 흐르지 않는 것을 확인한 후 송신 동작에 들어갔으므로 송신을 시작했을 때는 신호가 흐르지 않음
* 신호 송신을 완료할 때까지 신호가 들어오지 않으면 송수신 동작이 끝남

이더넷은 기기와 기기 사이를 연결하는 케이블 길이를 100m 이내로 정함
* 오류가 발생하더라도 TCP가 검출

신호를 송신하는 사이에 수신 신호가 흘러오지 않아야 한다.
* 만약 동시에 송신 동작에 들어간 기기가 있다면 보낸 신호가 수신 신호선으로 되돌아옴
* 이러한 상태가 되면 충돌
  * 충돌이 일어난 사실을 재밍 신호를 통해 전달
  * 이때 대기 시간이 동일하다면 다시 충돌이 일어나므로 대기 시간이 중복되지 않도록 고안되어 있다.
  * 난수를 기반으로 대기 시간을 계산

이더넷이 혼잡해지면 충돌의 가능성이 높아진다.
* 다시 충돌한다면 대기 시간을 2배로 늘려서 다시 보냄
* 10번 째까지 다시 보냈는데도 해결되지 않으면 오류로 판단

반이중 모드 - 3장에서 설명
* 충돌은 일어나지 않는다.

## 10. 돌아온 패킷을 받는다.
리피터 허브를 이용한 반이중 동작
* 1대가 송신한 신호가 리피터 허브에 접속된 케이블 전부에 흘러감
* 수신 동작은 이러한 신호를 전부 받아들이는 것에서 시작

수신 동작 과정
* 프리엠블을 통해 파형에서 타이밍을 계산하여 프레임 딜리미터가 나오면 그 다음 비트부터 디지털 데이터로 변환하여 동작을 개시
  * PHY 회로에서 MAC 회로 쪽으로 진행
* PHY 회로에서 신호를 공통 형식으로 변환하여 MAC 회로에 보내고, MAC 회로에서 신호를 맨 앞부터 차례대로 디지털 데이터로 변환하여 버퍼 메모리에 저장
* 신호의 마지막에 도달하면 FCS를 검사
  * FCS가 일치하지 않으면 오류 패킷으로 간주하여 폐기
* FCS에 문제가 없으면 MAC 헤더의 수신처 MAC 주소를 조사하여 자신의 MAC 주소와 비교
* 자신에게 오는 것이면 패킷을 받아 버퍼 메모리에 저장
* 아니라면 폐기

이로서 MAC 회로가 할일이 끝나면 패킷을 수신한 사실을 컴퓨터 본체에 통지

통지는 인터럽트라는 구조를 사용
* LAN 어댑터측에서 컴퓨터 본체로 알려주지 않으면 패킷의 도착을 알아차리지 못함
* 이떄 인터럽트를 보내 컴퓨터 본체가 실행하고 있는 작업에 끼어든다.
* 현재는 PnP 사양에 따라 인터럽트 번호를 자동으로 설정

LAN 드라이버는 이후 MAC 헤더의 타입 필드 값에 따라 프로토콜을 판별
* 해당 프로토콜 스택에 패킷을 건네주기만 하면 된다.

## 11. 서버의 응답 패킷을 IP에서 TCP로 넘긴다.
웹서버에서 반송된 패킷의 타입은 0800
* TCP/IP의 프로토콜 스택에 패킷을 건냄

IP 담당 부분의 작업
* IP 헤더를 조사하여 포맷에 문제가 없는지 확인
* 수신처 IP를 조사
  * 자신과 다르면 폐기

수신처 IP가 다른 오류가 발생하면
* ICMP라는 메시지를 사용하여 통신 상대에게 오류를 통지
* 이 경우에는 Destination unreachable이라는 메시지를 통지

ICMP 오류 메시지 종류
* Echo reply : Echo 메시지의 응답
* Destination unreachable : 패킷을 목적지에 건네줄 수 없는 경우
* Source quench : 라우터의 중계 능력을 초과하여 패킷을 보낸 경우
* Redirect : 패킷의 출력 대상 포트가 이 패킷을 수신한 포트와 동일한 경우 이 라우터를 중계하지 않고 다음 라우터에 직접 패킷을 송신 - 다음 라우터의 IP 주소를 나타내고 여기에 직접 패킷을 보내도록 통지
* Time exceeded : TTL 필드의 패킷 생존 값 만료
* Parameter problem : IP 헤더 필드의 값 등에 오류가 있는 경우 패킷을 폐기

fragmentation 기능 처리
* 만약 패킷이 분할된 것이라면 IP 담당 부분의 매모리에 일시적으로 보관
* IP 헤더의 ID 정보에 값은 값을 가진 패킷이 도착하기를 대기
* 프래그먼트 오프셋이라는 정보로 패킷을 조합
* 위 동작을 리어셈블링이라고 한다.

이후 TCP 담당 부분으로 패킷을 넘겨준다.
* TCP 헤더 부분의 수신처, 송신처 포트 번호의 네 가지 항목을 조사하여 해당하는 소켓을 찾는다.
* 해당하는 소켓을 찾아내어 적절한 동작을 실행