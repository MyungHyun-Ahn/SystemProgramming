# Story03 - 데이터를 송수신한다.
## 1. 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다.
connect에서 애플리케이션에 제어가 돌아오면 데이터 송수신 동작에 진입
* write를 호출하여 송신 데이터를 프로토콜 스택에 건네주는 곳부터 시작
* 이것을 받은 프로토콜 스택이 송신 동작을 실행한다는 순서로 진행

몇 가지 중요한 사실
* 프로토콜 스택은 송신 데이터의 내용이 무엇인지 알지 못한다.
  * write를 호출할 때 송신 데이터의 길이를 지정
  * 바이너리 데이터가 1바이트씩 차례로 나열되어 있다고 인식할 뿐
* 받은 데이터를 곧바로 송신하는 것이 아니다.
  * 송신용 버퍼 메모리 영역에 저장 후
  * 애플리케이션이 다음 데이터를 건네주기를 대기
  * 작은 패킷을 여러번 보낼 수도 있기 때문

어느 정도까지 저장하고 보낼 것인지는 다음과 같은 요소로 판단
* 한 패킷에 저장할 수 있는 데이터의 크기
  * MTU : 한 패킷으로 운반할 수 있는 데이터의 최대 길이 - 보통 1500바이트
  * MSS : 헤더를 제외한 데이터의 최대 길이
* 타이밍
  * 프로토콜 스택 내의 타이머를 기준으로 일정 시간 이상이 경과하면 패킷을 송신

MTU를 중요시 하면
* 패킷 길이가 길어져 네트워크 이용 효율 증가
* 그러나 송신 동작이 지연될 우려가 있음

타이밍을 중시
* 지연은 적어지나 이용 효율이 떨어짐

두 가지를 절충하여 적당히 송신 동작을 실행해야 한다.
* 애플리케이션에서 송신을 의뢰할 때 옵션으로 바로 송신할 것이라고 지정 가능

## 2. 데이터가 클 때는 분할하여 보낸다.
MSS의 길이를 초과하면 크기에 맞게 분할하고 한 개씩 송신


## 3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다
시퀀스 번호
* 데이터 조각을 송신할 때 분할된 패킷을 몇 바이트 순서인지 세어둔 값

송신 데이터의 크기는 알리지 않고 수신측에서 계산한다.
* 패킷 전체 길이에서 헤더 길이를 뺀다.

이렇게 하여 누락된 패킷을 알 수 있다.
* 시퀀스 번호가 누락된 것을 확인하고
* ACK 번호에 기록하여 송신측에 알려줌
* 이 때 송신측은 이것을 확인하고 재전송
* 수신 확인 응답이라 한다.

실제로는 시퀀스 번호를 난수를 바탕으로 산출한 초기값으로 시작
* 접속 시 SYN에 1을 설정할 때 시퀀스 번호에도 값을 설정
* 이것이 초기값을 나타냄

송신한 데이터에 대응되는 ACK 번호가 돌아오지 않으면 패킷을 재전송
* 이렇게 하여 다른 곳에서는 회복 조치를 하지 않음
* 오류를 검출하면 그 패킷을 버리기만 함

만약 서버가 다운되는 등의 이유로 아무리 다시 보내도 데이터가 도착하지 않는다면
* 몇 번 지정한 횟수만큼 보낸 뒤
* 데이터 송신 동작을 강제로 종료하고 애플리케이션에 오류를 통지

## 4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다
타임아웃 값
* ACK 번호가 돌아오는 것을 기다리는 시간
  
TCP는 타임아웃 값을 동적으로 변경
* ACK가 돌아오는 시간 기준으로 대기 시간을 판단

## 5. 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다
윈도우 제어
* 한개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 연속해서 복수의 패킷을 보내는 방식
* ACK 번호가 돌아올 때까지의 시간이 낭비되지 않는다.

그런데 수신 측의 버퍼를 넘어서게 송신 측이 송신하면 데이터를 잃어버려 오류가 발생한 것처럼 됨
* 먼저 수신측이 송신측에 수신 가능한 데이터 양을 통지
* 수신측은 이 양을 초과하지 않도록 송신 동작을 실행

TCP 헤더의 윈도우 필드에서 이것을 송신측에 알린다.
* 수신 가능한 데이터 양의 최대값을 윈도우 사이즈라 한다.

## 6. ACK 번호와 윈도우를 합승한다.
윈도우 통지가 필요한 시점
* 수신측이 수신 버퍼에서 데이터를 추출하여 애플리케이션에 건네주었을 때
* 이 동작은 송신측에서는 알 수 없다.
* 수신측에서 수신 버퍼의 빈 영역이 늘어났을 때가 윈도우 통지의 타이밍

ACK 번호의 통지가 필요한 타이밍
* 수신측에서 데이터를 받았을 때 내용을 조사하여 정상 수신을 확인할 수 있는 경우
* 즉, 데이터 수신 직후

이 두 가지를 조합하면
* 송신측에서 보낸 데이터가 수신측에 도착하여 수신 동작이 정상적으로 완료되었을 때 ACK 번호를 송신측에 통지하고
* 잠시 후 데이터를 애플리케이션에 건네주었을 때 윈도우를 송신측에 통지
* 이렇게 되면 ACK 번호 통지와 윈도우 통지의 패킷이 하나씩 따로따로 송신측에 보내짐

수신측은 소켓을 바로 보내지 않고 기다림
* ACK와 윈도우를 합쳐서 한 개의 패킷으로 보냄

ACK나 윈도우의 통지가 연속된 경우에도 묶을 수 있다.
* 마지막의 것만 보내주면
* 이전의 것은 모두 잘 도착했다는 의미

## 7. HTTP 응답 메시지를 수신한다
브라우저는 리퀘스트 메시지를 송신해달라고 의뢰하고 이것이 끝나면
* read 함수를 호출
* read를 경유하여 프로토콜 스택에 제어가 넘어가고 프로토콜 스택이 움직이기 시작
* 데이터를 수신할 때도 수신 버퍼를 사용

수신 동작
* 프로토콜 스택은 수신 버퍼에서 수신 데이터를 추출하여 애플리케이션에 건네줌
* 응답 메시지가 돌아올 때까지 대기
* 응답 메시지가 돌아오면 애플리케이션에 데이터를 건네줌
* 여기서도 수신 버퍼가 빔으로 타이밍에 맞춰 윈도우를 통지