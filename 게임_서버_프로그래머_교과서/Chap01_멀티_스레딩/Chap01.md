# 1장 멀티 스레딩
## 1.1 프로그램과 프로세스
프로그램
* 명령어 모음이 들어 있는 데이터 덩어리
* 코드와 데이터로 구성

프로세스
* 프로그램을 더블 클릭하여 실행시킨 상태

프로그램을 더블 클릭하여 실행하면
* 프로그램의 코드와 데이터가 프로세스 메모리로 로딩됨
* 프로세스가 RAM 메모리에 존재하게 됨

멀티 프로세싱
* 프로세스가 여러 개 실행되고 있는 것

## 1.2 스레드
스레드
* 프로세스 처럼 명령어를 한 줄씩 실행하는 기본 단위

스레드와 프로세스 차이점
* 프로세스 안에 여러 스레드가 존재
* 한 프로세스 안의 스레드는 프로세스의 메모리 공간을 같이 사용할 수 있음
* 스레드마다 스택을 가짐

싱글 스레드 프로그램
* 하나의 스레드만 실행되는 프로그램

메인 스레드
* 프로그램을 실행할 때 기본으로 존재하는 스레드
* 지금까지 우리는 메인 스레드에서 프로그램을 실행했음

멀티 스레딩
* 프로세스 안에서 여러 스레드를 생성할 수 있음
* 여러 스레드가 동시에 여러 가지 일을 처리하게 하는 것

각 스레드는 각자의 호출 스택을 가짐

스레드 생성 함수

윈도우 코드
```C++
DWORD threadID;
ThreadParam threadParam;
threadParam.value = 123;
CreateThread(..., ThreadProc, &ThreadParam, ..., &threadID);
```

리눅스 계열
```C++
pthread_t threadID;
CreateThread(&threadIDm ..., ThreadProc, &threadParam);
```

모던 C++
```C++
std::thread t1(ThreadProc, 123);
```

## 1.3 멀티스레드 프로그래밍은 언제 해야 할까?
멀티스레드 프로그래밍을 해야 하는 대표적인 상황
1. 오래 걸리는 일 하나와 빨리 끝나는 일 여럿을 같이 해야 할 때
   * 게임의 로딩
2. 어떤 긴 처리를 진행하는 동안 다른 짧은 일을 처리해야 할 때
   * 디스크에 액세스 하는 경우
3. 기기에 있는 CPU를 모두 활용해야 할 때

## 1.4 스레드 정체
컨텍스트 스위치
* 각 스레드를 실행하다 말고 다른 스레드를 마저 실행하는 과정
* 적지 않은 양의 연산이 발생
  * 실행 중이던 스레드의 상태를 저장
  * 새로 실행할 스레드의 상태를 로드
* 동시에 실행할 스레드가 여럿이라 컨텍스트 스위치가 자주 발생하면 배보다 배꼽이 커질 수 있음

타임 슬라이스
* 사람 입장에서 쾌적할 수 있는 가급적 긴 시간 단위
* 컨텍스트 스위치는 타임 슬라이스 단위로 이루어 진다.
* 보통 스레드를 다시 시작하는데 걸리는 시간은 5밀리 초
* CPU 입장에서 5억 * 5밀리초 = 250만 개 - 충분히 긴 시간

Runnable 상태의 스레드가 CPU 개수보다 많을 경우 성능 문제가 된다.
* Waitable 상태의 스레드는 이러한 성능 문제가 없다.

## 1.5 스레드를 다룰 때 주의 사항
데이터 레이스
* 두 스레드가 데이터에 접근해서 그 데이터 상태를 예측할 수 없게 하는 것

공유 자원에 접근 하는 경우 컨텍스트 스위치는 랜덤으로 발생하므로 예측할 수 없다.
* 발생할 수 있는 문제
  * 같은 값을 여러번 연산
  * 값을 건너뛰도 연산 등의 문제
  * 건드리면 안되는 메모리 영역을 건드리는 등의 문제 발생

이런 문제를 해결하는 방법
* 원자성을 지킨다.
  * 공유 자원을 한 스레드가 접근한 경우 다른 스레드는 접근하지 못하도록 함
* 이런 것을 동기화라고 함
  * 대표적으로 임계 영역과 뮤텍스, 잠금 기법이 있다.

## 1.6 임계 영역과 뮤텍스
경쟁 상태를 해결하는 방법 중 하나
* 스레드에서 어떤 정보 X를 사용하고 있는 동안 다른 스레드는 X를 건드리지 못하게 한다
* 다른 스레드는 X를 건드리려고 하면 기다린다. 현재 스레드가 X를 다 사용할 때까지

이때 사용하는 것이 뮤텍스(mutex)
* 상호 배제(mutual exclusion)의 줄임말

뮤텍스를 사용하는 방법
1. X, Y를 보호하는 뮤텍스 MX를 만든다.
2. 스레드는 X, Y에 접근하기 전 MX에 사용권을 요청합니다.
3. 스레드는 X, Y에 엑세스 합니다.
4. 엑세스가 끝나면 MX에 사용권을 반환합니다.

뮤텍스 C++ 표준 객체 std::mutex 사용 예
```C++
std::mutex mx;
lock();
read(x);
write(y);
sum(x);
mx.unlock();
```
* lock 부터 unlock까지 한 스레드만 접근이 보장됨
* 그런데 매번 lock()과 unlock()을 호출하는 것은 번거롭고 예외 처리 또한 어렵다.


코드 lock, unlock을 명시적으로 호출
```C++
std::mutex mx;
mx.lock();
read(x);
write(y);
sum(x);
mx.unlock();
```
* unlock 전 예외가 발생하면 unlock이 되지 않는다.
* try catch로 감싸야 한다.

뮤텍스 잠금 상태를 로컬 변수로 저장하고 그 변수가 사라질 때 자동으로 잠금 해제가 되게 하는 클래스를 제공
```C++
std::recursive_mutex mx;
lock_guard<std::recursive_mutex> lock(mx);
read(x);
write(y);
sum(x);
```

뮤텍스를 너무 잘게 나누면 생기는 문제
1. 프로그램 성능 하락 - 뮤텍스 엑세스 무겁다.
2. 프로그램이 복잡함 - 교착 상태 문제 발생 가능

컨텐션(Contention)
* 두 스레드가 동시에 한 데이터를 액세스하는 상황
* 뮤텍스로 잠금을 하면 병렬성이 사라지는 문제
* 멀티스레드 프로그래밍에서 불가피함

## 1.7 교착 상태
멀티스레드 프로그래밍에서 교착 상태
* 두 스레드가 서로를 기다리는 상황

## 1.8 잠금 순서의 규칙
교착 상태를 예방하는 법
* 각 뮤텍스의 잠금 순서를 먼저 그래프로 그려봄
* 잠금을 할 때 잠금 순서 그래프를 보며 거꾸로 잠근 것이 없는지 체크

뮤텍스는 재귀를 가지는 것도 있음
* recursive mutex
* 잠근 것을 또 잠글 수 있다.

교착 상태를 예방하려면 첫 번째 잠금 순서를 지켜야 한다.

## 1.9 병렬성과 시리얼 병목
시리얼 병목
* 병렬로 실행되게 만들었는데 한 CPU만 연산을 수행하는 현상

Visual Studio의 Concurrency Visualizer라는 것으로 멀티스레드 프로그램이 여러 가지 일을 정말로 동시에 잘 수행하는지 분석하는 도구
* 스레드가 무슨일을 했는지 그래프로 확인 가능

## 1.10 싱글스레드 게임 서버
싱글 스레드 서버를 구동하는 경우 CPU 개수만큼 프로세스를 띄우는 것이 일반적

싱글 스레드 서버를 만드는 경우
1. 방 개수만큼 프로세스가 있으면 컨텍스트 스위치 횟수가 증가
2. 같은 동시접속자를 처리하는 서버라고 하더라도 실제로 처리할 수 있는 동접을 크게 떨어뜨림


## 1.11 멀티스레드 게임 서버
멀티스레드로 서버를 개발하는 경우
1. 서버 프로세스를 많이 띄우기 곤란할 때
2. 서버 한 대의 프로세스가 여러 CPU의 연산량을 동원해야 할 만큼 많은 연산을 할 때
3. 코루틴이나 비동기 함수를 쓸 수 없고 디바이스 타임이 발생할 때
4. 서버 인스턴스를 서버 기기당 하나만 두어야할 때
5. 서로 다른 방이 같은 메모리 공간을 액세스해야할 때

## 1.12 스레드 풀링
스레드 풀링
* 스레드 개수에 제한을 두는 것

## 1.13 이벤트
이벤트
* 잠자는 스레드를 깨우는 도구
* 내부 상태 값
  * Reset : 이벤트가 없음
  * Set : 이벤트가 있음

이벤트 모드
* 자동 이벤트
  * 이벤트 상태값이 1이되면 스레드를 깨우고 상태값을 자동으로 0으로 초기화
* 수동 이벤트

## 1.14 세마포어
세마포어
* 원하는 개수의 스레드가 자원을 액세스할 수 있게 하는 것
* 1개만 허용하면 뮤텍스와 동일

## 1.15 원자 조작
원자 조작
* 동기화 객체 없이도 여러 스레드가 안전하게 접근할 수 있는 것

대표적인 원자 조작
* 값 더하기
* 값 맞바꾸기
* 값 조건부 맞바꾸기

## 1.16 멀티스레드 프로그래밍의 흔한 실수들
실수들
* 읽기 쓰기 모두에 잠금하지 않기
* 잠금 순서 꼬임
* 너무 좁은 잠금 범위
* 디바이스 타임이 섞인 잠금
* 잠금의 전염성으로 발생한 실수
* 잠금된 뮤텍스나 임계 영역 삭제
* 일관성 규칙 깨기