# 6장 커널 오브젝트와 오브젝트 핸들
## Section 01 - 커널 오브젝트에 대한 이해
**"커널에서 관리하는 중요한 정보를 담아둔 데이터 블록을 가리켜 커널 오브젝트라 한다."**

### 커널 오브젝트의 이해
* 프로세스를 실행하는 실질적 주체는 운영체제
* 관리 또한 운영체제의 몫
* 운영체제는 프로세스의 정보를 저장하고 관리해야 한다.
* ex) 프로세스 상태 정보, 우선순위 정보
* 이를 위해 Windows 운영체제 개발자들이 구조체를 정의 : 프로세스 관리 구조체
* 커널 오브젝트는 프로그래머가 직접 생성하거나 조작할 수 없다.

### 그 이외의 커널 오브젝트들
**"프로세스가 생성될 때만 커널 오브젝트가 생성되는 것은 아니다."**

* Windows에서는 파일을 생성할 때도 커널 오브젝트가 생성됨
* 커널 오브젝트마다 서로 다른 구조체를 기반으로 생성됨
* 파일 속성 또한 저장 (Read, Write 모드 등)

**"Windows 커널에 의해 관리되는 리소스 수만큼 커널 오브젝트또한 생성된다."**

Kernel Object <-> Resource

### 오브젝트 핸들(Handle)을 이용한 커널 오브젝트의 조작

* 마이크로소프트에서 제공하는 시스템 함수를 통해 커널 오브젝트를 간접적으로 조작 가능

**프로세스의 우선순위 변경**
BOOL SetPriorityClass (\
&nbsp;&nbsp;&nbsp;&nbsp;HANDLE hProcess,\
&nbsp;&nbsp;&nbsp;&nbsp;DWORD dwPriorityClass\
)

* 함수가 실패하면 return value zero
1. hProcess : 우선순위를 변경할 프로세스의 핸들
2. dwPriorityClass : 새롭게 적용할 우선순위 정보

"핸들이란 커널 오브젝트에 할당되는 숫자에 불과"

**커널 오브젝트에 할당되는 숫자! 핸들(Handle)**

커널 오브젝트와 핸들의 관계\
Handle <-> Kernel Object <-> Resource


**핸들 정보는 어디서?**

* 커널 오브젝트의 종류에 따라 다양하게 얻어올 수 있다.

## Section 02 - 커널 오브젝트와 핸들
### 커널 오브젝트와 핸들의 종속 관계
"커널 오브젝트는 핸들에 종속적이다."
* 종속적이다. : 독립적이지 못하다.

"커널 오브젝트는 프로세스에 종속적인 것이 아니라, 운영체제에 종속적인 관계로 커널 오브젝트의 소멸시점은 운영체제에 의해 결정된다."

즉, 여러 프로세스에 의해 접근 가능하다.\
(물론, 함수 호출을 통한 간접 접근이다.)

### 핸들의 종속 관계
**"핸들(핸들 테이블)은 운영체제에 종속적이지 않고 프로세스에 종속적이다."**

즉, 커널 오브젝트는 여러 프로세스에 의해 접근 가능하다.

### PROCESS_INFORMATION 구조체
typedef struct _PROCESS_INFORMATION\
{\
&nbsp;&nbsp;&nbsp;&nbsp;HANDLE hProcess;\
&nbsp;&nbsp;&nbsp;&nbsp;HANDLE hThread;\
&nbsp;&nbsp;&nbsp;&nbsp;DWORD dwProcessId;\
&nbsp;&nbsp;&nbsp;&nbsp;DWORD dwThreadId;\
}

* hProcess : 커널 오브젝트를 가리키기 위한 것
* dwProcessId : 프로세스 자체를 가리키기 위한 것
* hThread : 스레드 핸들
* dwThreadId : 스레드 ID 정보

스레드?
* 프로세스 내부적으로 스레드라는 '가벼운 프로세스'를 생성해 main 함수가 호출되게끔 디자인

## Section 03 - 커널 오브젝트와 Usage Count
* 커널 오브젝트를 생성한 주체가 커널 오브젝트를 소멸시킬 권한을 가지나? - 맞는 말
* 그런데, 그 주체가 누구냐?
* 프로세스 생성 요청 -> 운영체제가 커널 오브젝트 생성
* 즉, 운영체제가 커널 오브젝트의 생성 주체이다.

### CloseHandle 함수에 대한 정확한 이해
**"프로세스가 소멸된다고 해서 커널 오브젝트가 소멸된다고 말할 수 없다."**
* 운영체제가 결정할 일이기 때문

CloseHandle 함수는 핸들을 닫는 기능을 하고 있다.\
즉, 핸들의 반환

* 핸들의 리소스를 해제하면 커널 오브젝트도 소멸될까?
* 이렇게 말할 수 없다. 확대 해석
* 핸들의 리소스를 해제해도 프로세스는 살아있다.


### CloseHandle 함수와 프로세스 종료코드
* main 함수 끝에오는 return 값은 종료코드
* return 에 반환되는 값을 정의하여 다양하게 종료코드를 표현 가능

### 커널 오브젝트와 Usage Count
**"자식 프로세스의 종료코드는 자식 프로세스의 커널 오브젝트에 저장된다."**
* 자식 프로세스가 종료될 때 커널 오브젝트도 동시에 소멸되면 부모 프로세스는 종료코드를 얻을 수 없다.
* 그렇기에 프로세스가 종료되었다고 해서 커널 오브젝트까지 동시에 소멸시키지는 않는다.

언제 커널오브젝트를 삭제하는 것이 이상적일까?
* 커널 오브젝트를 참조하는 것이 없을 때가 가장 이상적이다.
* 이것이 바로 Windows가 커널 오브젝트 소멸을 결정하는 방식

### Usage Count와 CloseHandle
**"CloseHandle 함수는 핸들을 반환하면서 커널 오브젝트의 Usage Count를 하나 감소시키는 역할"**

바탕화면 또한 프로세스이기 때문에 바탕화면의 실행파일을 실행하면 Usage Count는 2가 된다.

### 프로세스 강제 종료
프로세스 종료를 요청하는 함수는 따로 존재
* TerminateProcess 함수


### 이것만은 알고 갑시다
1. 커널 오브젝트와 핸들
2. 운영체제에 종속적인 커널 오브젝트
3. Usage Count
4. CloseHandle 함수
5. 프로세스의 Usage Count
6. 종료코드
7. 부모 프로세스가 자식 프로세스 핸들을 곧바로 반환하는 이유