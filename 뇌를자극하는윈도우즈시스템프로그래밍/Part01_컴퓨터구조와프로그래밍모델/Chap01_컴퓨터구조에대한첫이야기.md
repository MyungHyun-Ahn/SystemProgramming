# 1장 컴퓨터 구조에 대한 첫 번째 이야기
## Section 01 - 시스템 프로그래밍의 이해와 접근
### 시스템 프로그래밍이란?
- 기본적인 개념 : 컴퓨터 시스템을 동작시키는 프로그램
- Windows 시스템 프로그래머가 되기 위해서는 무엇을 공부?
- -> MSDN을 뒤져서 각각의 함수가 제공하는 기능을 아주 정확히 이해하면 된다.
- 이것들을 이해하려면 운영체제의 최소한의 지식이 필요
- 운영체제를 이해하려면 컴퓨터 구조에 대한 기본적인 지식도 필요
- **결론 운영체제와 컴퓨터 구조를 잘 알아야 한다.**

### 컴퓨터 시스템의 주요 구성요소 (Main Components)
컴퓨터 구조 (Computer Architecture)
* CPU
* 캐쉬 (Cache)

운영체제
* 메인 메모리 (Main Memory)
* 하드 디스크 (Hard Disk)

## Section 02 - 컴퓨터 하드웨어의 구성
### CPU (Centeral Processing Unit)
* 우리가 흔히 말하는 **중앙처리장치**
* 컴퓨터 프로그램의 실행에 있어 핵심적인 역할
### 메인 메모리 (Main Memory)
* 램(RAM) 이라는 저장장치로 구성
* **컴파일이 완료된 프로그램 코드가 올라가서 실행되는 영역**
* 프로그램 실행을 위해 존재하는 메모리
### 입출력 버스 (Input/Output)
* 컴퓨터를 구성하는 구성요소 사이에서 데이터를 ㅂ주고 받기 위해 사용되는 경로
* 데이터의 종류와 역할에 따라서 어드레스 버스(Adress bus), 데이터 버스(Data Bus), 컨트롤 버스(Control Bus) 세 가지로 구분
* 나뉜다는 것보다는 각각의 역할에 집중하여 학습

## Section 03 - CPU에 대한 이해
### ALU (Arithmetic Logic Unit)
* CPU 내부에 실제 연산을 담당하는 블록
* 나머지 블록들은 연산을 하는데 도움을 주는 블록들
* ALU가 처리하는 기본적인 연산 - 2가지
* 산술 연산, 논리 연산
### 컨트롤 유닛 (Control Unit)
* 명령어를 해석하는 역할
* 명령어를 해석하고 결과에 따라 적절한 신호를 CPU의 다른 불록에 보내는 일을 한다.
### CPU 내부에 존재하는 레지스터들 (Register Set)
* ALU와 컨트롤 유닛이 모두 사용중일 경우 저장할 공간이 필요
* 임시로 저장할 데이터를 저장하는 공간
* CPU에 따라 16비트, 32비트, 64비트 정도의 데이터를 저장
### 버스 인터페이스 (Bus Interface)
* I/O 버스 : 컴퓨터 내부의 장치들이 서로 데이터를 주고받기 위한 매개체
* CPU는 그럼 어떻게 I/O 버스와 통신하고 있을까?
* 해당 역할을 수행하는 것이 바로 **버스 인터페이스**
* 버스 인터페이스는 I/O 버스의 프로토콜 혹은 통신방식을 알고 있다.
* 추가로 I/O 버스에 연결되는 모든 장치들은 버스 인터페이스가 필요하다.
* 컨트롤러(Controller) 혹은 어댑터(Adapter)라고도 불린다.
### 클럭 신호 (Clock Pulse)
* CPU를 구성하는 요소는 아니다.
* 그러나 CPU를 구성하는 구성 요소에 제공되어야 하는 신호로서 아주 중요한 의미를 가진다.
* 클럭 신호는 타이밍(Timing)을 제공하기 위해서 필요한 것이다.
* 내 PC의 클럭 3700Mhz
* 클럭발생기(오실레이터)는 1초당 370,000,000번의 클럭을 발생시키게 설정되어 있다.
* 1초에 370,000,000번의 일(연산)을 수행하게 된다.
* 컴퓨터는 이 클럭 신호에 맞춰서 일을 수행한다.
* 왜 그럴까? - 동기화를 위함 + 이를 이해하기 위해서 '디지털 논리 회로'를 공부하면 좋다.
* 덧셈을 수행하는 연산을 진행할 때
* +연산 보다 출력장치가 데이터를 가져가는 속도가 더 빠르다면 이미 한번 가져간 데이터를 출력할 수도 있게된다.
* 이걸 해결하기 위해, 속도가 느린 장치의 장단에 맞춰주면 된다.
* +연산장치의 속도가 더 느리다고 가정하면, + 신호에 맞춰서 데이터를 이동시키면 된다.

## Section 04 - 프로그램의 실행과정
### 위대한 수학자 폰 노이만
* 오늘날 사용하고 있는 컴퓨터의 기본 모델을 제시한 사람
* 초창기 컴퓨터는 여러명의 엔지니어가 진공관 회로의 스위치를 변경해주어야 했다.
* 폰 노이만은 개선된 형태의 컴퓨터를 고민하게 됐다.
* CPU <-> 메모리 <- Load <- 프로그램
* **프로그램이 컴퓨터 내부에 저장되는 구조를 생각해낸 것**
* **프로그램이라는 것이 존재하고, 이 프로그램은 컴퓨터 내부에 저장되어서 순차적으로 실행 되어야 한다.**

### 프로그램의 실행과정
* 전처리기 -> 컴파일러 -> 어셈블러 -> 링커

단계 1 : 전처리기에 의한 치환 작업

* #include, #define 등 #으로 시작하는 지시자의 지시에 따라서 소스코드를 변경한다.

단계 2 : 컴파일러에 의한 번역

* 소스코드를 어셈블리 코드로 번역한다.

단계 3 : 어셈블러에 의한 바이너리 코드 생성

* 바이너리 코드 : 텍스트 코드에 상대되는 뜻
* 1과 0으로만 구성되는 코드를 의미

단계 4 : 링커에 의한 연결과 결합

* 프로그램 내에서 참조하는 함수나 라이브러리들을 하나로 묶는(연결시켜 주는) 작업
* 링커 종료 후 실행 가능한 실행파일이 생성, 이 파일 또한 바이너리 코드로 구성

결론
* 프로그램 실행파일 실행
* 실행파일에는 명령어(바이너리 코드 형식)이 들어있다.
* 로드 (Load) -> 메모리 : 해당 명령어를 메모리에 올린다.
* 단계 1. Fecth : 메모리 상의 명령어를 CPU로 가져오는 작업
* 단계 2. Decode : 가져다 놓은 명령어를 CPU가 해석하는 단계
* 단계 3. Execution : 해석된 명령어의 명령대로 CPU가 실행하는 단계

결국 프로그램의 기본 실행은 **Fecth, Decode, Execution** 단계를 거친다.

## Section05 - 하드웨어 구성의 재접근
### 폰 노이만의 컴퓨터 구조 vs 오늘날의 컴퓨터 구조
* Fetch : 메모리 - I/O 버스 -> 레지스터 중 IR(Instruction Register)
* Decode : 컨트롤 유닛
* Execution : ALU

### 데이터 이동의 기반이 되는 버스(BUS) 시스템
데이터 버스(Data Bus)
* 데이터가 이동하기 위해 필요한 버스
* 데이터 : 명령어, 피연산자 ~

어드레스 버스(Address Bus)
* 주소값을 이동하기 위해 필요한 버스

컨트롤 버스(Control Bus)
* CPU가 원하는 바를 메모리에 전달할 때 사용
* CPU와 메모리가 서로 특별한 사인(Sign)을 주고받는 용도

## 이것만은 알고 갑시다.
1. ALU와 컨트롤 유닛의 기능적 역할

2. 레지스터(Register)의 필요성

3. 클럭 펄스(Clock Pulse)의 필요성

4. Fetch, Decode, Execution

5. 버스 인터페이스 (Bus Interface)