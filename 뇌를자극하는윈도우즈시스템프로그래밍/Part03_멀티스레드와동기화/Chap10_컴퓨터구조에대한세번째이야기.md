# 10장 컴퓨터 구조에 대한 세 번째 이야기
## Section 01 - 절차적 함수 호출(Procedure Call) 지원 CPU 모델
* 함수 호출은 CPU의 도움을 받아야 가능
* 하드웨어 종속적인 부분이 상당 수 존재

### 스택 프레임(Stack Frame) 구조
* 함수 호출 과정에서 할당되는 메모리 블록을 스택 프레임이라 함
* 함수 호출이 완료되면 기존에 있던 지역 변수에 접근이 불가능

### sp 레지스터
* 지역변수를 위한 메모리 공간을 스택이라 표현한 이유는
* 메모리의 구조적 특성(LIFO) 때문이다.
* 스택에 데이터를 쌓거나 반환하기 위해서는 현재 어느 위치까지 데이터를 저장했는지 기억해야 한다.

그것이 바로 sp(stack pointer)라는 레지스터이다.

* 함수가 호출될 때마다 변수가 하나하나 할당될 때마다 sp레지스터는 증가한다.
* 반환될 때는 스택 프레임 단위로 빼주어야 한다.
* sp 레지스터를 아래로 내려주는 것만으로도 선언된 변수를 반환할 수 있다.

그런데 반환할 때 얼만큼 sp 레지스터를 이동시켜야할까?
* 이를 기억할 장치가 필요하다.
* 프레임 포인터 레지스터가 이 역할을 한다.

### 프레임 포인터(Frame Pointer) 레지스터
* 함수가 호출 되었을 때의 위치를 기억하는 레지스터
* 반환될 때 fp 레지스터의 위치로 스택을 되돌린다.

fp 레지스터 만으로 문제가 해결될까?
* 함수가 하나라면 문제가 안된다.
* 중첩될 경우 fp 레지스터가 갱신되므로 문제가 생긴다. (덮어 씌워진다.)

### 스택에 저장하자, 프레임 포인터(Frame Pointer)
* fp 포인터를 어딘가에 저장하면 문제는 해결된다.
* 즉, 함수가 호출될 때마다 fp의 값을 저장해두는 것이다.

## Section 02 - 함수 호출 인자의 전달
* 어셈블리 언어라 해서 레지스터를 일일히 컨트롤 해야하는 것은 아니다.
* 잘 정의된 명령어를 제공함으로 레지스터를 직접 컨트롤하는 수고를 덜어주는 경우도 있다.

보통 함수 호출과 프로시저 호출을 구분
* 함수 호출 : 입력에 대한 출력이 반환값으로 존재하면 함수 호출
* 프로시저 호출 : 출력에 해당하는 반환값 없이 모듈화 해놓은 것, 서브 루틴의 실행

우리의 관심사
1. 함수 호출 시 실행위치의 이동은 어떻게 이루어지는가?
2. 함수 호출 시 전달되는 인자들은 어떻게 함수 내부로 전달되는가?
3. 함수 호출이 끝나고 나면 어떻게 이전 실행위치로 복귀하는가?

### 함수 호출 인자의 전달방식
* 이것또한 CPU 제조사의 표준에 따라 달라진다.
* 함수 호출이 끝나면 지역변수와 마찬가지로 사라지므로
* 스택에 할당된다고 봐도 된다. 그러나 반드시 그런 것은 아니다!
* 성능 향상을 위해서 레지스터에 할당을 하는 표준을 정의하기도 한다.


## Section 03 - 함수 호출(Procedure Call)에 의한 실행의 이동
### 다시 살펴보는 메모리 구조와 프로그램 카운터 (Program Counter)
Code 영역
* 프로그램이 동작하기 위한 프로그램 코드가 올라가는 위치
* 여기서 명령어를 순차적으로 실행시키기 위해 pc 레지스터가 존재한다.
* CPU는 Fetch, Decode, Execution 과정을 계속해서 진행하도록 구현되어 있고
* Fetch 연산이 발생할 때마다 자동으로 pc 레지스터가 증가한다.
* 따라서 우리가 직접 pc를 증가시킬 일은 없다.
* 필요에 따라서 pc 값을 조절시키는 경우도 있긴하다. - 잠시 후 설명

### 함수 호출과 함수 종료
이번에는 첫 번째 질문과 세 번째 질문의 결론을 내릴 차례이다.
1. 함수 호출 시 실행위치의 이동은 어떻게 이루어지는가?
2. 함수 호출 시 전달되는 인자들은 어떻게 함수 내부로 전달되는가?
3. 함수 호출이 끝나고 나면 어떻게 이전 실행위치로 복귀하는가?

함수 호출과 종료 시 pc의 조작이 이루어 진다.
* 함수 호출로 인해 이동해야할 주소값을 pc에 저장해두면 자연스럽게 실행 위치는 이동된다.
* 추가로 반드시 pc의 백업이 필요하다. sp 와 마찬가지로
* 이것또한 스택에 저장한다.

## Section 04 - 함수 호출규약(Calling Convention)
### 함수 호출규약이란?
1. 함수가 호출될 때 스택에 쌓이는 순서가 왼쪽부터인가 오른쪽부터인가?
2. 반환할 때 누가 반환해야하는가?

함수 호출규약 : 함수 호출 시 인자를 전달하는 방식과 스택 프레임을 반환하는 방식을 약속해 놓은 것

### __cdecl, __stdcall + a
1. WINAPI, APIENTRY, CALLBACK 등이 함수 앞에 붙은 경우 __stdcall 방식이다.
2. Visual Studio 에서는 기본적으로 __cdecl 방식을 사용한다.

### 호출규약의 종류와 의미
검색해서 표 참고

간단히 __cdecl과 __stdcall을 정리하면
* __cdecl : 32bit, 오른쪽부터 스택에 쌓음, 호출자가 스택 프레임 정리
* __stdcall : 32bit, 오른쪽부터 스택에 쌓음, 피호출자가 스택프레임 정리(즉, 함수 내부에서)
  * stdcall은 함수 내부에서 호출하므로 호출 시에 인자의 크기를 계산할 수 있어야한다.
  * 가변인자일 경우 stdcall을 사용하지 못한다.

추가로 __fastcall은 함수 호출 인자를 레지스터를 사용해서 빠르게 처리할 수도 있다.
* 무조건 레지스터 사용은 아님

x64 윈도우 환경에서는 MicroSoft의 자체 규약을 사용한다.
* 윈도우에서는 레지스터에 4개 인자 저장 가능
* 리눅스에서는 14개

## 이것만은 알고 갑시다.
1. 스택이 관리되는 방법

2. 함수 호출규약
3. 전달인자와 레지스터