# IOCP
## 효율적인 스레드 모델
비효율적인 스레드 모델(한꺼번에 많은 스레드가 I/O 블락을 대기)
* 스레드 스레싱(thread-thrashing)이 유발될 수 있음
  * 연쇄적으로 페이징 I/O가 발생되고 지나친 컨텍스트 스위칭이 발생
  * 원활하게 작업이 수행되지 않는 상황 발생

고성능 스레드 모델의 목표
* 가능하면 컨텍스트 스위칭을 줄이는 것
* 효율적으로 I/O 요청에 의해 스레드가 블록되면 다른 스레드를 활성화할 방법이 필요함

## IOCP
### IOCP의 핵심 - 병행성 제어
병행성(concurrency)
* IOCP의 핵심(매우 중요함)
* 특정 시점에 실행될 수 있는 스레드의 최대 개수를 의미
* IOCP는 병행성 값을 사용하여 러닝 상태의 스레드 개수를 제어함
  * CreateIoCompletionPort 함수의 4번째 인자(NumberOfConcurrentThreads)
* 즉, IOCP는 결국 스레드 풀

만약 러닝 상태 스레드의 수가 병행성 값과 같아지면
* 대기 상태의 스레드는 실행되지 않음
* 이런 경우 활성 상태의 스레드가 요청을 완료하고 다른 완료 패킷을 확인하여 이것을 처리함
  * 컨텍스트 스위칭의 최소화
* 만약 요청을 완료하는 과정에서 스레드 블록이 발생하고 다른 스레드가 깨어나면
  * 블록에 빠졌던 스레드가 다시 깨어나며 병행성 값보다 더 많은 스레드가 깨어날 수 있음

### 블록 스레드는 스택 방식으로 관리
완료 포트와 연계
* GetQueuedCompletionStatus 한번이라도 호출되면 해당 스레드는 IOCP에 의해 관리됨

완료 포트와 연계된 스레드는 LIFO 방식으로 관리됨
* 즉, 최근에 블록된 스레드에 다음 패킷이 주어짐

오래 블록되어 있던 스레드가 깨어났을 때의 단점
* 자신의 스택이 디스크로 스왑되었을 수 있음
* 페이징 I/O 발생 - 느림
* 스택 방식으로 관리되므로 오래 블록되어 있었던 스레드는 메모리를 적게 점유하게 됨

### IOCP 단점
IOCP 큐에 들어있는 완료 패킷의 개수를 파악 불가능함
* 이것은 모두 논-페이지드 풀에 저장됨
  * 빨리 빨리 처리 못하면 논-페이지드 풀이 증가함
* 직접적인 제어가 불가능함

### 병행성 값을 결정하는 방법
기본적으로는 논리 프로세서의 개수만큼 설정한다고 함
* 그런데 좀 더 최적화하는 방법은?
* 나의 생각
  * CPU 점유율과 활성 스레드 개수를 확인하자
  * 만약 활성 스레드 개수가 병행성 값보다 같거나 높은데 CPU 점유율이 낮게 나온다면?
    * 블록된 스레드 수가 많다는 의미 - 더 많은 스레드를 활성화시켜도 됨
    * 따라서 병행성 값을 높혀주면 됨

### IOCP와 연계시킬 스레드 결정
일단 GQCS를 호출하여 완료 통지를 받을 스레드는 확정적으로 연계가 됨
* 그런데 이것 외에도 연계시켜도 될까?

나의 아이디어
* 내 프로세스에서 모든 스레드를 연계시켜버리자
  * 모니터링 스레드... 등등
* 이렇게 하면 모든 스레드가 IOCP의 관리를 받게되어 활성 스레드 관리 개수에 다른 스레드도 포함됨
* 따라서 내 프로세스의 모든 스레드가 IOCP를 관리를 받게 되어 효율적으로 스레드 자원을 활용 가능할 것