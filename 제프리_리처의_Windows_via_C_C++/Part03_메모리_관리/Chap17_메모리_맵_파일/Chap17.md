# Chapter17 - 메모리 맵 파일
메모리 맵 파일(memory-map file)
* 시스템의 페이징 파일을 사용하는 대신 디스크 상에 존재하는 파일을 물리적 저장소로 사용한다는 것

메모리 맵 파일의 사용 목적
* 시스템은 .exe나 DLL 파일을 읽고 수행하기 위해 사용
  * 페이징 파일의 크기를 일정하게 유지할 수 있으며, 애플리케이션의 시작 시간도 일정하게 유지할 수 있다.
* 디스크에 있는 데이터에 접근하기 위해 사용 가능
  * 파일에 대한 I/O 작업이나 파일의 내용에 대한 버퍼링을 자동적으로 수행해준다.
* 동일한 머신에서 수행 중인 다수의 프로세스 간 데이터를 공유하기 위해 사용 가능
  * 윈도우 내부적으로 프로세스들 사이 데이터 전달하기 위해 메모리 맵 파일을 사용하여 구현
  * 단일 머신 내에서 프로세스 간 데이터를 전달하는 가장 효율적인 방법

## Section01 실행 파일과 DLL 파일에 대한 메모리 맵
CreateProcess를 호출하면 수행하는 절차
1. CreateProcess의 매개변수로 전달된 .exe 파일을 찾는다.
   * 파일이 없으면 FALSE를 반환
2. 시스템은 새로운 프로세스 커널 오브젝트를 생성한다.
3. 시스템은 새로운 프로세스를 위한 전용의 주소 공간을 생성한다.
4. 시스템은 .exe 파일을 수용할 수 있을 만큼의 충분한 영역을 주소 공간 내에 예약한다.
5. 시스템은 예약된 영역에 사용할 물리적 저장소로 시스템의 페이징 파일 대신 .exe 파일 자체를 지정한다.

.exe 파일이 프로세스의 주소 공간에 매핑되고 나면 DLL 파일의 목록을 가져옴
* 이후 LoadLibrary 함수를 반복적으로 호출

위 4~5 과정을 반복한다.
1. 시스템은 DLL 파일을 수용할 수 있는 충분한 영역을 주소 공간 내에 예약한다.
    * 기본 시작 주소는 x86 0x10000000, x64 0x00400000 /BASE 링커 옵션으로 변경 가능
    * 모든 시스템 DLL 파일은 서로 다른 시작 주소를 가지므로 단일의 프로세스 주소 공간에 로드되더라도 서로 겹치지 않는다.
2. DLL 파일이 선호하는 시작 주소에 이미 다른 DLL 파일이나 .exe 파일이 로드되어 있거나 해당 영역으로부터 충분한 공간을 확보할 수 없는 경우
    * 다른 공간을 찾게 된다.
    * 만약 재배치 옵션을 끈다면 실패
3. 시스템은 예약된 영역에 매핑할 물리적 저장소로 시스템의 페이징 파일 대신 디스크 상의 DLL 파일 자체를 지정한다.

만약 DLL 로드에 실패하게 되념 CreateProcess는 FALSE를 반환
* GetLastError를 호출하여 실패 이유를 알 수 있다.

.exe와 DLL 파일의 로드가 끝이나면
* .exe 파일의 startup 코드 수행

### 1. 정적 데이터는 실행 파일과 DLL의 여러 인스턴스들 사이에 공유되지 않는다.
동시에 같은 프로세스를 2개 이상 켜는 경우
* 카피 온 라이트 기능을 이용하여 변경 작업이 일어나지 않도록 한다.
* 애플리케이션은 복사 작업이 완료된 이후에야 메모리 블록에 변경을 수행할 수 있게 된다.

실행 파일과 DLL의 여러 인스턴스들 사이에 정적 데이터 공유하기
* 섹션 기법을 통하여 가능

섹션 특성
* READ : 읽혀질 수 있다.
* WRITE : 쓰여질 수 있다.
* EXECUTE : 수행될 수 있다.
* SHARED : 다수의 인스턴스 사이에서 공유될 수 있다.

실행 파일 내에서 일반적으로 사용되는 섹션의 이름
* .bss : 초기화되지 않은 데이터
* .CRT : 읽기 전용의 C 런타임 데이터
* .data : 초기화된 데이터
* .debug : 디버깅 정보
* .didata : 지연 임포트 네임 테이블
* .edata : 익스포트 네임 테이블
* .idata : 임포트 네임 테이블
* .rdata : 읽기 전용의 런타임 데이터
* .reloc : 재배치 테이블 정보
* .rsrc : 리소스
* .text : .exe나 DLL 코드
* .textbss : 증분 링크 옵션이 설정된 경우 C++ 컴파일러에 의해 생성되는 섹션
* .tls : 스레드 지역 저장소
* .xdata : 예외 처리 테이블


소스코드를 통해 지시어를 사용하여 섹션이름을 지정
```C++
#pragma data_seg("Shared")
LONG g_lInstanceCount = 0;

// 초기화되지 않은 변수는 섹션에 추가되지 않는다.
int a;

// 초기화되지 않았음에도 섹션내에 추가된다.
__declspec(allocate("Shared)) int b;

#pragma data_seg()
```

## Section02 메모리 맵 데이터 파일
운영체제는 프로세스의 주소 공간에 데이터 파일을 매핑할 수 있기 떄문에 크기가 큰 데이터 스트림을 편리하게 다룰 수 있다.

파일의 내용을 바이트 단위로 뒤집는 네 가지 방법
### 1. 한 개의 파일, 한 개의 방법
파일 전체의 내용을 모두 읽을 수 있는 충분한 크기의 메모리 블록을 할당하는 방법
1. 파일을 열고, 메모리로 모두 읽어온 후 파일을 닫는다.
2. 첫 번째 바이트와 마지막 바이트를 교환하고 n번째와 마지막 - n 번째의 바이트를 교환 반복
3. 이후 파일을 다시 열고 메모리 블록의 내용을 파일로 덮어씀

두 가지 단점
* 파일 크기 만큼 메모리를 할당 - 매우 크면 곤란
* 파일의 내용을 뒤집은 후 다시 파일로 저장할 때 수행이 중단되면 기존 파일의 내용이 손상
  * 파일을 복사해둔 뒤 전체 과정이 완료된 이후에 파일의 복사본을 삭제하는 것
  * 추가적인 디스크 공간이 필요

### 2. 두 개의 파일, 한 개의 버퍼
기존 파일을 여는 것과 동시에 파일 크기가 0인 파일을 새로 생성하는 방법
* 내부적으로 8KB 정도의 작은 버퍼를 할당하고, 기존 파일의 가장 끝으로부터 8KB만큼 떨어진 곳으로 이동한 후 파일의 마지막 8KB를 버퍼로 읽어들인다.
* 버퍼의 내용을 뒤집고 새롭게 생성한 파일에 내용을 저장
* 처리과정은 포인터 이동, 읽기, 뒤집기, 쓰기 순으로 반복
* 기존 파일의 시작에 다다를 때까지 반복
* 기존 파일의 크기가 8KB의 배수가 아니라면 특별한 처리가 필요

첫 번째 방법에 비해 구현하기 복잡
* 메모리는 더 효율적으로 사용한다.

두가지 문제점
* 파일 포인터를 이동하기 때문에 첫 번째 작업에 비해 수행 속도가 느릴 수 있다.
* 하드 디스크의 공간을 많이 사용할 가능성이 있다.

### 3. 한 개의 파일, 두 개의 버퍼
두 개의 8KB 크기의 버퍼를 할당하는 것으로 시작
* 프로그램은 파일로부터 가장 앞쪽의 8KB와 가장 뒤쪽의 8KB를 서로 다른 버퍼로 읽어들인다.
* 뒤집고 파일에 덮어씀
* 16KB 배수가 아니라면 중간의 내용은 따로 특별한 처리가 필요

### 4. 한 개의 파일, 버퍼는 사용하지 않음
메모리 맵 파일을 이용
* 파일을 열고 가상 주소 공간 상에 영역을 예약한 뒤 파일의 첫 번째 바이트와 예약된 영역의 첫 번째 위치를 매핑시킨다.
* 텍스트 파일이 0으로 끝나는 경우 _tcsrev 함수를 호출하여 파일의 내용을 모두 뒤집을 수 있다.

단점
* 갑작스러운 중단이 발생하면 데이터가 소실될 가능성이 있다.

## Section03 메모리 맵 파일 사용하기
메모리 맵 파일을 사용하기 위한 세 가지 단계
1. 메모리 맵 파일로 사용할 디스크 상의 파일을 나타내는 파일 커널 오브젝트를 생성하거나 연다.
2. 파일의 크기와 파일의 접근 방식을 고려하여 파일 매핑 커널 오브젝트를 생성한다.
3. 프로세스의 주소 공간 상에 파일 매핑 오브젝트의 전체나 일부를 매핑시킨다.

메모리 맵 파일을 더 이상 사용할 필요가 없을 때 세 가지 단계
1. 프로세스의 주소 공간으로부터 파일 매핑 오브젝트의 매핑을 해제한다.
2. 파일 매핑 커널 오브젝트를 닫는다.
3. 파일 커널 오브젝트를 닫는다.

### 1. 파일 커널 오브젝트를 생성하거나 열기
```C++
HANDLE CreateFile(
    PCSTR pszFileName, 
    DWORD dwDesiredAccess, 
    DWORD dwShareMode, 
    PSECURITY_ATTRIBUTES psa, 
    DWORD dwCreationDisposition, 
    DWORD dwFlagsAndAttributes, 
    HANDLE hTemplateFile
);
```

파일 접근 권한
* 0 : 파일의 내용에 대해서 읽거나 쓸 수 없다. 파일의 특성 정보에 대해서만 접근하고자 하는 경우에 사용한다.
* GENERIC_READ : 파일의 내용을 읽을 수만 있다.
* GENERIC_WRITE : 파일의 내용을 쓸 수만 있다.
    * or 비트연산으로 동시부여 가능

파일 공유 모드
* 0 : 추가적으로 파일 열기를 시도할 경우 실패한다.
* FILE_SHARE_READ : 쓰기 옵션으로 열면 실패
* FILE_SHARE_WRITE : 읽기 옵션으로 열면 실패
  * or 비트연산으로 동시에 주어지면 모두 성공

### 2. 파일 매핑 커널 오브젝트 생성
CreateFileMapping 함수
* 파일 매핑 오브젝트가 필요로 하는 물리적 저장소의 크기를 알려주어야 함

```C++
HANDLE CreateFileMapping(
    HANDLE hFile,
    PSECURITY_ATTRIBUTES psa,
    DWORD fdwProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    PCTSTR pszName
);
```

페이지 보호 특성
* PAGE_READONLY
* PAGE_READWRITE
* PAGE_WRITECOPY
* PAGE_EXECUTE_READ
* PAGE_EXECUTE_READWRITE

페이지 보호 특성과 더불어 다섯 가지 섹션 특성을 비트 OR 연산을 이용하여 fdwProtect 매개변수에 전달할 수 있다.
* 섹션이란 메모리 매핑의 다른 말

섹션 특성
* SEC_NOCACHE
  * 매핑된 파일에 대해 캐시를 수행하지 못하게 한다.
  * 주로 디바이스 개발자들에 의해 사용
* SEC_IMAGE
  * 매핑할 파일이 PE 파일 이미지임을 알려준다.
  * 이것을 인자로 전달하면 시스템은 파일 이미지를 매핑하고 적절한 페이지 보호 특성을 결정
* SEC_RESERVE
* SEC_COMMIT
* SEC_LARGE_PAGES

dwMaximumSIzeHigh와 dwMaximumSizeLow 파라미터
* 각각 상위 32비트, 하위 32비트
* 파일의 크기가 4GB 이하라면 dwMaximumSizeHigh는 항상 0
* 둘 다 0인 경우 함수는 NULL을 반환하고 실패

### 3. 파일의 데이터를 프로세스의 주소 공간에 매핑하기
파일 매핑 오브젝트를 생성한 후에는 커밋 단계를 거쳐야 한다.

```C++
PVOID MapViewOfFile(
  HANDLE hFileMappingObject,
  DWORD dwDesiredAccess,
  DWORD dwFileOffsetHigh,
  DWORD dwFileOffsetLow,
  SIZE_T dwNumberOfBytesToMap
);
```

hFileMappingObject
* 전 단계에서 생성한 파일 매핑 객체 전달

dwDesiredAccess
* 데이터에 어떻게 접근할 것인지 나타내는 값

메모리 맵 파일에 요구되는 접근 권한
* FILE_MAP_WRITE
* FILE_MAP_READ
* FILE_MAP_ALL_ACCESS
* FILE_MAP_COPY
* FILE_MAP_EXECUTE

나머지 세 개의 매개변수
* 주소 공간 상에 영역을 예약
* 물리적 저장소를 매핑하기 위해 필요한 정보들

주소 공간에 매핑된 파일의 일부를 뷰(view)라고 함

dwFileOffsetHig, dwFileOffsetLow
* 데이터 파일의 어떤 부분을 뷰로 구성할 것인가 하는 정보
* 16EB 크기의 파일을 지원하므로 상하위 비트를 나누어서 전달
* 파일의 오프셋 값은 반드시 Allocation granularity의 배수 값으로 전달

dwNumberOfBytesToMap
* 얼마나 많은 데이터를 주소 공간상에 매핑할지에 대한 정보를 전달해 주어야 한다.
* 주소 공간 상에 얼마만큼의 영역을 예약할 것인지를 지정하는 것과 동일
* 0을 전달하면 시스템은 지정된 오프셋으로부터 파일의 끝까지를 뷰로 구성하려 시도

만일 FILE_MAP_COPY 플래그를 지정
* 페이징 파일로부터 물리적 저장소를 커밋하게 된다.
* 커밋하는 공간의 크기는 dwNumberOfBytesToMap 매개변수에 의해 결정
* 읽는 동안에는 아무런 작업도 일어나지 않으며 시스템 페이징 파일에 커밋된 페이지를 사용하지 않음
* 수정을 시도하려는 순간 페이징 파일의 커밋된 페이지들 중 하나를 취하여 복사하고 복사본을 수정

### 4. 프로세스의 주소 공간으로부터 파일 데이터에 대한 매핑 해제하기
```C++
BOOL UnmapViewOfFile(PVOID pvBaseAddress);
```
* 예약되었던 영역을 삭제

시스템은 파일 데이터의 페이지를 버퍼링하기 때문에 즉각적으로 파일에 반영되지는 않는다.
* FlushViewOfFile 함수를 호출하여 변경된 내용을 디스크 이미지에 강제로 저장하도록 할 수 있다.

```C++
BOOL FlushViewOfFile(
  PVOID pvAddress,
  SIZE_T dwNumberOfBytesToFlush
);
```

pvAddress
* 메모리 맵 파일의 뷰에 포함된 주소를 지정
* 페이지 경계에 맞추어 내림이 수행됨

dwNumberOfBytesToFlush
* 디스크로 강제 저장하고자 하는 영역의 바이트 수를 지정
* 페이지 크기에 맞춰 올림이 수행됨

### 5, 6. 파일 매핑 오브젝트와 파일 오브젝트 닫기
CloseHandle을 통해 파일 매핑 오브젝트를 닫아주면 된다.
* 그러나 MapViewOfFile 함수가 파일 매핑 오브젝트의 Usage count를 증가시키기 때문에
* 파일 매핑 오브젝트가 즉시 삭제되지 않을 수 있다.