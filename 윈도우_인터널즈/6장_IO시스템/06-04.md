# I/O 시스템 04 - I/O 완료 포트
## I/O 완료 포트
서버의 목표
* 다중 스레드 사용을 통한 최대한의 병렬 처리를 하는 동안 스레드가 불필요하게 블록되는 것을 피해 가능하면 컨텍스트 스위칭 횟수를 줄이는 것
* 이상적인 것은 프로세서마다 한 클라이언트의 요청을 서비스하는 한 스레드가 있고 요청을 완료할 때 추가 요청이 있다면 스레드가 블록되지 않는 것
* 따라서 요청을 처리하는 스레드가 I/O에 의해 블록됐을 때 다른 스레드를 활성화하는 방법이 있어야 함

### IoCompletion 객체
IoCompletion 익스큐티브 객체
* 다중 파일 핸들과 연관된 I/O의 완료 작업의 핵심인 완료 포트(Completion port)
  * 윈도우 API에 공개됨
* 파일과 완료 포트가 연결되면 이 파일의 완료되는 비동기 I/O 동작의 결과는 완료 포트에 큐잉되는 완표 패킷(completion packet)이 됨
* 스레드는 단순히 완료 포트에 큐잉될 완료 포트를 대기함으로 어떤 I/O라도 완료되기를 기다릴 수 있음
  * WaitForMultipleObjects 같은 API 함수를 통해 유사한 기능 제공
* 시스템의 도움으로 병행성을 제어할 수 있다는 장점
  * 병행성이란 클라이언트 요청을 서비스할 수 있는 스레드 개수

완료 포트를 생성할 때 병행성 값 지정 가능
* CreateIoCompletionPort의 NumberOfConcurrentThreads 매개변수인 듯 함
* 특정 시점에 실행되어야 하는 스레드의 최대 개수를 가리킴
  * 해당 포트와 연관된 스레드여야 함
* 윈도우는 어플리케이션이 얼마나 많은 활성 스레드를 가질 것인지 제어하기 위해 이 값을 사용
* 활성 스레드의 개수가 병행성 값과 같아진다면 완료 포트에서 대기 중인 스레드는 실행되지 못할 것
  * 대신 활성 스레드 중 하나가 자신의 현재 요청을 완료하고 또 다른 패킷이 포트에 대기 중인지 확인함
  * 이런 경우 스레드는 단순히 대기 중인 패킷을 가져와 처리함
  * 컨텍스트 스위칭이 발생하지 않고 CPU는 거의 모든 능력을 사용함

### 완료 포트 사용
완료 포트 생성
* CreateIoCompletionPort 호출하여 생성
* 완료 포트에 블록된 스레드는 포트와 연결되고 후입선출 순서로 깨어남
  * 따라서 가장 최근에 블록된 스레드에게 패킷이 주어짐
  * 오래된 스레드는 자신의 스택이 디스크로 스왑 아웃되었을 가능성이 높기 때문

![6-23](https://github.com/user-attachments/assets/da46651d-2900-4a77-ad36-0328f0e67f2f)

완료 포트 동작의 대략적인 과정
* 서버는 엔드포인트를 완료 포트와 연관시킴
* 서버 스레드는 GetQueuedCompletionStatus(Ex) 호출을 통해 포트에 도착하는 요청을 대기
* 스레드가 완료 포트로부터 패킷을 전달받으면 스레드는 활성 스레드가 되어 처리 시작
  * 만약 활성 도중 I/O가 발생해 블록된다면
  * 윈도우는 이런 일을 탐지하고 다른 대기 중인 스레드를 깨움
  * 활성 스레드 수가 병행성 값보다 높아질 수 있음
  * 마이크로소프트는 활성 스레드를 프로세서 개수와 거의 일치하게 설정하는 것을 권장

병행성 한계가 1인 경우
1. 클라이언트의 요청이 들어오고 스레드가 요청을 처리하기 위해 디스패치됨
2. 두 번째 요청이 도착하지만 병행성 한계점이므로 두 번째 스레드는 진행되지 않음
3. 첫 번째 스레드가 파일 I/O를 대기하기 위해 블록되어 비활성
4. 두 번째 스레드가 해제됨
5. 두 번째 스레드가 활성화된 도중 첫 번째 스레드의 I/O가 완료되어 다시 활성화
    * 이 시점에 병행성 값은 2
    * 대부분의 시간에서 활성 스레드의 수는 병행성 한계이거나 초과

완료 포트에 완료 패킷을 삽입하기
* PostQueuedCompletionStatus 함수를 통해 삽입할 수 있음
* 일반적으로 안전한 서버의 종료를 위해 사용함

애플리케이션은 스레드 비종속적 I/O를 사용하여 스레드가 자신들의 I/O와 연관되고 완료 포트 객체와 연관되는 것을 방지
* 이것으로 확장성 이점과 컨텍스트 전환을 최소화할 수 있음
* 일반적으로 I/O 완료는 I/O를 일으킨 스레드에 의해 실행되나
  * 완료 포트와 연관된 I/O는 임의의 대기 중인 스레드를 사용

### I/O 완료 포트 동작
완료 포트 생성
* CreateIoCompletionPort 호출 인자로 완료 포트 핸들을 NULL로 전달하여 완료 포트 생성
* 호출 결과로 NtCreateIoCompletion 실행
  * IoCompletion 객체는 커널 큐(kernel queue)로 불리는 커널 동기화 객체를 포함
    * 시스템 서비스는 이 객체를 생성하고 초기화
    * 큐가 포트 메모리의 시작 부분에 위치
    * 즉, 포트 포인터는 큐 객체를 가리킴
* KeInitializeQueue를 내부에서 호출하여 큐 객체를 초기화

파일 핸들과 완료 포트 연결
* CreateIoCompletionPort 함수를 호출
* NtSetInformationFile 시스템 서비스는 파일 핸들을 주 인자로 사용해 실행됨
* 설정되는 정보 클래스는 FileCompletionInformation이고, CreateIoCompletionPort의 완료 포트 핸들과 CompletionKey 인자가 데이터 값임
* NtSetInformationFile은 파일 객체를 얻기 위해 파일 핸들을 역참조하고 완료 컨텍스트 데이터 구조체를 할당함
  * 마지막으로 파일 객체 내부 필드인 CompletionContext가 컨텍스트 구조체를 가리키게 설정

파일 객체에 대한 비동기 I/O 작업이 완료될 때
* I/O 관리자는 파일 객체의 CompletionContext 필드가 NULL이 아닌지 확인
* NULL이 아니라면 I/O 관리자는 완료 패킷을 할당하고 패킷을 추가할 큐로 포트를 제공하면서 KeInsertQueue를 호출하여 패킷을 완료 포트의 큐에 넣음

서버 스레드가 GetQueuedCompletionStatus를 호출할 때
* 시스템 서비스인 NtRemoveIoCompletion이 실행
  * 인자에 대한 검증을 하고 완료 포트의 핸들을 포트를 가리키는 포인터로 변환을 마치고 IoRemoveCompletion 호출
* IoRemoveCompletion은 KeRemoveQueueEx를 호출

고성능 시나리오에서 여러 I/O가 완료되는 것이 가능
* 그럼에도 스레드는 블록되지 않고 한 아이템을 얻을 때마다 여전히 커널을 호출
* GetQueuedCompletionStatus(Ex) API는 유저 모드에서 커널 모드까지의 경로를 감소시키고 최상의 효율을 유지하며 하나 이상의 I/O 완료 상태를 구해오는 것을 가능하게 함
* 내부적으로 NtRemoveIoCompletionEx 함수를 통해 구현되어 있음
  * KeRemoveQueueEx에 전달된 큐잉된 아이템의 개수를 인자로 하여 IoRemoveIoCompletion을 호출

KeRemoveQueueEx, KeInsertQueue
* 완료 포트의 숨겨진 엔진들
* I/O 완료 패킷을 기다리는 스레드가 활성화되어야 하는지 여부를 결정하는 함수
* 내부적으로 큐 객체는 활성 스레드의 현재 개수와 최댓값을 유지
  * KeRemoveQueueEx를 호출할 때 현재 개수가 최대치와 같거나 초과
    * 이 스레드는 완료 패킷을 처리하기 위해 순서를 기다리는 LIFO 스레드 리스트에 추가
    * 이 스레드 리스트는 큐 객체를 hang off(객체의 추가적 참조가 없다면 해제되게 함) 시킴
    * KTHREAD 구조체는 큐 객체를 참조하는 포인터를 갖고 있음

완료 포트가 아닌 어디선가 블록되는 스레드를 추적
* 스레드 블록을 유발할 수 있는 스케줄러 루틴은 스레드의 큐 포인터를 확인
  * 만약 NULL이 아니라면 큐와 연관된 활성 스레드의 개수를 줄이는 함수인 KiActivateWaiterQueue를 호출
* 결과적으로 최댓값보다 작고 적어도 하나의 완료 패킷이 큐에 있다면 큐의 스레드 리스트 맨 앞에 있는 스레드가 깨어나고 가장 오래된 패킷을 받음
* 반대로 큐와 연관된 스레드가 깨어날 때마다 KiUnwaitThread를 실행하여 큐의 활성 카운터를 증가시킴

PostQueuedCompletionStatus 함수
* NtSetIoCompletion 시스템 서비스의 실행으로 이어짐
* KeInsertQueue를 사용하여 지정된 패킷을 완료 포트로 넣음

I/O 완료 포트 객체의 동작

![6-24](https://github.com/user-attachments/assets/1de23733-792e-4c53-85da-cb4686009045)

I/O 완료 포트의 정확한 통지 모델은 SetFileCompletionNotificationModes API로 조절 가능
* 코드를 수정해야하는 단점은 있지만 추가적인 이점과 더 많은 처리량 제공

세 가지 통지 모드 최적화가 지원
* 성공 시 완료 포트 생략(FILE_SKIP_COMPLETION_PORT_
ON_SUCCESS=1)
  * 다음 세 가지 조건이 만족되면 완료 엔트리를 큐잉하는 작업을 하지 않음
    1. 완료 포트가 파일 핸들과 연결
    2. 비동기적 I/O
    3. PENDING 없이 즉시 완료
* 핸들 이벤트 설정 생략(FILE_SKIP_SET_EVENT_ON_HANDLE=2) \
  * 반환 값이 성공 혹은 PENDING 그리고 비동기 I/O
    * 파일 객체에 이벤틀르 설정하지 않음
* 패스트 I/O 시 유저 이벤트 설정 생략(FILE_SKIP_SET_USER_EVENT_ON_FAST_IO=4)
  * 패스트 I/O 경로를 따라서 성공 코드 반환 혹은 PENDING
    * 명시적인 이벤트를 설정하지 않음
