# I/O 시스템 03 - I/O 처리
## I/O의 유형
### 동기적 I/O와 비동기적 I/O
동기적 I/O
* 호출자에게 제어를 반환하기 전에 I/O 명령을 완료함
* I/O 요청이 가장 단순한 형태로 사용되는 케이스
  * ReadFile과 WriteFile을 동기적으로 사용하는 것

비동기 I/O(Asynchronous I/O)
* 애플리케이션이 다수의 I/O 요청을 발생하고 장치가 I/O 동작을 수행하는 동안에도 계속 실행할 수 있게 함
* I/O 명령이 진행 중인 동안에도 다른 작업을 할 수 있음
  * 처리량 향상
* 비동기 I/O를 사용하려면
  * FILE_FLAG_OVERLAPPED 플래그를 지정해야 함
  * 물론 스레드는 비동기적 I/O 동작을 발생시킨 후 디바이스 드라이버가 데이터 전송을 완료할 때까지 I/O 동작에 관련된 어떤 데이터도 접근하지 않게 주의해야 함
  * 스레드는 I/O가 완료될 때 시그널되는 동기화 객체(이벤트 객체 혹은 I/O 완료 포트)의 핸들을 감시해 I/O 요청의 완료와 스레드의 실행을 동기화시켜야 함

I/O 수행
* 요청한 I/O 동작이 드라이버로 전달되면 I/O 명령은 내부적으로 I/O 요청의 유형과 관계없이 비동기적으로 수행
* 즉, I/O 요청이 시작되면 디바이스 드라이버는 I/O 시스템으로 가능한 빨리 복귀해야 함
* I/O 시스템이 즉시 호출자에게 복귀할 것인지는 핸들이 동기, 비동기로 열렸는지에 따라 결정됨

읽기 동작이 시작될 때의 제어 흐름
* 파일 객체의 operlapped 플래그에 따라 대기가 이뤄진다면 이 대기는 NtReadFile 함수에 의해 커널 모드에서 이루어짐

![6-8](https://github.com/user-attachments/assets/e1d49b47-653f-451d-a557-11c6e4a06b52)

펜딩된(Pending) 비동기 I/O의 상태를 테스트 하는 방법
* HasOverlappedIoCompleted 매크로 사용
* GetOverlappedResult(Ex) 함수
* I/O 완료 포트 사용시 GetQueuedCompletionStatus(Ex) 함수

### 패스트 I/O
* I/O 시스템 I/O 요청을 완료하기 위해 IRP를 생성하는 것을 건너뜀
* 대신 드라이버 스택으로 직접 접근하게 하는 특별한 메커니즘
* IRP의 느린 특정 I/O 경로를 최적화하기 위해 사용
* 드라이버는 자신의 패스트 I/O 진입점을 드라이버 객체의 PFAST_IO_DISPATCH 포인터가 가리키는 구조체에 등록해야 함

### 맵 파일 I/O와 파일 캐싱
맵 파일 I/O(Mapped File I/O)
* 디스크에 존재하는 파일을 프로세스 가상 메모리의 일부분 처럼 볼 수 있는 것을 말함
* 데이터를 버퍼링하거나 디스크 I/O를 수행하지 않고 커다란 배열처럼 파일에 접근 가능
* 프로그램은 메모리에 접근하고 메모리 관리자는 자신의 페이징 메커니즘으로 디스크 파일로부터 정확한 페이지를 로드
* 가상 주소 공간에 쓰기 작업을 할 때 메모리 관리자가 일반 페이징의 일부분 처럼 파일에 변화된 내용을 기록

맵 파일 I/O 사용
* CreateFileMapping, MapViewOfFile 등의 함수로 유저 모드에서 사용 가능
* 운영체제 내부에서 파일 캐싱과 이미지 활성화와 같은 중요한 동작에서 사용함
  * 주 사용처는 캐시 관리자
  * 캐시 관리자를 이용해 I/O 바운드 프로그램에 좀 더 빠른 응답 시간을 제공하기 위해 파일 데이터를 가상 메모리에 매핑함
  * 호출자가 파일을 사용할 때 메모리 관리자가 접근된 페이지를 메모리로 가져옴

캐싱 시스템
* 윈도우 캐시는 메모리의 사용 가능 여부에 따라 늘어나거나 줄어듬
  * 메모리 관리자의 일반 워킹셋 메커니즘을 사용하기 때문
* 메모리 관리자의 페이징 시스템 장점을 활용하여 캐시 관리자는 메모리 관리자가 이미 실행한 작업을 반복하지 않게 함
  * 2권의 14장에서 자세히 설명함

### 스캐터/게더 I/O
* ReadFileScatter와 WriteFileGather를 통해 사용할 수 있는 고성능 I/O
* 디스크에서 파일의 연속된 영역에 대응하는 가상 메모리의 여러 버퍼에 개별 I/O 요청을 하는 대신 하나의 읽기 요청이나 쓰기 요청을 할 수 있음
* 파일은 넌캐시드(noncached) I/O로 열려있어야 함
* 유저 버프는 page-aligned 여야 하고, 비동기 I/O 여야 함
* 대용량 저장 장치의 I/O 라면 장치 섹터 경계에 정렬되어야 하고 섹터 크기의 배수 길이를 가져야 함

## I/O 요청 패킷
* I/O 시스템이 I/O 요청을 처리할 때 필요한 공간을 저장하는 곳
* 스레드가 I/O API를 호출할 때 I/O 관리자는 I/O 동작이 I/O 시스템을 통한 진행 정도에 따라 그 동작을 나타내는 용도로 IRP를 만듬

I/O 관리자는 프로세서 당 존재하는 세 개의 IRP 넌페이지드 룩 어사이드 리스트 중 하나에서 IRP를 할당
* 작은 IRP 룩 어사이드 리스트
  * 하나의 스택 로케이션을 갖는 IRP를 저장
* 중간 크기의 IRP 룩 어사이드 리스트
  * 최대 4개의 스택 로케이션을 갖는 IRP를 포함
* 큰 IRP 룩 어사이드 리스트
  * 4개보다 더 많은 스택 로케이션을 갖는 IRP를 포함
  * 기본적으로 14개의 스택 로케이션을 갖는 IRP를 저장
  * 최대 20개까지 늘릴 수 있음

이들 리스트는 전역 룩 어사이드 리스트의 지원을 받음
* CPU 간 효율적인 IRP 흐름이 가능케 하기 위해
* 큰 IRP 룩 어사이드 리스트보다 더 많은 로케이션을 필요로 하면 넌페이지드 풀에서 할당
* I/O 관리자는 IoAllocateIrp 함수로 IRP를 할당
  * 드라이버 개발자가 이용 가능
* I/O 관리자는 IRP를 할당하고 초기화한 후 호출자의 파일 객체를 가리키는 포인터를 IRP 내부에 저장

IRP 구조체

![6-9](https://github.com/user-attachments/assets/4ebf90c6-ee64-41ef-b747-6bc04d1629fd)
* IoStatus
  * 실제 코드 자체인 Status와 경우에 따라 달라지는 다형성의 값의 Information으로 이뤄진 IRP의 상태
  * 예를들어 읽기 쓰기라면 읽기 쓰기 바이트 수
* MdlAddress
  * 메모리 디스크립터 리스트에 대한 옵션 포인터 - 요청되지 않는다면 NULL
  * 물리 메모리 내 버퍼 정보를 나타내는 구조체
* I/O 스택 로케이션 카운트와 현재 스택 로케이션 카운트
  * 스택 로케이션의 총 개수와 현재 스택 로케이션
* 사용자 버퍼
  * 클라이언트가 제공한 버퍼의 포인터
* 사용자 이벤트
  * 비동기 I/O 동작에 사용됐던 커널 이벤트 객체
  * I/O 동작이 완료될 때 일방적으로 통지되는 이벤트
* 취소 루틴
  * IRP가 취소되는 경우에 I/O 관리자가 호출하는 함수
* AssociatedIrp
  * 세 필드 중 하나를 나타내는 유니온 값
  * 버퍼드 I/O 기법을 사용하면 SystemBuffer 멤버가 사용됨
  * MasterIrp 멤버는 원래의 작업을 서브 Irp로 나누는 방법을 제공
    * 마스터 IRP는 자신의 모든 서브 IRP가 완료된 이후에야 완료되었다고 간주

### I/O 스택 로케이션
IRP는 항상 하나 이상의 I/O 스택 로케이션을 동반
* 스택 로케이션 개수는 IRP가 향하는 디바이스 노드 내의 디바이스 계층의 수와 동일
* I/O 동작 정보는 IRP 바디와 현재 I/O 스택 로케이션으로 나뉘어 있음
  * 현재의 의미 특정 디바이스 계층에 대해 설정된 값

IRP가 생성될 때
* 요청 I/O 스택 로케이션의 개수가 IoAllocateIrp로 전달
* I/O 관리자는 디바이스 노드에서 최상위 디바이스로 향하는 IRP의 바디와 첫 번째 I/O 스택 로케이션만 초기화
* 디바이스 노드에서 각 계층은 IRP를 다음 디바이스로 내려보내기로 결정하면 다음 I/O 스택 로케이션의 초기화를 책임

IO_STACK_LOCATION 구조체

![6-10](https://github.com/user-attachments/assets/536afd9e-f5c4-4c02-8f08-1538a13d7500)
* 메이저 함수
  * 디스패치 루틴 코드로 알려진 주 코드
* 마이너 함수
  * 일부 함수에서 메이저 함수를 확장하는 데 사용
* 매개변수
  * 복잡한 유니온 유형의 구조체
  * 각각 특정 메이저 함수 코드나 메이저/마이너 코드의 조합으로 유효한 의미를 지님
* 파일 객체와 디바이스 객체
  * FILE_OBJECT와 DEVICE_OBJECT
* 완료 루틴
  * IoSetCompletionRoutine(Ex) DDI를 사용해 드라이버가 등록할 수 있는 함수
  * 아래 계층의 드라이버에 의해 IRP가 완료될 때 호출됨
    * 이 시점에 드라이버는 IRP의 완료 상태를 살펴보고 필요한 후처리 작업 가능
* 컨텍스트
  * 완료 루틴에 전달되는 값
  * IoSetCompletionRoutine(Ex)에서 설정

IRP 바디와 I/O 스택 로케이션으로 정보를 분리하면
* 원본 요청의 인자는 유지하며 디바이스 스택에서 다음 디바이스에 대한 I/O 스택 로케이션 인자의 변경이 가능해짐

처리 중인 IRP
* 각 IRP는 보통 I/O를 요청했던 스레드와 관련된 IRP 리스트에 저장됨
* 이렇게 하면 스레드가 미처리된 I/O 요청이 있는 채로 종료될 때 취소를 할 수 있게 함
* 부가적으로 페이징 I/O IRP(취소 불가능하지만) 또한 폴트를 유발한 스레드와 연관됨

현재 스레드가 I/O를 시작한 그 스레드라서 I/O를 완료하는 데 APC를 사용하지 않는 경우
* 윈도우는 비종속적 I/O 최적화를 사용할 수 있음
* APC 전달이 요구되는 대신 페이지 폴트가 내부적으로 발생함을 의미

### IRP 흐름

하드웨어 기반 장치 드라이버에서 일반적인 IRP 흐름
* 디바이스 스택 내의 아래 계층의 네임드 디바이스에 대한 핸들이 오픈됐더라도 IRP는 항상 최상위 계층의 디바이스로 전달됨

![6-11](https://github.com/user-attachments/assets/e6ae87c9-953b-4516-8b68-c2ea8180a62b)

I/O 관리자만이 IRP를 생성하는 것은 아님
* 플러그앤플레이 관리자와 전원 관리자 또한 IRP를 생성할 책임을 가짐
  * IRP_MJ_PNP, IRP_MJ_POWER 메이저 함수 코드에 대한 IRP

IRP를 받은 드라이버가 수행하는 작업
* IoCompleteRequest를 호출해 IRP를 완료 가능
  * IRP가 유효하지 않은 매개변수를 갖는 경우
  * 레지스트리의 값을 읽는 경우처럼 요청된 동작이 빠르게 즉시 완료될 수 있는 경우
  * 드라이버는 IoGetCurrentIrpStackLocation을 호출해 자신이 참조해야 할 스택 로케이션의 포인터를 구함
* 드라이버는 선택적으로 일부 처리를 하고 다음 계층으로 IRP를 보낼 수 있음
  * 요청을 아래로 보내기 전 드라이버는 다음 드라이버가 살펴보게 될 다음 I/O 스택 로케이션을 준비시켜야 함
  * 드라이버 스택 로케이션의 변경을 원치 않으면 IoSkipCurrentIrpStackLocation 사용 가능
  * IoCopyIrpStackLocationToNext를 사용해 스택 로케이션의 복사본을 만들고 IoGetNextIrpStackLocation을 사용해 복사된 스택 로케이션의 포인터를 구해 스택 로케이션 수정 가능
  * 다음 I/O 스택 로케이션의 준비가 되면 드라이버는 IoCallDriver를 호출하여 IRP 전달을 함
* 드라이버는 IRP를 아래로 전달하기 전 IoSetCompletionRoutine(Ex)를 호출하여 완료 루틴 전달 가능
  * 최하단을 제외한 모든 계층은 완료 루틴을 등록할 수 있음
  * 아래 계층의 드라이버가 IoCompleteRequest를 호출한 이후부터 IRP는 상단으로 거슬러 올라오며 등록된 역순으로 완료 루틴을 호출함
  * 실제로 IRP의 원주인(I/O관리자 혹은 PnP관리자, 전원 관리자)은 이 메커니즘을 사용해 필요한 후처리를 하고 마지막으로 IRP를 해제

## 단일 계층 하드웨어 기반 드라이버로의 I/O 요청
단일 계층의 커널 모드 디바이스 드라이버에서 일반적인 IRP 처리 상황

![6-12](https://github.com/user-attachments/assets/727eb3dd-caae-4a64-bf92-92c3bc5f13d7)

일반적인 사항을 순서대로 살펴봄
* 두 유형의 수평 분할 선이 존재함
  * 첫 번째(실선)는 통상적인 유저 모드/커널 모드 분할선
  * 두 번째(점선)는 요청 스레드 컨텍스트와 임의의 스레드 컨텍스트에서 실행하는 코드를 분할

이런 컨텍스트는 다음과 같이 정의됨
* 요청 스레드 컨텍스트 영역
  * 실행 스레드가 I/O 동작을 요청한 원래의 스레드임을 나타냄
  * 스레드가 원래의 호출을 한 스레드 - 프로세스 컨텍스트가 원래의 프로세스임
  * 따라서 I/O 동작에 제공된 유저 버퍼를 포함하는 유저 모드 주소 공간을 직접 접근할 수 있기 때문에 매우 중요함
* 임의의 스레드 컨텍스트 영역은 이들 함수를 실행하는 스레드가 임의의 스레드가 될 수 있음을 나타냄
  * 즉, 요청 스레드가 아닐 수 있고, 보이는 유저 모드 프로세스 주소 공간은 원래의 프로세스의 것이 아닐 수 있음
  * 이 컨텍스트에서 유저 모드 주소로 유저 버퍼에 근하면 손상이 발생할 수 있음

<br/>

* 4개의 블록으로 구성된 커다란 사각형(디스패치 루틴, Start I/O 루틴, ISR, DPC 루틴)은 드라이버가 제공한 코드임을 나타냄
  * 그 외는 모두 시스템이 제공
* 많은 유형의 장치에서 그렇듯 여기에 하드웨어 장치는 한 번에 하나의 요청을 처리할 수 있다 가정
  * 여러 요청을 처리할 수 있어도 기본 흐름은 동일

위 그림의 소개된 사건들의 순서
1. 클라이언트 애플리케이션은 ReadFile과 같은 윈도우 API 호출
   * ReadFile은 네이티브 NtReadFile(Ntdll.dll)을 호출
   * 이 함수는 커널 모드 익스큐티브 NtReadFile로 스레드 전환
2. I/O 관리자는 자신의 NtReadFile 구현에서 클라이언트가 제공한 버퍼가 올바르게 접근 가능한지 무결성 검사 수행
   * I/O 관리자는 관련된 드라이버를 찾고 IRP를 할당해 초기화하고 IoCallDriver를 사용하여 적절한 디스패치 루틴을 호출
3. 드라이버는 처음으로 이 IRP를 봄
   * 일반적으로 요청 스레드에서 이뤄짐
     * 상위 필터가 IRP를 보관하다 다른 스레드에서 IoCallDriver를 호출한 경우 예외
   * 예외 경우가 아니라고 가정
   * 드라이버 디스패치 Read 콜백은 두 가지 작업을 함
     * 요청이 실제로 의미하는 것을 몰라 I/O 관리자가 할 수 없던 추가적 검사(버퍼 크기 등)를 수행
     * DeviceIoControl 동작의 경우 드라이버는 제공된 I/O 컨트롤 코드가 지원되는 것인지 검사
       * 만약 이런 검사가 실패하면 IRP를 실패 상태로 완료시키고 즉시 복귀
       * 검사가 성공하면 드라이버는 busy 비트를 설정하고 Start I/O 루틴(DriverEntry에 존재)을 호출 (IoStartPacket 함수)
       * 하드웨어 장치가 바쁜 상태(busy 비트 확인)라면 IRP는 드라이버가 관리하는 큐에 넣어짐
         * 이때 IRP는 PENDING 상태를 반환
     * IoStartPacket 함수를 사용하지 않더라도 비슷한 흐름에서 동작
4. 장치가 바쁘지 않다면 Start I/O 루틴이 디스패치 루틴으로부터 바로 호출
   * 여전히 호출을 한 스레드 컨텍스트
   * 그러나 그림에서는 Start I/O 루틴이 임의의 스레드 컨텍스트에서 호출되고 있음
     * DPC 루틴에서 보통 이런 상황이 발생
   * Start I/O의 목적은 IRP 관련 인자를 가져와 하드웨어 장치를 프로그래밍 하는 것
   * 완료 이후 호출은 복귀하고 드라이버에서는 특별한 코드가 실행됮 ㅣ않음
     * 하드웨어는 지시된 작업을 수행
     * 하드웨어가 동작하는 동안 같은 스레드나(비동기 동작) 동일한 장치에 다른 스레드에 의해 추가적인 요청이 올 수 있음
       * 이 경우 디스패치 루틴은 장치가 바쁜 상태임을 알고 IRP를 IRP 큐에 넣음
         * IoStartPacket을 호출하는 것도 한 방법
5. 장치에서 현재 동작이 완료되면 인터럽트를 발생
   * 커널 트랩 핸들러는 인터럽트를 처리하기 위해 선정된 CPU에서 현재 CPU의 컨텍스트를 저장하고 인터럽트와 연관된 IRQL까지 IRQL을 상승시키고 등록된 ISR로 점프
6. DIRQL에서 실행되는 ISR은 가능한 작은 일만 수행
   * ISR의 마지막 작업으로 DPC를 큐에 넣음
   * DPC의 이점
     * DIRQL과 DPC/디스패치 IRQL(2) 사이의 블록된 인터럽트가 더 낮은 우선순위를 갖는 DPC 처리가 일어나기 전 진행할 수 있다는 것
     * 따라서 중간 레벨의 인터럽트는 좀 더 빠르게 수행될 수 있고 시스템 지연을 줄여줌
7. 인터럽트가 해제된 이후 커널은 DPC 큐가 비어있지 않음을 감지하고 소프트웨어 인터럽트를 통해 DPC 처리 루프로 점프
8. DPC는 큐에서 꺼내지고 IRQL 2에서 실행 - DPC에서 하는 일
   * 큐에서 다음 IRP를 가져와 장치에 새로운 동작을 시킴
     * 장치가 유휴 상태로 지속되는 시간을 줄이기 위해
     * 디스패치 루틴이 IoStartPacket을 사용했다면 DPC 루틴은 IoStartNextPacket을 호출
     * IRP가 큐에 있다면 DPC에서 Start I/O 루틴이 호출됨
       * 임의의 스레드에서 Start I/O 루틴이 수행되는 이유
     * 큐에 IRP가 없다면 장치는 바쁘지 않음으로 표시됨
       * 다음 요청을 대기
   * 드라이버에 의해 동작이 막 끝난 IRP에 대해 IoCompleteRequest 호출하여 완료시킴
     * 이 시점부터 드라이버는 IRP에 대한 책임이 없음
     * 어느 순간에 메모리 해제가 될지 모르므로 IRP에 접근하면 안됨
     * IoCompleteRequest는 등록된 완료 루틴이 있다면 호출함
     * 최종적으로 I/O 관리자는 IRP를 해제함
       * 자신의 완료 루틴을 사용하여
9. 원래 요청 스레드는 완료 통지를 받을 필요가 있음
   * DPC에서 실행하는 현재 스레드는 원래의 스레드가 아님(프로세스 주소 공간이 다를 수 있음)
   * 요청 스레드의 컨텍스트에서 코드를 실행하기 위해 커널 APC가 스레드에 발행됨
     * APC는 특정 스레드의 컨텍스트에서 실행되게 강제된 함수
     * 요청 스레드가 CPU 시간을 받을 때 특수한 커널 APC가 먼저 실행(IRQL APC_LEVEL=1)
     * APC는 대기로부터 스레드를 해제하고 비동기 동작에서 등록된 이벤트를 시그널하는 등 필요한 작업을 함

비동기 I/O 함수는 콜백 함수를 인자로 받음
* I/O 관리자가 I/O 완료의 마지막 단계에서 유저 모드 APC를 호출자의 스레드 APC 큐에 넣음
* 이 기능으로 완료 혹은 취소의 서브루틴을 호출자가 지정 가능

APC 완료 루틴
* 요청 스레드의 컨텍스트에서 실행
* 스레드가 Alertable wait 상태일 때만 전달됨

### 유저 주소 공간 버퍼 접근