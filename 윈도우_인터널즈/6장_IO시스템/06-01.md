# I/O 시스템 01 - I/O 관리자, 인터럽트와 DPC
## I/O 시스템 컴포넌트
![6-1](https://github.com/user-attachments/assets/7257cf42-eafd-43c2-b25f-cde726a56bf9)

### I/O 관리자
I/O 시스템의 핵심 부분
* I/O 요청을 디바이스 드라이버에 전달하는 일관적인 프레임워크나 모델을 정의

I/O 시스템은 패킷 구동(packet driven) 방식
* 대부분의 I/O 요청은 I/O 요청 패킷(IRP)로 표현됨
  * 일종의 구조체임
* IRP는 한 시스템 구성 요소에서 다른 구성 요소로 이동
  * 예외로 패스트 I/O는 IRP를 사용하지 않음
* 개별 애플리케이션 스레드는 다중 I/O 요청을 동시에 관리하는 것이 가능하게 설계됨

I/O 관리자가 하는 작업
* I/O 작업을 나타내는 IRP를 메모리에 생성
* IRP의 포인터를 해당 드라이버에 전달
* I/O 명령이 완료될 때 IRP를 해제
* 드라이버는 이를 전달받아 작업을 수행한 후 완료하거나 다른 드라이버에게 추가 처리를 위해 I/O 관리자에게 다시 전달

I/O 관리자는 서로 다른 드라이버의 I/O 처리를 위해 공통 코드를 제공
* I/O 관리자 내에 공통 작업을 통합함으로 드라이버는 더 단순하고 간결해질 수 있음

운영체제는 모든 I/O 요청을 파일에 접근하는 것처럼 처리
* 드라이버는 이런 요청을 하드웨어 특정적인 요청으로 변환
* 드라이버가 단일화된 모듈 인터페이스를 제공하므로 구조 등의 특별한 지식 없이도 호출할 수 있게 함

윈도우 I/O 시스템이 제공하는 기능
* open, close, read, write 기본적인 기능
* 비동기 I/O, 다이렉트 I/O, 버퍼드 I/O, 스캐터/게더 I/O 등 향상된 기능을 제공

### 전형적인 I/O 처리
일반적인 I/O 요청
* I/O와 관련된 함수를 호출하는 애플리케이션에서 시작
* I/O 관리자와 하나 이상의 디바이스 드라이버, HAL에 의해 처리

윈도우는 가상 파일 상대로 I/O를 수행
* 가상 파일 : 파얼처럼 취급되는 I/O의 대상을 말함

일반적인 유저 모드 클라이언트
* CreateFile 등의 함수로 가상 파일의 핸들을 구함
  * 이런 함수는 파일만이 대상이 아니라 GLOBAL??로 불리는 객체 관리자 디렉터리 내의 symbolic link로 알려진 무엇이나 그 대상이 될 수 있음
  * CreateFile의 File은 익스큐티브에 의해 생성된 가상 파일 객체를 의미함

I/O 요청 흐름

![6-2](https://github.com/user-attachments/assets/fcdaa169-5ca0-4791-992a-199c7383da93)

운영체제는 모든 I/O 요청을 가상 파일에 동작하는 것처럼 추상화
* I/O 관리자는 파일 이외의 I/O는 이해하지 못함
* 파일 명령을 장치 종속적인 명령으로 변환하는 것은 드라이버의 책임
* I/O 관리자는 유저 클라이언트의 가상 파일 요청을 적합한 디바이스 드라이버에 동적으로 전달

## 인터럽트 요청 레벨과 지연된 프로시저 호출
### 인터럽트 요청 레벨
IRQL(Interrupt Request Levels)의 두 가지 의미
* IRQL은 하드웨어 장치의 인터럽트 소스에 할당되는 우선순위
  * HAL에 의해 설정됨
  * 인터럽트 서비스를 필요로 하는 장치가 연결된 인터럽트 컨트롤러와 연계
* 각 CPU는 자신만의 IRQL을 가짐
  * CPU의 레지스터 한 값으로 간주될 수 있음
  * 현재 CPU는 이런 레지스터를 구현하지 않지만...

IRQL의 기본 규칙
* 낮은 IRQL 코드는 높은 IRQL 코드를 방해할 수 없음
* 높은 IRQL 코드는 낮은 IRQL 코드를 선점할 수 있음
  * IRQL은 스레드 우선순위와는 다름
  * 스레드 우선순위는 IRQL이 2보다 낮을 때만 의미를 가짐

![6-3](https://github.com/user-attachments/assets/015e6ecc-4693-44dc-bc49-24574e3cc033)

IRQL과 IRQ(인터럽트 요청)는 다름
* IRQ는 인터럽트 컨트롤러에 장치를 연결하는 하드웨어 라인

프로세서의 IRQL은 일반적으로 0
* 스레드 커널 스케줄러 외에 특별한 아무 작업도 발생하지 않음
* 유저 모드에서 IRQL은 0만 가능
  * 상승 불가능

커널 모드에서는 IRQL을 상승, 하강시킬 수 있음
* KeRaiseIrql, KeLowerIrql 함수를 통하여
* 하지만 시간 특정적인 함수의 대부분은 예상된 레벨로 상승할 IRQL 값과 함께 호출됨

I/O와 관련해서 중요한 IRQL
* 패시브(0)(PASSIVE_LEVEL)
  * 커널 스케줄러가 일반적으로 동작하는 기본 IRQL
* 디스패치/DPC(2)(DISPATCH_LEVEL)
  * 커널 스케줄러가 동작하는 IRQL
  * 이는 스레드가 현재 IRQL을 2 이상으로 상승시키면 이 스레드는 무한 퀀텀을 가지고 선점되지 않음
  * 즉, IRQL이 2 밑으로 떨어져야 스케줄러는 현재 CPU에서 깨어날 수 있음
* 디바이스 IRQL(x86 3-26, x64 3-12)(DIRQL)
  * 하드웨어 인터럽트에 할당되는 레벨
  * 인터럽트가 도착하면 커널의 트랩 디스패처는 적절한 ISR을 호출하고 IRQL을 연관된 인터럽트의 IRQL로 상승시킴

IRQL 레벨 2 이상이 가지는 의미
* IRQL이 2 이상이면 커널 디스패처 객체를 대기하는 누구라도 시스템을 크래시 시킴
  * 대기가 암시하는 것 : 스레드가 대기 상태로 전환되고 다른 스레드가 해당 CPU에서 스케줄 되어야 함
  * 그러나 2 이상이면 스케줄러는 실행될 수 없음
  * 따라서 시스템은 버그 체크를 발생시킴
    * 유일한 예외 - 대기 타임아웃이 제로인 경우
* 페이지 폴트가 처리될 수 없음
  * 변경 페이지 기록자 중 하나로 컨텍스트 스위칭이 일어져야 하기 때문
  * 그러나 IRQL이 2 이상이면 컨텍스트 스위칭은 허용되지 않고 시스템 크래시
  * 즉, IRQL 2 이상에서 동작하는 코드는 넌페이지드 풀에 할당되어야 함

### 지연된 프로시저 호출
DPC(Deferred Procedure Call)
* IRQL DPC_LEVEL(2)에서의 함수 호출을 캡슐화하는 객체
* 인터럽트 후처리를 위해 주로 존재

ISR은 최소한의 작업만
* ISR에서는 장치의 상태를 읽고 장치 인터럽트 신호를 중지하라는 요청을 하고
* DPC를 통해 좀 더 낮은 IRQL(2)에서 추가 처리를 지연시키는 작업을 할 뿐

"지연"의 의미
* DPC가 바로 실행되지 않음을 의미
  * ISQL이 2보다 높은 상태임으로 바로 실행 불가능
* ISR이 복귀할 때 펜딩 인터럽트가 더 이상 없다면 IRQL은 2로 떨어지고 DPC를 실행하게 됨

하드웨어 인터럽트 발생 시 일어날 수 있는 사건의 순서
![6-4](https://github.com/user-attachments/assets/cb291924-3b55-4206-ac96-7ad09a48d35b)

위 그림의 순서 설명
1. IRQL 0인 상황에서 일부 유저 모드와 커널 모드 코드가 실행됨
2. IRQL 5인 하드웨어 인터럽트 도착
    * IRQL 0보다 높으므로 해당 인터럽트의 ISR 호출
    * 컨텍스트 전환은 없음
    * ISR 코드의 실행이 일어나는 곳은 인터럽트 발생 시점에 실행하던 스레드
    * 스레드가 유저 모드에 있었다면 커널 모드 전환이 발생
3. IRQL이 5인 동안 ISR 1이 실행 시작
    * 이 시점에 IRQL이 5또는 그 이하의 인터럽트는 발생 불가능
4. IRQL 8인 다른 인터럽트가 도착하고 해당 인터럽트를 처리
    * 곧바로 CPU IRQL 상태는 8이 되고, 즉시 ISR 2로 점프
    * 여전히 같은 스레드임
5. ISR 2가 실행
    * 추가 작업은 더 낮은 IRQL에서 하게함
6. ISR2의 마지막 작업으로 후처리 드라이버 루틴을 가리키는 DPC를 큐에 넣음
    * KeInsertQueueDpc
    * ISR은 복귀하여 ISR 2로 진입하기 전의 CPU 상태를 복원
7. IRQL은 5로 다시 복귀하고 ISR 1의 실행을 재개
8. ISR 1의 후처리 작업 또한 DPC 큐에 인큐
9. IRQL은 0으로 복귀해야 하나 처리되지 않은 DPC가 존재하므로 DPC_LEVEL(2)로 떨어지고 DPC 처리 루프로 진입
    * DPC 큐가 빌 때까지 진행
10. IRQL은 0으로 되돌아오고 CPU 상태를 복원한 뒤 원래의 유저 모드, 커널 모드의 코드를 수행