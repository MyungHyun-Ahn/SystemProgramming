# 시스템 메커니즘 03 - 트랩 디스패칭
## 트랩 디스패칭
트랩(Trap)
* 예외나 인터럽트를 발생한 스레드를 잡아 운영체제에서 이를 처리하는 코드로 옮기는 메커니즘
* 윈도우에서 트랩 핸들러로 흐름을 옮기고 트랩 핸들러는 개별 인터럽트 또는 예외마다 배치됨

트랩 핸들러를 활성화시키는 조건

![8-06](https://github.com/user-attachments/assets/ab4485fd-00d5-4b70-b487-3626d8c3bc94)

커널이 구분하는 인터럽트와 예외의 차이
* 인터럽트
  * 비동기 이벤트(언제라도 일어날 수 있는)이고 프로세서가 실행하고 있는 것과 무관
  * I/O 디바이스, 프로세서 클록에 의해 발생
  * 켜지거나 꺼질 수 있음
* 예외
  * 동기적으로 발생
    * 어떤 명령의 실행에 대한 결과
    * 중단(Aborts)는 명령 수행과 관련없는 예외
  * 예외나 중단은 폴트라고도 불림
  * 메모리 액세스 위반, 특정 디버거 명령, 0 나누기 등이 있음
  * 커널은 시스템 서비스를 예외로 다룸

하드웨어 예외나 인터럽트가 발생한 경우
* 먼저 현재 코드 세그먼트(CS)가 CPL0 이하인지 봄
  * 즉, 현재 스레드가 커널 모드인지 유저 모드인지
* 스레드가 링0 권한이라면 프로세서는 다음 정보를 스택에 저장
  * 현재 프로세서 플래그(EFLAGS/RFLAGS)
  * 현재 코드 세그먼트(CS)
  * 현재 프로그램 카운터(EIP/RIP)
  * 선택적으로 예외의 종료나 에러 코드
* 링3 권한으로 동작하는 유저모드 코드에서
  * 태스크 레지스터를 통해 TSS 확인
  * x86에서는 SSO/ESP0로 전환
  * x64에서는 RSP0로 전환
* 프로세서는 커널 스택을 이용하여 실행하며 이전 SS와 이전 ESP를 먼저 저장
* 그리고 커널에서 커널로 전이했던 것과 같은 내용의 데이터를 저장

이런 데이터를 저장하는 것의 장점
* 커널 스택에서 원래 스레드로 전환을 위한 충분한 정보 기록
  * 복귀하였을 때 아무런 일이 일어나지 않았던 것처럼 돌아올 수 있음
* 운영체제가 저장된 CS 값을 이용하여 트랩이 어디서 왔는지 알게 해줌
  * 유저 모드 코드에서? 커널 시스템 콜로 부터? 왔는지 알게 해줌

프로세서는 제어 흐름을 복구하는 데 필요한 정보만 저장
* 나머지 장치 상태(EAX, EBX, ECS, EDI 등)는 트랩 프레임에 저장
* 트랩 프레임
  * 윈도우가 스레드 스택에 할당해 놓은 구조체
  * 여기에 스레드의 실행 상태를 저장
  * 즉, 이곳에는 스레드의 완전한 콘텍스트와 추가적인 상태 정보가 있음

커널이 인터럽트를 다룰 때
* 소프트웨어 인터럽트를 하드웨어 인터럽트처럼 다룰 수 있음
* 소프트웨어 인터럽트를 유발한 스레드 함수 호출 시점에 동기적으로 다룰 수 있음

프론트엔드 트랩 처리 함수
* 트랩을 처리하기 전과 후에 트랩 처리 작업을 수행하는 함수
* 예시
  * 디바이스 인터럽트 조건이면 커널 하드웨어 인터럽트 핸들러는 ISR로 제어를 넘김
  * 디바이스 드라이버는 디바이스 인터럽트를 다룸
  * 시스템 서비스에 의해 발생했다면 일반적인 시스템 서비스 트랩 핸들러가 커널 이그제큐티브에 존재하는 서비스 함수로 제어를 넘김

가짜 트랩 혹은 예기치 못한 트랩
* 비정상 상황에서 커널이 받는 기대하지 않은 트랩과 인터럽트
* 트랩 핸들러는 보통 KeBugCheckEx라는 함수를 실행
  * 컴퓨터 자체를 중지시키는 함수
  * 커널이 잘못된 동작으로 데이터를 손상시킬 가능성이 있을 때 수행

### 인터럽트 디스패칭
하드웨어 생성 인터럽트
* 서비스가 필요할 때 프로세서에게 서비스를 제공하고자 I/O 장치에서 필수적으로 발생

인터럽트 기반의 장치
* 운영체제가 프로세서를 최대한 사용할 수 있도록 주 처리 동작과 I/O 처리 동작을 중첩하여 사용
* 디바이스 대상 I/O 혹은 디바이스로부터 I/O를 받는 동작이 시작함과 동시에 디바이스가 작업을 끝낼 때까지 다른 작업 처리 가능
* 디바이스 작업이 끝나면 디바이스는 인터럽트를 보냄
* 포인팅 장치, 프린터, 키보드, 디스크 드라이브, 네트워크 카드 같은 장치가 있음

시스템 소프트웨어 인터럽트
* 커널은 스레드 디스패치 수행이나 스레드를 비동기적으로 수행하는 것을 멈추고자 발생시킬 수 있음

### 하드웨어 인터럽트 처리
인터럽트 컨트롤러
* 윈도우가 지원하는 하드웨어 플랫폼은 외부 I/O 인터럽트가 인터럽트 컨트롤러로 입력을 받음

출력 APIC 컨트롤러(IOAPIC)
* 하나 또는 그 이상의 프로세서의 로컬 APIC 컨트롤러(LAPIC)로 인터럽트를 보냄
* 단 하나의 입력 라인으로 프로세서에 인터럽트를 전달할 수 있음

프로세서에 인터럽트가 전달되면
1. 프로세서는 전역 시스템 인터럽트 벡터(GSIV)를 확인
   * 전역 시스템 인터럽트 벡터는 인터럽트 요청 번호(IRQ)로도 표현
2. GSIV 벡터는 CPU의 IDT 레지스터(IDTR)에 저장된 인터럽트 디스패치 테이블(IDT)의 색인 번호로 사용됨
   * 그 결과로 IDT 엔트리를 얻을 수 있음
3. IDT 엔트리에 있는 정보를 통해 프로세서는 링 0의 권한에서 적절한 인터럽트 디스패치 루틴에 제어권을 넘길 수 있음
4. 또는 프로세서는 새로운 TSS 레지스터를 로드하고 작업 레지스터 TR을 업데이트시킴
  * 이런 작업을 인터럽트 게이트라 함

IDT를 채우는 방식
* 윈도우는 시스템 부팅 타임에 IDT를 예외나 하드웨어 인터럽트를 위해 할당된 담당 커널 루틴이나 HAL 루틴으로 채움
* 서드파티 디바이스 드라이버가 등록해서 다룰 수 있는 외부 인터럽트를 처리하는 KilsrThunk라 불리는 루틴으로 채움

x86과 x64 아키텍처에서 인터럽트 벡터
* 0~31과 연관된 처음 32개의 IDT 엔트리는 프로세서 트랩으로 예약됨
* 나머지 IDT 엔트리는 하드코드된 값의 조합된 값 사용과 디바이스 드라이버, 하드웨어 인터럽트 컨트롤러, ACPI와 같은 플랫폼 소프트웨어와 함께 지정된 값 사용

각각의 프로세서는 분리된 IDT를 가짐
* IDTR 레지스터가 IDT를 담고 있음
* 프로세서마다 다른 ISR 루틴을 수행함
  * 하나의 프로세서만 시스템 클록을 업데이트 하는 역할을 가짐
    * 단, 스레드 수행 시간 단위 측정과 다시 스케줄링하고자 모든 프로세서는 해당 인터럽트를 사용
  * 일부 시스템 설정에서는 특정 프로세서만 특정 디바이스 인터럽트를 다룸

### 프로그래머블 인터럽트 컨트롤러 아키텍처
전통적인 x86 시스템
* i8295A 프로그래머블 인터럽트 컨트롤러(PIC, Programmable Interrupt Controller) 사용
  * IBM PC로부터 유래한 표준
  * 단일 프로세서 시스템에서만 동작
  * 8개의 인터럽트 라인을 가짐

IBM PC 아키텍처의 두 번째 PIC(보조 PIC라고도 함)
* 인터럽트는 주 PIC 인터럽트 라인으로 전달됨
* 결과적으로 15개의 인터럽트가 제공됨
  * 7개는 주 PIC, 8개는 보조 PIC
  * 주 PIC의 8번째 인터럽트 라인을 통해 다중화됨
* PIC가 15개까지 제공하더라도 다양한 전기적 문제와 단일 프로세서에 한계가 존재
  * 원치 않은 인터럽트로 취급될 가능성이 높음

최신 시스템에서는 i82489 APIC로 대체하기 시작
* APIC는 멀티프로세서 시스템에서 동작
* 인텔은 멀티프로세서 규격(MPS, MultiProcessor Specification)을 만듬
  * 이 규격은 I/O APIC와 로컬 APIC를 통합하는 것을 중점에 둠
* MPS 표준은 고급 구성 및 전원 인터페이스(ACPI)로 나뉘어짐
  * 단일 프로세서 시스템에서 멀티 프로세서 시스템을 시작하는 운영체제와 부팅 코드의 호환성을 제공
    * APIC는 PIC의 주 프로세서에 대한 15개 인터럽트와 인터럽트 전달을 지원함

![8-07](https://github.com/user-attachments/assets/ed1fd859-35c9-43b2-89d5-54efdbcafddb)

APIC의 구성 요소
* I/O APIC
  * 디바이스에서 인터럽트를 받음
* 로컬 APIC
  * 버스에 있는 I/O APIC에서 인터럽트를 받아 연관된 CPU에 전달
* i8259A 호환 인터럽트 컨트롤러
  * APIC 입력을 PIC 시그널로 전환

여러 I/O APIC가 시스템에 존재
* 보통 마더보드와 프로세서 사이에 중요 로직이 위치하게됨
* 해당 로직은 인터럽트 라우팅 알고리즘을 구현해 프로세서 사이의 부하를 조정함
* 지역성의 이점을 얻고자 이전에 서비스했던 같은 타입의 인터럽트를 이전에 전달한 프로세서에 전달할 수도 있음
* 소프트웨어 프로그램은 I/O APIC를 재프로그래밍 가능
  * 대부분 윈도우는 I/O APIC를 고유한 로직으로 대체
  * 해당 로직에는 인터럽트 스티어링이라는 기능이 있음
  * 하지만 여전히 디바이스 드라이버와 펌웨어가 관여하는 역할도 있음

x64 아키텍처에서
* APIC만 동작함
  * PIC는 동작하지 않음
* APIC의 태스크 우선순위 레지스터는 사용되지 않고 CR8 레지스터에 직접적으로 연결되어 사용
  * 최신 운영체제에서는 현재 소프트웨어 인터럽트 우선순위 단계(IRQL)를 CR8 레지스터에 저장
  * 그리고 이걸 IO APIC에 알려줘서 라우팅 관련 결정을 하게 함

### 소프트웨어 인터럽트 요청 레벨(IRQL)
인터럽트 요청 레벨(IRQL)
* 인터럽트 컨트롤러은 인터럽트 우선순위를 수행하지만
* 윈도우는 자체 인터럽트 우선순위 체계로 강제됨
  * x86 0-31번
  * x64 0-15번
* 높은 번호일수록 높은 우선순위 
* 커널이 IRQL 집합을 정의하고 HAL이 하드웨어 인터럽트 번호를 IRQL과 대응시킴

인터럽트는 우선순위 순서로 서비스 됨
* 높은 우선순위 인터럽트는 낮은 우선순위 인터럽트를 선점함
  * 높은 우선순위 인터럽트가 발생하면 프로세서는 인터럽트된 스레드 상태를 저장
  * 해당 인터럽트와 연관된 트랩 디스패처를 호출함
  * 트랩 디스패처는 IRQL을 높이고 인터럽트 서비스 루틴을 호출함
  * 루틴 수행 후에는 IRQL 레벨을 다시 낮추고 저장한 상태를 복구
  * 인터럽트된 스레드는 수행을 재개
  * IRQL을 낮출 때 중단되었던 낮은 순위의 인터럽트 실행이 재개됨

![8-08](https://github.com/user-attachments/assets/86245781-a1e1-4adc-8e5a-53527b0bd1f4)

IRQL 우선순위 레벨은 스레드 스케줄링 우선순위와는 완전히 다른 의미
* 스케줄링 우선순위는 스레드의 특성
* IRQL은 키보드, 마우스와 같은 인터럽트 소스에 속성을 가짐
* 운영체제가 코드를 수행함에 따라 각 프로세서의 IRQL 설정은 변경됨
* 각 프로세서의 IRQL 설정은 어떤 인터럽트를 프로세서가 받을지 결정함

IRQL은 커널 모드 데이터 구조체의 동기화에도 사용 가능
* KeRaiseIrql과 KeLowerIrql을 직접 호출하여 IRQL 조작
* 혹은 커널 동기화 객체를 획득하는 함수로 간접적 호출

인터럽트 마스킹
* 현재 프로세서 IRQL보다 높은 IRQL 인터럽트는 프로세서에 인터럽트를 전달
* 같거나 낮은 IRQL 레벨의 인터럽트는 실행되는 스레드가 IRQL을 낮출 때까지 무시됨

인터럽트 발생 시
* 트랩 핸들러는 인터럽트 소스에 할당된 IRQL로 프로세서의 IRQL을 높임
  * 같거나 작은 인터럽트를 마스킹
* 마스크된 인터럽트는 다른 프로세서에 의해 다뤄지거나 IRQL이 떨어질 때까지 프로세서에서 대기
* 따라서 모든 시스템의 구성 요소는 IRQL을 패시브 레벨로 유지하려 함
  * 디바이스 드라이버의 인터럽트에 제때 응답하기 위해
  * 따라서 인터럽트 동작, DPC, APC와 같은 인터럽트를 처리하고 있지 않다면 IRQL은 언제나 0

유저 모드 프로세스가 IRQL을 다루는 것
* 시스템에 매우 큰 영향을 끼침
* 0보다 높은 IRQL 레벨에서 유저 모드 스레드로 복귀하면 시스템 크래시(bugcheck)를 유발
* 드라이버의 심각한 버그임

디스패처 작업
* IRQL 2에서 동작
* 컨텍스트 스위칭이 발생하는 경우
  * 프로세서가 단일 스레드처럼 해당 레벨과 그 이상에서 동작한다는 것
  * IRQL 2 이상에서는 디스패처 객체를 기다리는 동작이 금지됨
  * 다른 스레드로의 콘텍스트 스위칭이 발생하지 않음
* DPC/디스패치 이상의 레벨은 넌페이지 메모리만 액세스해야 함
  * 컨텍스트 스위칭이 금지된 것에 의한 부작용
  * 페이지 아웃된 메모리는 페이지 폴트를 유발하고 메모리 관리자가 I/O를 시작
  * 파일 시스템 드라이버가 디스크로부터 페이지를 읽어오는 것을 기다림
    * 이런 동작은 스케줄러에 의해 컨텍스트 스위칭이 가능함
    * 결과적으로 스케줄러가 동작할 수 없다는 규칙이 깨짐(IRQL이 2 이상이기 때문)
  * 더 큰 문제는 I/O 완료가 APC_LEVEL에서 일어난다는 것
    * I/O 완료가 절대 일어나지 않는 상황이 발생
* 이런 제약조건이 깨진다면 시스템은 크래시를 일으킴

IRQL 1으로 동작 중인 경우
* 선점이 여전히 활성화, 컨텍스트 스위칭도 가능
* IRQL 1에서 대기 작업이나 선점 작업을 진행 
  * 스케줄러는 스레드 제어 블록에 현재 IRQL을 저장
  * 프로세서의 IRQL을 새로 실행된 IRQL로 복원
* IRQL 1은 프로세서 로컬 IRQL이 아닌 스레드 로컬 IRQL로 동작하게 됨
  * 패시브 레벨의 스레드가 APC 레벨의 스레드를 선점할 수 있다는 의미
  * IRQL 2 레벨 이하는 어떤 스레드가 프로세서를 소유할지를 스케줄러가 결정하기 때문

### 인터럽트 벡터와 IRQL 매핑
인터럽트 컨트롤러가 인터럽트 라인이 다른 것보다 더 높은 우선순위를 가진다고 생각하게 하는 것을 방지
* 반대 상황을 반영함
* APIC 때문에 윈도우는 쉽게 IRQL을 APIC의 TPR(x64 CR8)을 통해 나타냄
  * TPR은 APIC가 더 나은 전달 결정을 내릴 수 있게 함
* 시스템의 각 하드웨어 인터럽트의 우선순위는 IRQ가 아닌 인터럽트 벡터에 묶여 있음
  * 상위 4비트가 우선순위에 대응됨
  * IDT가 256 엔트리를 가질 수 있으므로 16개의 우선순위가 가능함
    * TPR이 가지는 16개의 숫자와 같음
  * 결론적으로 윈도우가 구현한 16개의 IRQL과 대응

윈도우가 어떤 IRQL을 인터럽트로 매핑할지 결정하려면
* 먼저 인터럽트와 맞는 적절한 인터럽트 벡터를 결정해야 함
* IO APIC를 하드웨어 IRQ와 인터럽트 벡터가 연관되게 해야 함
* 거꾸로 특정 IRQL이 하드웨어 디바이스에서 필요하다면 특정 우선순위에 대응하는 인터럽트 백터를 선택해야 함
* 이러한 결정은 플러그앤플레이 관리자가 버스 드라이버와 함께 수행함
  * 버스 드라이버는 버스에 존재하는 디바이스를 알아내는 데 사용
  * 그리고 어떤 인터럽트를 디바이스에 할당할 수 있는지 알려줌

이런 결정을 진행하고
* 플러그앤플레이 인터럽트 아비터를 호출
* 아비터가 IRQL과 인터럽트를 매핑함
* 아비터는 HAL에 노출되어 있어 HAL이 ACPI 버스 드라이버 및 PCI 버스 드라이버와 함께 동작해 적절한 매핑을 결정함
* 대부분의 경우 확실한 벡터 번호는 라운드 로빈 정책으로 선택
  * 미리 알 수 있는 방법은 없음
* 윈도우는 IDT에 사전 정의된 인터럽트 벡터도 가지고 있음

![8-09](https://github.com/user-attachments/assets/708f6aff-183d-48dc-8bc0-051fbbb3b871)

벡터 번호의 우선순위는 IRQL과 대응됨
* APC 1
* DPC 2
* IPI 14
* 프로파일 인터럽트 15

### 사전 정의된 IRQL
* 커널은 보통 KeBugCheckEx로 시스템을 멈출 때 높은 레벨에서 동작
  * 원격 커널 디버거가 붙을 때도 모든 인터럽트를 마스킹
  * 프로 파일 타이머 기능이 켜져 있고 동작하는 x86이 아닌 시스템에서 프로파일 레벨은 같은 값을 공유
  * 인텔의 프로세서 트레이스 기능과 연관돼 있는 다른 하드웨어 성능 모니터링 단위 기능도 해당 레벨에서 동작
* 프로세서 간 인터럽트 레벨은 다른 프로세서의 동작을 요청하고자 사용
  * TLB 캐시 업데이트 혹은 컨트롤 레지스터 변경이 이에 해당
* 클록 레벨은 시스템 클록을 위해 사용
* 동기화 IRQL은 디스패처와 스케줄러 코드가 전역 스레드 스케줄링을 위한 리소스 보호에 사용
  * 대기와 동기화 코드에서 사용
  * 보통 디바이스 IRQL 다음으로 높게 정의됨
* 디바이스 IRQL은 디바이스 인터럽트 우선순위를 정하고자 사용
* 수정된 장치 체크 인터럽트 레벨은 심각하지만 복구가능한 하드웨서 상태 또는 CPU 펌웨어가 장치 체크 에러 인터페이스를 통해 에러를 보고했을 때 이를 운영체제로 전달하고자 사용
* DPC의 디스패치 레벨과 APC 레벨 인터럽트는 커널과 디바이스 드라이버가 발생시키는 인터럽트
* 가장 낮은 레벨은 패시브 레벨
  * 일반 스레드 실행이 이뤄지고 모든 인터럽트가 일어날 수 있는 상태

### 인터럽트 객체
* 커널이 제공하는 디바이스 드라이버가 자신의 디바이스에 대한 ISR을 등록할 수 있게 하는 메커니즘
* KINTERRUPT라 불리는 객체
* 인터럽트 객체가 포함하는 것
  * 특정 하드웨어 인터럽트와 디바이스 ISR을 커널이 연관시키고자 알아야 하는 정보
  * ISR의 주소
  * 인터럽트의 극성과 트리거 모드
  * 디바이스 인터럽트가 발생하는 IRQL
  * 공유 상태
  * GSIV/IRQ
  * 다른 인터럽트 컨트롤러 데이터
  * 호스트의 성능 통계 정보

인터럽트는 일반 메모리 풀을 통해 할당됨
* 디바이스 드라이버가 인터럽트를 등록할 때 필요한 정보들이 초기화됨
* 인터럽트를 받을 수 있는 프로세서의 개수에 기반을 두고 KINTERRUPT 객체는 각각 하나씩 할당됨
  * 일반적인 경우 모든 프로세서마다 할당
* 그리고 인터럽트 벡터가 선택되고 나면 KPRCB에 포함된 배열 요소 중 하나가 KINTERRUPT 객체 하나를 가리킴
* KINTERRUPT를 할당할 때 공유 가능한 벡터인지 확인
  * 공유 가능하다면 이미 있을 것
  * 공유 가능한 상황이라고 판명되면 커널은 DispatchAddress 필드가 KiChainedDispatch 함수를 가리키게 업데이트
  * KINTERRUPT를 이미 존재하는 KINTERRUPT와 InterruptListEntry 필드를 통해 연결함
* 공유 가능하지 않는 경우
  * KiInterruptDispatch가 사용됨

인터럽트 객체의 IRQL을 저장하므로
* ISR 호출 전 KiInterruptDispatch 혹은 KiChainedDispatch가 정확한 IRQL로 올리게 해줌
* ISR이 반환되면 IRQL을 낮춤
* 이 2가지 과정이 필요한 이유
  * 최초 디스패치에 인터럽트 객체 포인터를 전달할 수 없기 때문
  * 최초 디스패치는 하드웨어에 의해서 발생하기 때문

인터럽트가 발생할 때 IDT는 KiIsrThunk 함수의 복사본 256개를 가리킴
* 각각은 인터럽트 벡터를 커널 스택에 넣는 어셈블리 코드로 이뤄짐
* 그후 나머지 처리 동작을 수행하는 공유 KiIsrLinkage 함수를 호출
  * 적절한 함수 프레임을 만들고 KINTERRUPT에 저장된 디스패치 주소를 호출함
  * KPRCB의 인터럽트 객체 배열을 읽어 KINTERRUPT를 얻음
  * 이때 스택에 있는 인터럽트 벡터를 인덱스로 활용함
    * 만약 KINTERRUPT가 없다면 예기치 않은 인터럽트로 처리됨
    * BugCheckUnExpectedInterrupts 레지스트리 값에 따라 KeBugCheckEx 함수로 크래시를 유발
    * 레지스트리 값에 없으면 인터럽트는 무시되고 실행 흐름은 원래 제어 포인터로 복구

x64에서 커널은 불필요한 기능을 생략함
* 프로세서 사이클을 줄이는 최적화
* KiInterruptDispatchNoLock
  * 커널이 관리하는 스핀락과 연관없는 인터럽트를 위함
* KiInterruptDispatchNoLockNoEtw
  * ETW 성능 트레이싱을 원하지 않는 인터럽트를 위함
* KiSpuriousDispatchNoEOI
  * 인터럽트 종료 신호를 보낼 필요가 없는 인터럽트를 위함
* KiInterruptDispatchNoEOI
  * 자동 EOI 모드에서 APIC를 프로그램했던 인터럽트를 위해 존재
  * EOI 시그널을 인터럽트 컨트롤러가 자동으로 전달하기 때문에 커널이 EOI를 처리할 필요가 없음

인터럽트 객체를 이용해 ISR을 등록하면
* 디바이스 드라이버가 인터럽트 하드웨어를 직접 조작하지 않아도 됨
* IDT에 대한 세부 정보도 몰라도 됨
* 이런 기능은 이식 가능한 디바이스 드라이버를 만들어줌
* 프로세서 간 차이도 반영하지 않아도 됨
* 커널은 ISR 데이터를 공유하는 다른 부분의 드라이버와의 실행을 동기화 시킬 수 있음

![8-10](https://github.com/user-attachments/assets/7b265fbc-617a-4eb0-b8b8-b325438ff162)

### 라인 기반 인터럽트와 메시지 기반 인터럽트
공유 인터럽트의 문제
* 높은 인터럽트 지연과 안정성 문제가 있음
* 따라서 선호되지 않고 컴퓨터의 제한된 물리 인터럽트 라인에 악영향을 미침
* 예를들어 4-in-1 미디어카드 리더기의 경우
  * USB, 호환 플래시, 소니 메모리 스틱, 시큐어 디지털 등을 다룸
  * 이 경우 같은 물리 장치의 일부인 모든 컨트롤러는 하나의 인터럽트 라인에 연결됨
  * 이 라인은 다른 디바이스 드라이버를 통해 공유되는 인터럽트 벡터를 이용하도록 설정됨
  * 미디어 디바이스에 인터럽트를 보내는 컨트롤러를 결정하고자 순차 실행해야 하기 때문에 지연 시간이 늘어남

훨씬 나은 해결책 - 각각의 디바이스 컨트롤러만의 인터럽트 부여
* 개별 드라이버가 다른 인터럽트를 다루게 함
  * 인터럽트가 어떤 디바이스에서 왔는지 알게 함


그러나 4개의 전통적인 IRQ 라인을 하나의 장치에 사용하는 것의 문제
  * IRQ 라인을 부족하게 함
  * PCI 장치들은 하나의 IRQ 라인에만 연결되어 있기 때문에 미디어카드 리더는 하나 이상의 IRQ를 사용할 수 없음

IRQ 라인을 통해 인터럽트를 발생시켰을 때의 또 다른 문제
* 정확하지 않은 IRQ 시그널의 관리로 인해
  * 인터럽트 스톰
  * 데드락 유발
* ISR이 이를 인지하기까지 시그널이 high 혹은 low 상태일 수 있음
  * 버그로 인해 그중 하나라도 처리되지 않으면 영원히 인터럽트 상태에 머물 수 있음
  * 혹은 인터럽트가 무시되어 버릴 수 있음

라인 기반 인터럽트는 멀티프로세서 환경에서 확장성이 낮음
* 많은 경우 하드웨어는 어떤 프로세서가 인터럽트를 받을지 플러그앤플레이 관리자가 선택 가능한 집합에 따라 결정을 함
* 디바이스 드라이버는 여기에 거의 관여할 수 없음

메시지 시그널 인터럽트(MSI)
* 위에서 제시된 문제들의 해결책
* 디바이스가 PCI 버스에 속한 특정 메모리 주소에 데이터를 쓰는 것으로 드라이버에 메시지를 전달
* 사실상 하드웨어가 연관되어 있으면 DMA로 처리됨
* 해당 동작은 인터럽트를 발생시키고 윈도우는 ISR을 메시지 내용과 메시지가 전달될 주소를 사용하여 호출
* 또한 디바이스는 32개까지 메시지를 메모리 주소로 전달 가능하고 이벤트에 따라 서로 다른 페이로드를 전달하게 됨
