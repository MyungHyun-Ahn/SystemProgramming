# 시스템 메커니즘 04 - DPC
## 소프트웨어 인터럽트
소프트웨어 유발 원인
* 스레드 디스패치 초기화
* 시간에 민감하지 않은 인터럽트 처리
* 타이머 만료 처리
* 특정 스레드 콘텍스트에서 비동기적으로 프로시저 처리
* 비동기 I/O 동작 지원

## 디스패처 또는 지연된 프로시저 요청(DPC) 인터럽트
### 지연된 프로시저 요청(DPC)
* 모든 디바이스 인터럽트가 처리된 이후의 작업을 처리하기 위한 인터럽트 연관 기능
* 지연된다 표현
  * 실제로 바로 수행을 하지 않기 때문
* 커널은 타이머 만료를 처리하고자 DPC를 사용
  * 스레드 퀀텀이 만료된 이후에 프로세서를 다시 스케줄링 하기 위해서도 사용
  * 일반적인 커널 DPC를 통한 것이 아니라 DPC IRQL 레벨에서 발생한다는 의미
* 디바이스 드라이버는 인터럽트를 처리하고 높은 IRQL에서 적합하지 않은 동작을 위해 DPC를 사용
  * 즉각적인 하드웨어 인터럽트 처리를 위해 낮은 IRQL을 유지
* 이런 목적을 달성하기 위한 방법
  * 디바이스 드라이버 ISR이 작업을 가능한 적게 수행하게 함
  * 사라질 인터럽트 상태 정보를 저장하고 데이터 전송을 미루거나 시간에 민감하지 않은 인터럽트 작업을 DPC 시점에 수행하는 것

DPC의 목적
* IRQL이 패시브 또는 APC 레벨에 있을 때 DPC는 즉시 수행되고 하드웨어 관련 작업이 아닌 건 막음
* 높은 우선순위의 시스템 코드를 즉시 수행하고자 DPC를 사용
* DPC는 운영체제에 인터럽트를 발생시킬 수 있게 함
  * 스레드가 대기 상태로 들어갈 때 커널이 즉각 디스패처를 호출하여 즉시 컨텍스트 스위칭을 유도 가능
  * 그러나 현재 하드웨어 인터럽트가 완료될 때까지 디스패칭이 발동하지 않도록 지연시킴

커널은 스케줄링과 연관된 커널 구조체에 동기적 액세스가 필요하면?
* 프로세서의 IRQL을 DPC/디스패처 레벨 혹은 그 이상으로 올리려 함
* 부가적인 소프트웨어 인터럽트와 스레드 디스패칭을 막는 행위

커널이 디스패칭이 반드시 일어나야 한다고 인지
* DPC/디스패치 레벨 인터럽트를 요청
* 그러나 IRQL이 해당 레벨 혹은 그 이상이기 때문에 인터럽트를 확인 상태로 잡아놓음
* 커널이 현재 동작을 마치고 IRQL을 2레벨 이하로 낮출 수 있는지 봄
* 그리고 어떤 디스패치 인터럽트가 대기 중인지 확인
* 대기 중인 것이 있다면 IRQL이 DPC/디스패치 레벨로 낮아짐
* 디스패치 인터럽트가 처리됨

즉, 소프트웨어 인터럽트를 통해 스레드 디스패치를 조건이 맞아 떨어질 때까지 미루는 것

DPC 객체
* DPC는 DPC 객체에 의해 표현됨
* 커널이 객체를 제어, 유저 모드 프로세스에서는 액세스되지 않음
* 디바이스 드라이버와 시스템 코드에서만 액세스 가능
* DPC 인터럽트를 처리 시 커널이 호출하는 시스템 함수 주소를 가지고 있음
  * DPC 객체가 가지는 가장 중요한 정보

DPC 큐
* 실행을 대기하는 DPC 루틴을 관리하는 커널 큐
* 프로세서 별 하나씩 존재
* DPC를 요청하고자 시스템 코드는 DPC 객체를 초기화하고 DPC 큐에 넣음
* 기본적으로 커널은 DPC 객체를 DPC가 요청된 프로세서에 속하는 2개의 DPC 큐 중 하나의 끝에 위치시킴
  * 일반적으로는 ISR이 수행된 프로세서
* 디바이스 드라이버는 해당 동작을 DPC 우선순위 조정으로 변경 가능
  * 만약 DPC가 높은 우선순위를 가진다면 커널은 DPC 객체를 큐의 맨 앞에 놓음
  * 그렇지 않다면 맨 뒤
* DPC를 특정 프로세서에서 수행되도록 설정 가능
  * 타깃 DPC

DPC 처리
* 프로세서 IRQL이 DPC/디스패치 레벨 또는 그 이상에서 낮은 IRQL로 떨어질 때 DPC를 처리함
  * 커널이 DPC를 처리하는 타이밍
* 윈도우는 IRQL이 DPC/디스패치 레벨에 남아있도록 보장하고 DPC 객체를 큐가 빌 때까지 현재 프로세서 큐에서 끌어옴
  * drain 한다고 함
* DPC 함수를 순서대로 호출함
* 큐가 비어 있을 때 비로소 커널은 IRQL을 DPC/디스패치 레벨 아래로 낮춤

DPC 프로세싱

![8-11](https://github.com/user-attachments/assets/b26ace26-a506-48bc-85c6-4c31eeaded46)

DPC 우선순위
* DPC가 낮은 우선순위를 갖는다면 커널은 DPC 요청이 특정 임곗값 이상으로 넘어가거나 특정 시간대 요청된 DPC가 적은 경우에만 인터럽트를 요청
* DPC가 ISR이 수행된 CPU와 다른 CPU에 요청되고 DPC의 우선순위가 높거나 중간 높음이면 커널은 즉시 대상 CPU에서 시그널을 전달해 DPC 큐를 모두 비움
  * 단 대상 프로세서가 Idle 상태일 때만
* 우선순위가 중간 또는 낮음이라면 대상 프로세서에 큐잉된 DPC의 개수가 임곗값을 넘어 커널로 하여금  DPC/디스패치 인터럽트를 요청할 수 있게해야 함
* 유휴 스레드는 현재 수행 중인 프로세서에서 DPC 큐를 비울 수 있음

DPC가 보통의 유저 스레드 수행을 인터럽트할 가능성이 높음
* DPC 루틴은 어떤 스레드에 관계없이 수행됨
* 즉, 프로세스 주소 공간을 가정 불가
* DPC 루틴은 커널 함수를 호출할 순 있지만 
  * 시스템 서비스 요청 불가
  * 페이지 폴트 유발 불가
* 넌페이지 메모리 공간만 액세스 가능
  * 시스템 주소 공간은 현재 프로세스가 어떤 것이든 상관없이 대응하게 되어 있으므로
* DPC는 유저 모드 메모리에 액세스해서는 안됨
  * 액세스 즉시 버그체크 발생

스레드의 수행 시간 보장
* 스레드의 수행 시간 및 DPC와 ISR이 동작한 시간을 빼서 정확한 CPU 사이클 수를 추적하여 스케줄러가 보정해줌

스레드 DPC
* 오래 수행되는 DPC를 위해 윈도우가 만든 것
* 패시브 레벨에서 실시간 우선순위(31)로 동작함
* DPC로 하여금 대부분의 유저 모드 스레드를 선점할 수 있게 해줌
* 하지만 다른 인터럽트, 즉 넌스레드 DPC, APC와 다른 우선순위 31 스레드들이 해당 루틴을 선점할 수 있게함