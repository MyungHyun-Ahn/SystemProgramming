# 시스템 메커니즘 01 - 프로세서 실행 모델
## 프로세서 실행 모델
### 세그먼테이션
어셈블러(assembler) 또는 어셈블리 코드(assembly code)와 같은 저급 언어
* 프로세서 레지스터에 직접 액세스

프로그램이 액세스하는 3가지 기본 유형의 레지스터
* 프로그램 카운터(PC, Program Counter)
  *  x86/x64 아키텍터에서는 IP(Instruction Pointer)라고 함
  *  EIP(x86), RIP(x64) 레지스터로 표시됨
  *  항상 실행 중인 어셈블리 코드 라인을 가리킴
     *  특정 32비트 ARM 아키텍처 제외
*  스택 포인터(SP, Stack Pointer)
   *  ESP(x86), RSP(x64) 레지스터로 표시됨
   *  메모리에서 현재 스택의 위치를 가리킴
*  기타 범용 레지스터(GPR, General Purpose Registers)
   *  EAX/RAX, ECX/RCX, EDX/RDX, ESI/RSI, R8, R14 등이 있음

이런 레지스터들은 메모리를 가리키는 주소값을 가짐
* 추가 레지스터에는 보호 모드 세그먼테이션(protected mode segmentation)이라는 메커니즘이 관여

셀렉터(selector)라고 하는 세그먼트 레지스터(segment registers)를 확인하여 동작
* 프로그램 카운터에 대한 모든 엑세스는 코드 세그먼트(CS, Code Segment) 레지스터를 확인하여 검증
* 스택 포인터에 대한 모든 액세스는 스택 세그먼트 레지스터(SS, Stack Segment)를 확인하여 검증
* 다른 레지스터는 세그먼트 오버라이드에 의해 결정
  * 데이터 세그먼트(DS, Data Segment), 확장 세그먼트(Extended Segment) 또는 F 세그먼트와 같은 특정 레지스터에 대한 검사를 강제할 수 있음

전역 디스크립터 테이블(GDT, Global Descriptor Table)
* 셀렉터는 16비트 세그먼트 레지스터에 있음
* GDT에서 찾을 수 있음
  * 프로세서는 이걸 찾고자 GDT 레지스터(또는 GDTR)를 사용함

![8-01](https://github.com/user-attachments/assets/dfe6d529-d4ab-483d-8be9-0e308b821676)

세그먼트 셀렉터의 오프셋
* T1 비트가 설정되지 않은 한 GDT에서 찾을 수 있음
* 다른 구조체의 경우 LDTR 레지스터에서 식별되는 로컬 디스크립터 테이블(LDT)을 사용
  * 그러나 최신 윈도우 운영체제에서는 사용하지 않음
* 세그먼트 항목이 발견되거나 값이 유효하지 않다면 일반 보호 에러 혹은 세그먼트 에러 예외 발생

최신 운영체제의 세그먼트 디스크립터의 목적
* 코드 세그먼트의 경우 코드 권한 레벨(CPL)이라는 링 레벨을 나타냄
  * 이 링 레벨에서 세그먼트 셀렉터가 로드한 코드를 실행하고 링 레벨은 실제 셀렉터의 맨 아래 2비트에 저장됨
    * 링0 - 커널 모드 구성 요소 및 드라이버를 실행
    * 링3 - 일반 애플리케이션과 서비스
  * x64 시스템에서 코드 세그먼트는 롱 모드 혹은 호환 모드 세그먼트를 가리킴
    * 롱 모드 - 네이티브 코드의 실행을 허용하는데 사용
    * 호환 모드 세그먼트 - x86과 레거시 호환성을 활성화
  * x86 시스템에도 세그먼트가 16비트 혹은 32비트로 표시될 수 있는 메커니즘이 있음 
* 다른 세그먼트는 디스크립터 권한 레벨(DPL)이라는 링 레벨을 나타냄
  * 해당 세그먼트에 액세스하는데 필요
  * 구시대적인 검사이지만 최신 시스템의 프로세서도 이 검사를 적용하고 정상적으로 설정해야함

x86 시스템에서 세그먼트 항목은 32비트 베이스 주소도 가질 수 있음
* 베이스 주소에 세그먼트를 재정의해 참조하는 레지스터에 로드된 특정 값을 더해 사용
* 해당 세그먼트의 제한을 사용해 하위 레지스터 값이 고정된 상한 값을 초과하는지 확인
  * 대부분의 운영체제에서 이 기본 주소는 0으로 설정
  * x64 아키텍처는 FS 및 GS 셀렉터를 제외하면 약간 다르게 동작

약간 다르게 동작하는 x64 아키텍처
* 코드 세그먼트가 롱 모드 코드 세그먼트인 경우
  * FS 세그먼트의 베이스 주소를 FS_BASE 모델 전용 레지스터(MSR, Model Specific Register)에서 가져옴
* GS 세그먼트의 경우
  * swapgs 명령으로 수정할 수 있는 현재 스왑 상태에서 GS_BASE 또는 GS_SWAP MSR 중 하나를 로드
* FS 또는 GS 세그먼트 셀렉터 레지스터에 T1 비트가 설정되어 있으면
  * LDT 항목의 적절한 오프셋에서 해당 값을 가져옴
    * 32비트 베이스 주소로 제한됨
  * 이는 특정 운영체제와의 호환성을 위해 수행되고 해당 제한은 무시됨
* 코드 세그먼트가 호환 모드 세그먼트인 경우
  * 베이스 주소를 적절한 GDT 항목(T1 비트 설정된 경우 LDT)에서 정상적으로 읽음
  * 세그먼트 재정의에 따른 레지스터 오프셋에 따라 제한 값을 적용하고 검증

FS 및 GS 레지스터의 흥미로운 동작
* 특정 데이터 구조체를 가리킬 수 있는 일종의 스레드 로컬 레지스터 효과를 얻고자 세그먼트 기본 주소를 사용해 내부의 특정 오프셋/필드에 간단히 액세스 가능
* TEB의 주소를 FS(x86), GS(x64) 레지스터에 저장함
* x86 시스템에서는 커널 모드 코드를 실행하는 동안 FS 세그먼트에 커널 프로세서 제어 영역(KPCR)의 주소를 갖는 다른 세그먼트 항목으로 수정
* x64에서는 GS(스왑되지 않음) 세그먼트에 KPCR 주소를 저장

윈도우는 세그멘테이션을 사용하여 2가지 효과를 달성
* 실행되는 코드의 프로세서 권한 수준을 인코딩하고 적용
* 유저 모드 또는 커널 모드 코드에서 TEB 및 KPCR 데이터 구조의 직접 액세스 제공
  * GDT는 CPU 레지스터(GDTR)에 의해 지정되기 때문에 프로세서 별 고유한 GDT를 가질 수 있음

### 세그먼트 지연 로딩
위에서 설명한 내용의 기반으로 x86 및 x64 시스템에서 DS 및 ES 값을 확인해보면 각각의 링 레벨에 대해 정의된 값과 반드시 일치하지는 않음
* 예를 들어 x86 유저 모드 스레드는 다음의 세그먼트를 가짐
  * CS = 1Bh(18h | 3)
  * ES, DS = 23(20h | 3)
  * FS = 3Bh(38h | 3)
* 그러나 링 0의 시스템 콜 도중의 세그먼트
  * CS = 08h(08h | 3)
  * ES, DS = 23(20h | 3)
  * FS = 30h(30h | 3)
* 이와 같이 커널 모드에서 실행되는 x64 스레드
  * ES, DS = 2Bh = (28h | 3)
* 이런 불일치는 지연 세그먼트 로딩으로 인한 것

지연 세그먼트 로딩
* 플랫 메모리 모델에서 동작하는 시스템의 경우 현재 코드 권한 수준이 0일 때
  * 데이터 세그먼트의 디스크립터 권한 수준이 의미 없음
  * 더 높은 CPL에서는 항상 낮은 DPL의 데이터에 액세스할 수는 있고
  * 커널에 들어가려면 DS 및 ES를 적절한 값으로 변경해야 하고
  * 유저 모드로 돌아갈 때는 복원해야 함

MOV DS, 10h 명령
* 사소해 보이지만 많은 셀렉터의 정확성 검사가 필요
* 따라서 시스템 콜 및 인터럽트 처리에 상당한 프로세싱 비용이 추가됨
  * 윈도우는 항상 링3 데이터 세그먼트 값을 사용하여 이런 비용을 피함

### 작업 상태 세그먼트
작업 레지스터(TR, Task Register)
* GDT에서 오프셋 역할을 하는 또 다른 16비트 셀렉터
* 세그먼트 항목이 작업과 연관됨
  * 현재 실행 중인 코드 조각에 대한 프로세서의 내부 상태를 나타냄
  * 작업 상태(Task State)라고 불림
  * 윈도우에서는 현재 스레드를 가리킴
  * 작업 상태 세그먼트(TSS, Task State Segment)로 표시됨

작업 상태 세그먼트
* 최신 x86 운영체제에서 중요한 프로세서 트랩과 관련된 다양한 작업을 구성할 때 사용
* 최소한 하나의 페이지 디렉터리, 코드 세그먼트, 스택 세그먼트, 명령 포인터를 나타내고 스택 포인터를 4개(링 레벨별 하나씩)까지 나타냄
  * 페이지 디렉터리는 x64의 PML4와 마찬가지로 CR3 레지스터를 통해 나타냄

TSS는 다음 시나리오에서 사용됨
* 특정 트랩이 발생하지 않은 경우 현재 실행 상태를 나타냄
  * 프로세서가 현재 링3에서 실행 중이라면 TSS에서 링0 스택을 로드
    * 인터럽트, 예외를 올바르게 처리함
* 디버그 폴트(Debug Fault)를 처리할 때 구조적 경쟁 조건을 해결하기 위해 필요
  * 전용 TSS는 유저 지정 디버그 폴트 핸들러와 커널 스택을 갖고 있음
* 더블 폴트(Double Fault) 트랩이 발생할 때 로드되어야 하는 실행 상태를 나타냄
  * 에러가 발생한 원인이 될 수 있는 현재 스레드의 커널 스택 대신 안전한(백업된) 커널 스택에서 더블 폴트 핸들러로 전환하고자 사용
* 마스크할 수 없는 인터럽트가 발생할 때 로드되어야 하는 실행 상태를 나타내고자 사용
  * 안전한 커널 스택에 NMI 핸들러를 로드하고자 사용
* 장치 체크 예외 중 사용하는 것과 유사한 작업에 대해 안전한 전용 커널 스택에서 실행 가능

x64 시스템에서는 단일 TSS
* 전용 커널 스택에서 트랩 핸들러를 실행해야 하는 요구 사항이 하나만으로 거의 줄어듬
* 대신 인터럽트 스택 테이블(IST)이라는 8개의  사용 가능한 스택 포인터 배열이 있음
  * 이전의 각 트랩은 커스텀 TSS 대신 IST 인덱스와 연관