# 스레드 04 - 스레드 스케줄링 02
## 멀티프로세서 시스템
멀티프로세서 시스템에서는 선호 프로세서, 직전 수행 프로세서를 고려하여 스케줄링해야 함
* 윈도우는 가장 높은 우선순위의 스레드를 어디선가 실행하고 있음을 보장
* 공유 레디 큐 덕분에 이 보장은 강력히 지켜짐

### 패키지 세트와 SMT 세트
윈도우는 올바른 스케줄링 결정을 위해 KPRCB의 다섯 개 필드를 사용
* CorePerPhysicalProcessor : 멀티 코어 패키지의 일부분인지 결정
* LogicalProcessorsPerCore : SMT 세트의 일부분인지 결정
* PackageProcessorSet : 다른 논리 프로세서가 동일한 물리 프로세서에 포함되어있는지를 기술하는 값
* CoreProcessorSet : 다른 논리 프로세서를 SMT 세트라 불리는 동일한 코어로 연결
* GroupSetMember : 프로세서 그룹 내에서 논리 프로세서를 나타내는 비트마스크

### NUMA(None-Uniform Memory Architecture) 시스템
윈도우에서 지원하는 비정형 메모리 아키텍처
* 프로세서들이 노드라는 작은 단위로 그룹화
  * 자체적인 프로세서와 메모리를 가짐
  * Cache-Coherent로 더 큰 시스템에 연결
* 각각의 노드가 자체적인 고속 메모리를 가짐
  * 어느 노드의 어느 프로세서든 모든 메모리에 접근 가능
    * 노드 내의 메모리의 접근이 훨씬 빠름

윈도우는 NUMA 인식 스케줄링 알고리즘을 따름
* 친화성 마스크 설정을 통해 프로세스가 특정 노드에서만 동작하도록 할 수 있음

### 스케줄러 확장성
지연된 레디 상태의 스레드 리스트가 하나씩 존재
* Defered Ready : 스레드가 실행 준비는 되었으나 시작될 준비가 되지 않은 상태
  * 즉, 실행이 유예됨
* 코어가 파킹된 경우 모든 스레드는 지연된 레디 리스트에 들어간 후 처리됨
  * 파킹된 스레드의 모든 스레드를 다른 프로세서에서 실행되게 함
* KiDeferedReadyThread는 파킹된 코어를 건너뛰고 이 프로세서의 모든 스레드를 다른 프로세서에서 실행되게 함

코어 파킹
* 해당 코어를 저전력 모드로 수행
* 코어가 임시 정지 상태

### 친화성
친화성 마스크를 통해 스레드가 어느 프로세서에서 실행될 것인지 지정가능
* 스레드 친화성 마스크는 프로세스 친화성 마스크를 상속 받음
* 또한 스레드 친화성 마스크는 변경할 수 있음

친화성 마스크 변경 함수
* SetThreadAffnityMask : 개별 스레드 친화성을 설정
* SetProcessAffinityMask : 프로세스의 모든 스레드의 친화성을 설정

### 이상적 프로세서와 직전 프로세서
각 스레드는 세 가지 CPU 번호를 KTCB에 저장
* 이상적(Ideal) 프로세서 : 선호 프로세서
  * PCB의 시드(seed)를 통해 결정, 이 값은 실행될 때마다 1씩 증가
  * 이런 방식으로 프로세스 내의 스레드는 여러 프로세서에 분배됨
  * SMT 시스템에서는 다음번의 이상적 프로세서는 다음 SMT 세트로부터 선택됨
    * 이런 방식은 프로세스 내의 스레드가 같은 양의 일을 한다 가정
  * 64비트 윈도우에서는 NUMA 노드의 Stride 필드를 통해 스레드를 균형있게 분배
    * Stride는 다른 코어를 구하기 위한 수치
* 직전(Last) 프로세서 : 가장 최근 실행 프로세서
* 다음(Next) 프로세서 : 다음에 실행될 프로세서 혹은 이미 실행중인 프로세서

### 이상적 노드
NUMA 시스템에서 프로세서가 생성될 때 이 프로세스의 이상적 노드가 선택됨
* 첫 번째 노드 0, 두 번째 노드 1 ...

프로세스 내의 스레드에 대한 이상적 프로세서
* 프로세스의 이상적 노드에서 할당

## 멀티프로세서 시스템에서의 스레드 선정
전 글 스레드 선정 알고리즘 외 KiSearchForNewThread 알고리즘이 있음
* NtDelayExcution 혹은 Sleep API를 호출 등의 객체에 대한 대기로 블록되려고 할 때 호출됨

KiSearchForNewThread 동작
* 이 프로세서를 위한 스레드가 있는지 검사(NextThread 필드)
* 없다면 KiSelectReadyThreadEx로 찾고 있다면 즉시 실행 상태로
* 여기에서도 발견하지 못한다면 유휴 상태로 표시되고 다른 프로세서의 레디 큐 스캔
* 혹은 코어를 파킹 상태로 전환

유휴 상태도 아니고 파킹 상태도 아니라면 워크스틸링(work-stealing) 루프가 동작
* 현재 NUMA 노드에서 모든 유휴 프로세서를 제거
* 현재 프로세서의 공유 레디 큐에서 스레드를 찾지 못한다면 다른 프로세서 그룹의 레디 큐에서 찾음
* 후보 레디 스레드를 발견하지 못한다면 NUMA 노드 내의 논리 프로세서가 소진될 때까지 반복
* 현재 그룹 내의 모든 NUMA 노드가 소진될 때까지
* 어떠한 후보도 찾지 못한다면 유휴 스레드를 실행
  * 이 작업이 이미 수행되었다면 Sleep 상태로 진입

## 프로세서 선정
윈도우가 주어진 스레드에 대해 어떻게 레디 큐에 넣을 것인지

### 유휴 프로세스가 있을 때 프로세서 선정
스레드가 실행될 준비가 되면 윈도우는 KiDeferredReadyThread 스케줄러 함수를 호출
* 필요에 따른 우선순위 조정과 퀀텀 재설정 진행
* 최적의 논리 프로세서를 선택

최적의 논리 프로세서를 찾는 과정
* 스레드의 이상적 프로세서를 살펴보고 고정 친화성 마스크 내의 유휴 프로세서 집합을 계산
  * 유휴 프로세서 집합은 이렇게 정리됨
    1. 코어가 파킹된 유휴 논리 프로세서가 제거됨
        * 유휴 프로세서가 남지 않으면 유휴 프로세서 선정에 실패
        * 이후 스케줄러는 유휴 프로세서가 가용하지 않은 것 처럼 동작
    2. 이상적 노드에 존재하지 않는 모든 유휴 논리 프로세서를 제거
    3. SMT 시스템에서는 이상적 프로세서가 제거 되더라도 비유휴 SMT 세트를 제거
    4. 남은 유휴 프로세서 중 이상적 프로세서를 찾음
        * 없다면 적합한 유휴 프로세서를 찾아야 함
        * 남은 유휴 프로세서 집합 중 마지막으로 수행했던 프로세서가 있는지 검사
        * 있다면 이 프로세서를 임시 이상적 프로세서로 간주
          * 캐시 적중률을 최대화 시키는 방향으로 동작
    5. 모두 존재하지 않다면 이상적 프로세서와 동일한 SMT 세트 내에 존재하지 않는 모든 유휴 논리 프로세서를 제거하는 작업을 다시 수행
    6. 더 이상 남아있는 것이 없으면 현재 프로세서의 SMT 세트에 없는 프로세서를 대신 제거
        * 윈도우는 가장 먼저 선택되어야 하는 이용 불가능한 이상적 세트와 직전 프로세서와 동일한 SMT 세트를 공유하는 유휴 프로세서를 선호함
    7. 유휴 세트에 남아있는 프로세서가 하나 이상이라면 번호가 가장 낮은 프로세서를 선택
* 스레드를 실행할 프로세서가 선택되면 이 스레드는 스텐바이 상태로 가고 유휴 프로세서의 PRCB는 이 스레드를 가리키게 갱신됨
* 해당 프로세서가 유휴 상태이고 정지 상태가 아니라면 DPC 인터럽트가 전달되어 프로세서가 스케줄링 작업을 즉시 처리함
* DPC 인터럽트가 전달되어 스케줄링 작업을 즉시 처리

스케줄링 작업이 초기화될 때마다 KiCheckForThreadDispatch가 호출됨
* 이 함수는 해당 프로세서에 새로운 스레드가 스케줄링 되었다는 것을 탐지하고 가능하면 바로 컨텍스트 스위칭과 자동 상승을 통지하고 펜딩 APC 전달
* 펜딩 스레드가 없다면 DPC 인터럽트를 전송

### 유휴 프로세서가 없을 때 프로세서 선정
파킹된 유휴 프로세서로 인해 제거된 경우
* 코어 파킹 엔진에게 최상의 후보를 요청(KiSelectCandidateProcessor)
  * 이상적 노드 내의 파킹되지 않은 가장 높은 번호의 프로세서 선택
  * 없다면 파킹 상태를 강제로 덮어써 파킹을 해제
* 만약 전달받은 후보가 유휴 상태라면 이 프로세서를 선택

만약 위 과정이 실패하면
* 이상적 프로세서, 직전 프로세서, NUMA 노드 내의 첫 번째 프로세서, 다른 근접 NUMA 노드 내의 프로세서, 친화성 제약이 없는 프로세서 순으로 대상 프로세서를 탐색
* 우선 순위를 비교하여 선점 여부 결정
* 선점 여부가 결정되면
  * 수행 중인 스레드에 선점 표시를 하고 대상 프로세서에게 DPC 인터럽트를 큐잉하여 선점하게 함

레디 스레드가 바로 수행될 수 없다면
* 자신의 스레드 우선순위에 맞는 레디큐에 들어감
* 선점 여부에 따라 큐의 맨뒤나 맨앞에 삽입