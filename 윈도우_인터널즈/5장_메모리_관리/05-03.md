# 메모리 관리 03 - 가상 주소 배치, 랜덤화
## 가상 주소 공간 배치
### 윈도우 가상 주소 공간 데이터 매핑 유형
* 프로세스별 전용 데이터와 코드
* 세션 전역적인 코드와 데이터
* 시스템 전역적인 코드와 데이터
  * 시스템 코드
  * 넌페이지드 풀
  * 페이지드 풀
  * 시스템 캐시
  * 시스템 페이지 테이블 엔트리(PTE)
  * 시스템 워킹셋 리스트
  * 시스템 맵 뷰
  * 하이퍼스페이스
  * 크래시 덤프 정보
  * HAL 사용

### x86 주소 공간 배치
* 기본적으로 32비트의 유저 프로세스는 2GB 전용 주소 공간
* increaseuserva BCD 부팅 옵션을 사용하면 3GB까지 가능

2GB 유저 주소 공간의 경우
* 최상위 비트가 항상 0
* 이 비트를 플래그로 사용하다가 데이터를 참조하기 전에 지워줌
* 2GB 주소 공간의 프로그램이 3GB의 주소 공간을 가지고 실행된다면
  * 2GB 이상의 값을 갖는 포인터를 우연히 변경하게 될 수 있음
  * /LARGEADDRESSAWARE 링커 플래그로 설정 가능

![5-5](https://github.com/user-attachments/assets/d77c6e22-5cf0-496d-b9bf-69485ee7cd13)

### x86 시스템 주소 공간 배치
32비트 윈도우는 가상 주소 할당자를 통해 동적 시스템 주소 공간 배치를 구현
* 특별히 예약되는 영역도 여전히 있지만 많은 커널 구조체는 동적 주소 공간 할당을 이용
* 이런 구조체는 연속적일 필요는 없음

이런 방식으로 할당되는 시스템 주소 공간의 사용처
* 넌페이지드 풀
* 페이지드 풀
* 특수 풀
* 시스템 PTE
* 시스템 맵 뷰
* 파일 시스템 캐시
* PFN 데이터베이스
* 세션 공간

### 시스템 페이지 테이블 엔트리
* IO 공간, 커널 스택, 메모리 디스크립터 리스트 매핑 같은 시스템 페이지를 동적으로 매핑하는데 사용
* 시스템 PTE는 무한한 자원이 아님
  * 32비트 윈도우에서 시스템 PTE의 개수는 2GB
  * 윈도우 10 64비트에서는 16TB

### 64비트 주소 공간 배치
* 이론적으로 64비트 가상 주소 공간 : 16엑사바이트
* 현재 프로세서 제한은 48주소 라인까지만 허용
  * 256TB 까지로 제한됨
  * 이 주소를 절반으로 나누어 사용
  * 하위 128TB 유저 공간
  * 상위 128TB 시스템 공간
* /LARGEADDRESSAWARE 없이 링크된 64비트 애플리케이션
  * 32비트 애플리케이션 처럼 첫 2GB만 프로세스 가상 주소 공간으로 제한
  * 64비트 빌드 시 비주얼 스튜디오에서 기본적으로 설정됨

![5-6](https://github.com/user-attachments/assets/c0ae457c-5fa4-4b17-a894-699a90fd7861)

### x64 가상 주소 제약
AMD와 Intel에서 지원하는 x64 프로세서는 256TB의 가상 주소 공간만을 지원
* 칩 아키텍처를 단순화, 주소 변환 등의 불필요한 오버헤드를 줄이기 위해

표준 주소(canonical address)
* 64비트 가상 주소의 하위 48비트, 하지만 가상 주소는 64비트고 메모리 혹은 레지스터에서 8바이트 차지
* 상위 16비트는 2의 보수 연산에서 부호 확장과 유사한 방법으로 가장 높은 비트(47비트)와 동일한 값을 가져야 함
* 위와 같은 규칙을 따르는 주소를 표준 주소라 함
* 유저 영역은 0x0000000000000000으로 시작하고 0x00007FFFFFFFFFFF로 끝남
* 시스템 영역은 0xFFFF800000000000으로 시작하고 0xFFFFFFFFFFFFFFFF로 끝남

### 동적 시스템의 가상 주소 관리
* 32비트 버전의 윈도우가 사용하는 시스템 주소 공간 관리 방법
* 64비트 윈도우에서는 각 영역이 정적으로 정의되어 있으므로 가상 할당자가 필요없음

내부 커널 가상 할당자 메커니즘
* 시스템이 초기화될 때 MiInitializeDynamicVa 함수 호출
  * 기본적인 동적 영역 설정
  * 이용 가능한 모든 커널 공간에 유용한 가상 주소 설정 
* 그 후 MiInitializeSystemVaRange 함수 호출(32비트 시스템만)
  * 하드코딩된 주소 공간을 설정하기 위함
  * 부트 로더 이미지, 프로세스 공간, HAL을 위한 주소 공간을 초기화
  * 나중에 넌페이지드 풀이 초기화될 때 이 함수는 가상 주소 공간을 예약하기 위해 다시 사용됨
* 마지막으로 드라이버가 로딩될 때마다 주소 공간은 해당 드라이버 이미지 영역을 위해 재사용됨
* 이 시점 이후로 시스템 가상 주소 공간의 나머지 영역은 동적으로 할당되고 해제될 수 있음
  * MiObtainSystemVa : 할당
    * 커널 영역이 새로 할당될 때마다 새롭게 할당된 영역의 가상 주소 유형을 갖는 MiSystemVaType 배열을 갱신함
  * MiReturnSystemVa : 해제
    * 페이지드 풀, 시스템 캐시가 줄어들거나 특수 풀, 큰 페이지 매핑이 해제될 때 관련 가상 주소가 해제
    * 부팅 관련 레지스트리가 해제될 때도

이용 가능한 가싱 주소 공간이 128MB 이하로 떨어진 경우
* 플러시 되어야 하는 시스템 캐시와 연관된 가상 주소를 요청한 컴포넌트는 메모리를 재요청 가능함
  * MiReclaimSystemVa 함수로
* 초기 넌페이지드 풀이 해제됐을 경우에도 재요청 가능
* 재요청은 시스템 캐시와 넌페이지드 풀인 경우에만 효과가 있음

동적 가상 주소 할당자가 가지는 이점
* 커널 메모리 사용자에 전용된 가상 주소에 대한 좀 더 나은 비율과 관리
* 메모리에 대한 추가 정보를 줄임
  * 32비트와 64비트 시스템 모두에서 사용하지 않는 메모리 주소에 대해 페이지 테이블을 할당하지 않게 되므로 부팅 시 메모리 사용이 줄어들게 됨
  * 64비트 시스템에서 예약된 큰 주소 공간 영역이 메모리에 매핑된 페이지 테이블을 가질 필요가 없기 때문에 특히 페이징 구조체 결과를 백업하기 위한 물리 RAM이 적은 시스템에서 임의적인 크기 제한이 허용

### 사용자 주소 공간 배치
* 사용자 주소 공간 역시 동적으로 구축됨
* 스레드 스택, 프로세스 힙, 로딩되는 이미지 등의 주소는 ASLR(Address Space Layout Randomization) 메커니즘을 통해 동적으로 계산됨

운영체제 수준에서 사용자 주소 공간
* 몇 개의 메모리 영역으로 나뉘어 있음
* 실행 파일과 DLL, 메모리 맵 파일 이미지로 표현 그 다음에 프로세스 힙과 스레드 스택 위치
  * 이런 영역 이외의 다른 모든 메모리 할당은 실행 중 상황에 맞게 진행
* ASLR은 모든 실행 중 결정되는 영역의 위치에 관여, DEP와 연계하여 메모리 조작을 통해 익스플로잇을 더 어렵게 만듬
  * 공격자는 프로그램의 오프셋을 하드코딩할 수 없게 됨

![5-7](https://github.com/user-attachments/assets/225499cb-934f-4a6c-ace9-fb22e9919172)

ASLR은 이미지 레벨부터 시작
* /DYNAMICBASE 링커 플래그로 빌드해 PE 헤더에 ASLR 지원 명시
* 재배치 섹션을 포함하고 있는 이미지 파일이 ASLR에 의해 처리됨
* 이런 이미지가 발견되면 시스템은 이번 부팅에서 전역적으로 사용되는 이미지 오프셋을 하나 선택
  * 이 오프셋은 64KB로 정렬된 256개의 값을 가진 버킷에서 선택

### 이미지 랜덤화
* 실행 파일은 로드될 때마다 델타 값이 계산되어 로드 오프셋이 결정됨
  * 0x10000부터 0xFE0000까지 8비트 의사 난수 값
  * 현재 프로세서의 타임스탬프 카운터 값 중 4군데를 시프팅하고 254로 모듈러 연산한후 1을 더해 계산
  * 이후 64KB의 메모리 할당 단위로 곱해짐
  * 이때 메모리 관리자는 1을 더해 이 값이 절대 0이 되지 않게 함
    * ASLR을 사용할 경우 PE 헤더에 있는 주소로 절대 로딩되지 않도록 만듬
  * 이 값은 이미지의 선호 로딩 주소에 더해져 PE 헤더의 이미지 주소로부터 16MB 내의 가능한 256개 값 중 하나의 위치를 생성

DLL의 경우 이미지 Bias라는 시스템 전역 로드 오프셋이 사용됨
* 이 값은 부팅 때마다 MiInitailizeRelocation에 의해 새롭게 계산됨
  * MiState.Sections.ImageBias 필드 내의 전역 메모리 상태 구조체에 저장됨
  * 부팅 과정 중 이 함수가 불릴 당시의 현재 프로세서 TSC 값을 취해 시프트하고 8비트 값으로 마스킹됨
  * 32비트 시스템에서 256개의 가능한 값이 존재함
  * 64비트 시스템에서는 유사한 방식으로 계산이 이뤄지고, 주소 공간이 방대하므로 좀 더 많은 값을 가짐
* 실행 파일과 달리 이 값은 부팅 시 한 번만 계산되어 시스템 전역적으로 공유함으로 DLL이 물리 메모리에 공유되고 단 한번만 재배치되게 함
* DLL이 서로 다른 프로세스에서 서로 다른 영역에 로딩된다면 공유 불가능
* 로더는 각 프로세스 별로 주소 참조를 다르게 수정해야 하므로 공유되는 읽기 전용 코들르 프로세스 전용 데이터로 변경해야 함
* 해당 DLL을 사용하는 각 프로세스는 물리 메모리에 자신만의 전용 복사본을 만들어야 함

오프셋이 계산된 이후
* MI_SECTION_STATE 구조체의 일부분인 ImageBitMap이라는 비트맵 초기화
  * 32비트 시스템에서 0x50000000부터 0x78000000 까지의 범위를 나타냄
  * 각 비트는 하나의 메모리 할당 단위를 나타냄
  * 메모리 관리자가 DLL을 로딩할 때마다 시스템에서의 위치를 표시하는 비트가 설정됨
* 동일한 DLL이 다시 로딩된다면 이미 재배치된 정보를 이용해 섹션 객체를 공유

각 DLL이 로딩될 때
* 시스템은 사용되고 있지 않은 비트를 찾기 위해 비트맵을 위에서 아래로 스캔
* 이전의 ImageBias는 부팅 시마다 로딩을 랜덤화하기 위해 시작 인덱스로 사용됨
* 첫 번째 DLL(항상 Ntdll.dll)이 로딩될 땐 비트맵이 완전히 비어있으므로 그 DLL의 로딩 주소는 쉽게 계산됨
  * 32비트 0x78000000 - (ImageBias + NtDllSizein64KBChunks) * 0x10000
  * 64비트 0x7FFFFFFF0000 - (ImageBias64High + NtDllSizein64KBChunks) * 0x10000
* 이후 각 DLL은 64KB 영역만큼 떨어진 아래 부분에 로딩
  * 따라서 Ntdll.dll의 주소만 알면 다른 DLL의 주소는 쉽게 구할 수 있음
  * 이런 가능성을 줄이기 위해 DLL의 순서는 Smss.exe가 로딩될 때 랜덤화됨
* 비트맵에 가용한 공간이 없다면 DLL 재배치 코드는 선호 베이스 주소의 16MB 범위 안에서 64KB 단위에 맞는 위치에 로딩

### 스택 랜덤화
ASLR의 다음 순서 초기 스레드의 스택과 이후 생성되는 스레드 스택 위치를 랜덤화
* StackRandomizationDisabled 플래그가 켜져있지 않다면 활성화
* 64KB 혹은 256KB로 나눠진 32개의 가능한 스택 위치 중 하나를 선택
  * 베이스 주소는 적절한 크기의 사용 가능한 메모리 영역 중 첫 번째 것을 찾은 후 x번째 가능한 공간을 선택
  * x는 TSC 값 시프트하고 마스킹하여 5비트짜리 값으로 변경한 것(32가지 가능)
* 베이스 주소가 선택되면
  * TSC로부터 9비트 길이를 갖는 새로운 값을 만듬
  * 정렬을 위해 4를 곱하면 이 값은 2048바이트가 될 수 있음
* 이 값을 베이스 주소에 더해 최종 스택 베이스가 구해짐

### 힙 랜덤화
ASLR은 유저 모드에서 생성되는 초기 프로세스 힙과 이후 생성되는 힙의 위치에 더해 랜덤화를 수행
* RtlCreateHeap 함수
  * 힙의 베이스 주소를 결정하기 위해 TSC로부터 구해지는 의사 랜덤 값을 사용함
  * 초기 힙을 위해 0x00000000부터 0x001F0000까지의 가능한 값 사이의 최종 베이스 주소를 생성하기 위해 5비트인 랜덤 값에 64KB를 곱함
* 추가적으로 힙의 베이스 주소 이전의 메모리에 대해서는 모두 수동으로 할당해제하여 Brute-Force 공격이 발생했을 때 접근 위반 오류가 발생하게 함

### 커널 주소 공간에서의 ASLR
* 32비트 - 64개의 로딩 주소
* 64비트 - 256개의 로딩 주소
* 유저 공간 이미지의 재배치는 커널 공간에서 많은 작업 공간을 요구
  * 부족하다면 ASLR은 이 작업 용도로 시스템 프로세스의 유저 모드 주소 공간을 사용
* 윈도우 10에서 ASLR 적용 범위
  * 페이지드, 넌페이지드 풀, 시스템 캐시, 페이지 테이블과 같은 대부분의 시스템 메모리 영역에 적용