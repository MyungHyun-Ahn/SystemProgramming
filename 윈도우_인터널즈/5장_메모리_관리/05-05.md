# 메모리 관리 05 - 페이지 폴트
## 페이지 폴트(page fault)
* 유효하지 않은 PTE 참조
  * PTE의 유효 비트가 클리어되어 있는 경우

### 페이지 폴트 핸들링
* 커널 트랩 핸들러는 이런 폴트를 메모리 관리자 폴트 핸들러(MmAccessFault)로 전달
* 이 루틴은 폴트를 발생시킨 스레드 컨텍스트에서 수행
* 가능하면 해결, 불가능하다면 적절한 예외를 발생시킴

![5-14](https://github.com/user-attachments/assets/959194a0-8898-41c8-b4aa-6abb224b04c5)

### 유효하지 않은 PTR
* 주소 변환 중 PTE의 유효 비트가 0이라면 그 PTE는 유효하지 않은 페이지를 나타냄
  * 이런 페이지를 참조하면 페이지 폴트 발생
* MMU는 이때 남은 비트를 무시함
* 운영체제가 남은 비트들을 사용하여 페이지 폴트를 해결함

### 소프트웨어 PTE
MMU 대신 메모리 관리자에 의해 해석되기 때문에 소프트웨어 PTE라고 불림
1. 페이지 파일
    * 요청된 페이지는 페이징 파일 내 존재
    * PTE의 4비트는 페이지가 존재하는 16개의 가능한 페이지 파일을 나타냄
    * 32비트는 파일 내에서 페이지 번호를 제공함
    * 페이저(pager)는 해당 페이지를 메모리로 가져와 유효하게 만들기 위해 인페이지 동작 수행
    * 페이지 파일 오프셋은 다른 포멧을 허용하기 위해 0이 아니거나 모두 1이 아님
2. 제로 요청
   * 페이지 파일 오프셋은 0
   * 모두 0으로 채워진 페이지여야 함
   * 제로 페이지 리스트 -> 프리 리스트 순으로 페이지를 찾아옴
     * 프리 리스트의 페이지라면 가져와서 0으로 채움
   * 프리 리스트도 비어있다면 스탠바이 리스트에서 찾아옴
3. 가상 주소 디스크립터
    * 페이지 파일 오프셋 필드가 모두 1
    * 프로세스의 VAD 트리에서 찾을 수 있는 페이지
    * 매핑 파일에서 섹션에 의해 백업되는 페이지를 위해 사용
    * 페이저는 VAD에 의해 참조되는 맵 파일로부터 인페이지 동작 수행
4. 트랜지션(Transition)
    * 트랜지션 비트가 1
    * 요청된 페이지가 스탠바이 리스트나 변경 리스트, 쓰기 없는 변경 리스트에 있거나 어디에도 존재하지 않음
    * 페이저는 해당 페이지를 리스트에서 제거하고 프로세스 워킹셋에 추가
    * I/O가 동반되지 않으므로 소프트 페이지 폴트
5. Unknown
   * PTE가 0이거나 페이지 테이블이 아직 존재하지 않음
   * 두 경우 모두 커밋 여부 확인이 필요함
     * VAD를 검사
   * 커밋 되었다면 새롭게 커밋된 주소 공간을 위한 페이지 테이블이 만들어짐
   * 커밋이 안되었다면 페이지 폴트가 엑세스 위반 예외로 보고됨

### 인페이징 I/O
* 페이지 폴트를 해결하기 위해 파일에 대한 읽기 동작이 반드시 필요
  * 이때 발생하는 것이 인 페이징(In-Paging) I/O
* 페이지 테이블 자체도 페이징이 가능 - 페이지 폴트 처리 중 다른 I/O가 발생할 수 있음
  * 시스템이 참조하려는 원본 페이지에 대한 정보를 포함하고 있는 PTE의 경우 발생 가능
  * 페이지 테이블 딕셔너리도 페이징이 가능할까? - 여기서 페이지 폴트가 발생해도 괜찮은가?
  * 고민이 조금 필요할 듯

인페이징 I/O는 동기적
* 스레드는 I/O가 완료될 때까지 대기된다는 의미
* APC에 의해 인터럽트되지 않음
* 페이저는 I/O 요청 함수 내에서 페이징 I/O를 나타내기 위해 Modifier를 사용
* 페이징 I/O 완료되면 I/O 완료 이벤트를 통해 페이저를 깨워 계속 진행하게 함
* 페이징 I/O가 처리되는 중 동일한 프로세스 내 다른 스레드는 가상 메모리 함수 사용 가능, 페이지 폴트 또한 해결 가능

I/O 작업이 완료될 때 페이저가 알아야만 하는 몇 가지 흥미로운 조건
* 같은 프로세스 내의 다른 스레드가 동일한 페이지에 폴트를 발생시킬 수 있음
  * 폴트 충돌
* 페이지가 가상 주소 공간에서 삭제되고 다시 매핑될 수 있음
* 페이지에 대한 보호가 변경될 수 있음

페이저는 페이징 I/O 요청 전 스레드의 커널 스택에 충분한 상태 정보를 저장
* 요청이 완료되었을 때 이런 조건을 감지하고 페이지 폴트를 무시 가능
* 폴트를 일으킨 명령이 다시 실행되면 페이저는 다시 호출되고 PTE는 새로운 상태에서 다시 평가

### 페이지 폴트 충돌 (Collided page fault)
* 현재 페이징 인되고 있는 페이지에 대해 동일한 프로세스 내의 다른 스레드에서 다시 폴트를 발생시키는 것
* PFN에 명시된 정보로 이를 감지할 수 있음
* 이 경우 PFN 데이터베이스 엔트리에 명시된 이벤트에 대해 대기 명령을 내릴 수 있음
* 대안으로 파일 시스템이 데드락에 걸리는 것을 막기 위해 병렬 I/O를 발생시킬 수 있음
  * 먼저 완료한 I/O만 성공시키고 나머지는 무시
* 이 이벤트는 페이지 폴트를 위한 I/O를 처음으로 발생시켰던 스레드에 의해 초기화됨

I/O가 완료
* 대기 중이던 모든 스레드가 해제
* PFN 데이터베이스 락을 최초로 획득한 스레드는 인 페이지 완료 작업을 수행
  * I/O 상태 확인
  * PFN 데이터베이스 내의 읽기 진행 중 비트를 클리어
  * PTE를 갱신하는 작업

후속하는 다른 스레드가 페이지 폴트 충돌을 완료하기 위해 PFN 데이터베이스 락 획득
* 이때 페이저는 읽기 진행 중 비트가 지워진 것을 확인 - 최초 갱신 완료 인식
* PFN 데이터베이스 항목에서 인 페이지 오류 플래그 확인
  * 설정되어 있다면 PTE는 갱신되지 않고 인 페이지 오류 예외가 발생

### 클러스터 페이지 폴트
* 메모리 관리자는 페이지 폴트를 처리할 때 큰 클러스터 단위로 프리패치(Prefetch)해 시스템 캐시에 위치시킴

프리패치 동작
* 가상 메모리의 워킹셋 대신 시스템의 페이지 캐시로 데이터를 직접 읽어옴
* 프리패치된 데이터가 가상 메모리 공간을 소진하지 않게하고, 미리 읽어오는 데이터의 크기가 가용 가상 메모리 크기에 제약받지 않게 함
* 페이지가 용도 변경이 일어나는 경우 TLB 플러싱이 일어나는 프로세서 간 인터럽트가 필요없음
  * TLB 플러싱은 값이 비쌈
* 프리패치된 페이지는 스탠바이 리스트에 들어가고 PTE에 트랜지션 상태로 표시
* 프리패치된 페이지가 그 후에 참조되면 메모리 관리자는 워킹셋에 추가
  * 한번도 참조되지 않으면 그것을 해제하기 위해 시스템 리소스가 필요하지 않음
* 프리패치된 클러스터 내의 페이지가 이미 메모리에 있다면 메모리 관리자는 다시 읽지 않음

더미 페이지
* 하나의 커다란 페이지를 이용하여 효율적인 I/O을 발생시킬 수 있음
* 시스템 전역적으로 하나인 더미페이지(유효하지 않은 데이터)를 가리키게 할 수 있음
* 어떤 컴포넌트가 MDL 내의 더미 페이지에 매핑된 오프셋을 참조하면 더미 페이지를 보게 됨
* 메모리 관리자는 버려지는 많은 페이지를 하나의 더미 페이지로 나타낼 수 있음
  * 더미 페이지는 동일한 MDL에 여러 번 들어갈 수 있음
  * 그 결과 버려지는 페이지를 가리키는 위치에 대한 내용은 언제든 변경 가능

더미 페이지의 내용은 잘 모르겠음 - 6장의 MDL 내용과 다시 볼 것

### 페이지 파일
* 프로세스에 의해 아직 사용중이나 매핑 해제 혹은 메모리 압박으로 트림이 발생해 디스크에 써져야 할 변경된 페이지를 저장하는 용도
  * 트림(Trim) : 운영체제가 사용하지 않는 공간을 SSD 컨트롤러에게 알려주는 것
* 페이지가 최초 커밋되면 페이지 파일 공간이 예약되지만 페이지가 디스크에 기록되는 시점까지는 정확한 위치는 알 수 없음

페이징 파일의 크기
* 최댓값 최솟값이 모두 0 - 시스템에 의해 관리되는 페이지

윈도우 7에서의 크기 규칙
* 최소 크기 : RAM의 크기나 1GB 중 큰 값으로 설정
* 최대 크기 : 3 * RAM 크기나 4GB 중 큰 값으로 설정
  * 이런 설정이 이상적인 값은 아님
  * 초기 페이지 파일 크기 - RAM 크기로 설정
    * 디스크 크기가 상대적으로 작고 SSD 기반인 경우 디스크 공간의 손실로 이어짐
    * 또한 시스템에서 RAM의 크기가 일반적인 메모리 작업량이 아님

현재 구현은 좀 더 정교한 기법을 사용
* Smss.exe가 계산하는 방법
  * RAM, Crash dump, History, Apps 4가지 요소를 활용
  * 아래의 표처럼 계산

![5-15](https://github.com/user-attachments/assets/145c97cd-15fd-4483-992d-cfa6e3a9d13b)

새로운 페이지 파일 추가
* Ntdll.dll에 정의된 내부 NtCreatePagingFile 시스템 서비스를 사용
  * SeCreatePagefilePrivilage 권한이 필요
* 자신이 존재하는 디렉터리가 압축되었어도 항상 비압축 상태로 생성
* 이름은 PageFile.sys, 숨겨진 속성으로 루트 파티션에 생성되어 보이지 않음
* 페이지 파일이 삭제되는 것을 방지하기 위해 핸들이 시스템 프로세스로 복사됨
  * 따라서 프로세스가 닫더라도 복사된 핸들로 인해 삭제되지 않음

### 스왑 파일
* 메모리의 압박이 클 경우 다른 프로세스를 위해 워킹셋은 디스크로 나갈 수 있음
* 윈도우 8부터 추가된 스왑 파일(Swap file)
* 본질적으로는 페이지 파일과 동일하지만 UWP 앱 전용으로만 사용
  * 최소한 하나의 일반 페이지 파일이 생성된 경우 클라이언트 SKU에 생성됨
  * SwapFile.sys라는 이름을 가지고 시스템 루트 파티션에 존재
* 스왑 파일은 지원 가능한 최대 페이지 파일 개수에 고려되지 않음

### 가상 페이지 파일
* 이름이 없는 페이징 파일 - 가상 페이지 파일
* 실제 파일을 갖지 않음
* 메모리 압축 용도의 저장소로 간접적으로 사용
* 이 파일은 크지만 프리 공간을 소진하지 않으며 임의로 설정됨
* 압축된 페이지의 유효하지 않은 PTE는 가상 페이지 파일을 가리키고
* 메모리 압축 저장소가 유효하지 않은 PTE 내의 비트를 해석해 필요한 시점에 압축된 데이터가 있는 곳으로 갈 수 있게 함

### 커밋 양과 시스템 커밋 제한
* 목적 : 과도하게 커밋되지 않게 보장하기 위함
* 즉, 내용을 저장할 공간보다 추가적으로 정의된 가상 주소가 존재하지 않는다는 것

시스템 커밋 제한
* 개념적으로 백업 저장소와 연관된 가상 할당을 함께 나타냄
* 즉, 파일에 매핑된 섹션을 포함함
* 단순히 가용한 RAM의 양과 현재 모든 페이지 파일의 크기를 더한 값
* 페이지 파일 확장 혹은 추가 생성하면 커밋 제한 또한 증가

커밋 양
* RAM이나 페이지 파일에 보관되어야 하는 시스템 전역적인 모든 커밋된 메모리 할당의 총합
* 프로세스 전용으로 커밋된 가상 주소 공간 또한 포함됨

프로세스 페이지 파일 할당량(process page file quota)
* 윈도우에서 프로세스별 카운터를 관리함
* 시스템 커밋 양에 대한 각 프로세스별 기여를 나타냄

시스템 커밋 양에 기여하고, 많은 경우 프로세스 페이지 할당량에 기여하는 유형의 메모리 할당
* 전용으로 커밋된 메모리 : VirtualAlloc(MEM_COMMIT)
* 페이지 파일 백업 매핑 메모리
* 매핑된 메모리의 쓰기 시 복사 영역
* 넌페이지드 풀, 페이지드 풀, 명시적으로 연관된 파일에 저장되지 않는 시스템 영역 할당
* 커널 스택
* 페이지 테이블
  * 이들 중 대부분은 페이징 가능, 맵 파일에 저장되지 않음
  * 페이징이 가능하지 않더라도 RAM을 차지
* 실제로 아직 할당되지 않은 페이지 테이블을 위한 공간
  * 아직 참조되지 않은 가상 공간은 페이지 테이블을 생성할 필요가 없음
  * 하지만 이런 존재하지 않는 페이지 테이블을 위한 공간은 테이블이 필요할 때 만들어질 수 있으므로 커밋 양에 포함됨
* 주소 윈도잉 확장(AWE) API를 통해 이뤄진 물리 메모리 할당

어떠한 경우에는 커밋 양은 실제보다는 잠재된 사용을 나타낼 수 있음
* 커밋된 전용 메모리 참조 이전 - 제로 요청 페이지임
  * 실제로 공간을 점유하지 않음
* 그러나 커밋 양은 이런 것들을 포함

전용 메모리를 Reserve 하고 나중에 커밋할 때
* 윈도우 8 이전 버전 - 커밋 양에 포함
* 윈도우 8 이후 - 즉시 부가되지는 않음
  * 대규모 예약 메모리 영역은 페이지 테이블을 소진하지 않고서 할당될 수 있음을 의미
  * 커밋될 때 커밋 양에 포함됨

VirtualAlloc 호출을 성공적으로 끝낼 때 추후에 이용가능하게 약속(commitment)을 해두는 것
* 할당된 영역에 대한 이후의 메모리 참조는 저장 공간 부족으로 실패할 수 없음
* 커밋 양 메커니즘이 이를 보장