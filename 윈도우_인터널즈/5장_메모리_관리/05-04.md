# 메모리 관리 04 - 주소 변환
## x86 가상 주소 변환
* 최초의 x86 커널은 4GB 이상의 물리 메모리를 지원하지 않음
* 인텔 x86 펜티엄부터 물리 주소 확장(PAE, Physical Address Extension) 메모리 매핑 모드 지원
  * 물리 주소가 36비트까지 확장
* 적절한 칩셋이라면 64GB까지 접근 가능
* 윈도우 비스타부터는 항상 PAE 커널을 지원
  * 따라서 PAE 주소 변환에 대해서만 알아볼 것

### 페이지 테이블(Page tables)
* 메모리 관리자가 생성하고 관리하는 데이터
* 이것을 이용하여 가상 주소를 물리 주소로 변환
* 각 페이지는 페이지 테이블 엔트리(PTE)와 연계

### 페이지 테이블 엔트리(PTE, Page table entry)
* 가상 주소와 매핑된 물리 메모리 주소가 저장
* 가상 페이지는 연속되지만 물리적으로는 연속적이지 않을 수 있음
* 이것은 첫 번째 페이지 폴트에서 매핑됨
  * 실제 접근되지 않았다면 PTE가 존재하지 않을 수 있음
* 커널 코드 또한 물리 메모리에 매핑된 가상 주소로 간접 참조해야 함

![5-8](https://github.com/user-attachments/assets/6a67e071-3653-42c2-9b90-a481ef82e802)

실제 변환 과정과 페이지 테이블, 페이지 디렉터리의 배치는 CPU에 의해 결정
* 운영체제는 이런 개념이 잘 동작하도록 메모리에 구조체를 올바르게 구축함

변환 시스템의 입력 값과 출력 값
* 입력 값 : 32비트 가상 주소와 다수의 메모리 관련 구조체(PT, PDPT, 변환 룩 어사이드 버퍼)로 이루어짐
* 출력 값 : 실제 바이트가 위치할 36비트 물리 주소
  * 프로세서 특성에 의해 36비트가 나옴 (PAE)
* 작은 페이지를 매핑할 때 가상 주소의 최하위 12비트는 물리 메모리의 최종 결과에 바로 복사됨
  * 12비트는 정확히 4KB(작은 페이지 크기)

![5-9](https://github.com/user-attachments/assets/b60d463b-46cb-4b82-835e-34b1536d5cd7)

### 주소 변환 실패
* 물리 메모리가 아닌 페이지 파일에 존재하는 등
* 페이지 폴트 예외 발생
* 운영체제는 해당 페이지를 구하고 페이지 테이블에 페이지를 등록하고 OS는 다시 CPU에게 주소 변환을 하라 요청

![5-10](https://github.com/user-attachments/assets/217645fe-235e-49f0-a2a4-ca918ccd44d9)


CR3 레지스터부터 변환 과정이 시작
* CR3는 현재 실행 중인 프로세스의 PDPT 물리 주소 값을 가짐
* 프로세스 별 1개 씩 보유
* 다른 프로세스로의 컨텍스트 스위칭 시 이것도 교체
* PDPT는 32바이트 경계로 정렬되어야 함

### 가상 주소를 물리 주소로 변환하는 순서
1. 가상 주소의 최상위 두 비트(30, 31)는 PDPT로의 인덱스를 제공
   * 이 테이블은 4개의 엔트리를 가짐
   * 선택된 엔트리는 페이지 디렉터리의 물리 주소를 가리킴
2. 페이지 디렉터리는 512개의 엔트리를 가짐
   * 가상 주소 비트 21에서 29까지인 9비트에 의해 그중의 한 엔트리가 선택됨
   * 선택된 PDE는 페이지 테이블의 물리 주소를 가리킴
3. 페이지 테이블 또한 512개의 엔트리를 가짐
   * 가상 주소의 비트 13에서 20까지인 9비트에 의해 그중 한 엔트리가 선택됨
   * 선텍된 PTE는 페이지의 물리 시작 주소를 가리킴
4. 가상 주소 오프셋이 호출자에 의해 요청된 최종 물리 주소를 만들기 위해 PTE가 가리키는 주소에 더해짐
   * 최하위 12비트

### 페이지 프레임 번호(page frame number)
* 다양한 테이블 내의 각 엔트리 값은 페이지 단위로 정렬된 주소를 가리키기 때문에 페이지 프레임 번호라고 불림
* 각 엔트리는 64비트 크기지만 64GB 물리 영역을 기술하는 데 24비트만이 필요
  * 페이지 디렉터리나 페이지 테이블의 크기는 4KB 페이지보다 클 수 없음
  * 24비트에 12비트 오프셋을 더해 총 36비트가 됨

### 유효 비트
* 전체 메커니즘에 중요한 역할
* PFN 데이터가 실제로 유효해 변환 절차를 수행해야 하는지를 나타냄
* 이 비트가 설정되어 있지 않다면 페이지 폴트를 나타냄
* CPU는 예외를 일으키고 OS가 적절한 방식으로 페이지 폴트를 처리하기를 기대

각 프로세스의 전용 주소 공간 제공
* 자신만의 PDPT와 페이지 디렉터리, 페이지 테이블을 가짐

시스템 주소 공간
* 프로세스 간 공유(세션 공간은 세션 내의 프로세스 간 공유)
* 시스템 공간을 기술하는 PDE는 기존 시스템 페이지 테이블을 가리키게 초기화 됨

### 페이지 테이블과 페이지 테이블 엔트리
* PDE는 페이지 테이블
* 페이지 테이블은 PTE의 배열
* PDPT 또한 페이지 테이블의 배열
* 모든 페이지 테이블은 512개의 엔트리를 가짐
* PTE는 4KB를 매핑
  * 즉, 한 페이지 테이블이 2MB 주소 공간을 매핑할 수 있음을 의미
  * 512 * 4KB
* 한 페이지 디렉터리는 512 * 2MB를 매핑할 수 있음
* 4개의 PDPE가 존재하고 이를 모두 합치면 32비트 전체 4GB를 매핑할 수 있음

큰 페이지의 경우
* PDE는 11비트 - 물리 메모리의 큰 페이지 시작 부분을 가리킴
* 바이트 오프셋은 하위 21비트로부터 구해짐
* 큰 페이지를 매핑하는 PDE는 페이지 테이블을 가리키지 않음을 의미

PAE 모드에서 PTE의 정의 비트
* 크기는 64비트임
* PAE 모드가 아니라면 32비트

![5-11](https://github.com/user-attachments/assets/856b5736-a033-44cb-bc7e-10521a8fe9da)

더티(dirty) 비트와 접근(Accessed) 비트 두 개를 포함
* 엑세스 하는 시점에 접근 비트가 꺼져있다면 읽기나 쓰기가 발생할 때 MMU는 이 비트를 설정
* MMU는 페이지에 쓰기가 일어날 때마다 더티 비트를 설정
* 이 두 비트는 MMU에 의해 꺼지지 않고 운영체제가 적절한 시점에 꺼야함

x86 메모리 관리 유닛은 페이지 보호를 위해 쓰기(Write) 비트를 사용함
* 이 비트가 꺼져있다면 읽기 전용
* 켜져있다면 읽기/쓰기 상태
* 쓰기 비트가 꺼져있는 페이지에 쓰기를 시도하면 메모리 관리 예외 발생
* 메모리 관리자의 엑세스 폴트 핸들러가 해당 페이지에 쓸 수 있게할지, 엑세스 위반을 발생해야 할지 등을 결정

### 페이지 테이블 엔트리 내의 하드웨어 쓰기 비트와 소프트웨어 쓰기 비트
소프트웨어로 구현된 추가적인 쓰기 비트
* 더티 비트의 갱신과 윈도우 메모리 관리 데이터의 갱신을 동기화하게 강제하는 데 사용
* 메모리 관리자는 모든 쓰기 가능 페이지에 대해 하드웨어 쓰기 비트를 설정하고 MMU가 PTE 내의 더티 비트를 설정하게 만듬
* 이후 이 더티 비트는 메모리 관리자에게 물리 페이지가 사용되기 전 플러시 해야함을 알려줌

이것은 경쟁 상태를 유발할 수 있음
* 메모리 관리자는 이것을 해결하기 위해 푸시락을 사용
* 그러나 한 프로세서가 락을 소유하고 있는 동안 다른 프로세서의 MMU에 의해 변경될 수 있음
* 더티 비트에 대한 갱신을 잃게 만드는 가능성을 유발

이러한 상황을 방지하기 위한 방법
* 윈도우 메모리 관리자는 읽기 전용과 쓰기 가능한 페이지의 PTE에 대한 하드웨어 쓰기 비트를 0으로 초기화
* 페이지의 실제 쓰기 가능한 상태를 소프트웨어 쓰기 비트에 기록
* 이런 페이지의 첫 쓰기 접근 -> 메모리 관리 예외 발생
* 이 경우 메모리 관리자는 (쓰기 가능함) 워킹셋 푸시락을 획득하고 PTE 내의 하드웨어 쓰기 비트와 더티 비트를 설정
* 워킹셋 리스트를 갱신하고 푸시락 해제하고 예외 제거
  * 변경되었다는 것을 알림
* 하드웨어 쓰기 작업은 보통처럼 처리됨
  * 더티 비트의 설정은 워킹셋 리스트 푸시락을 소유한 채로 일어남

이후의 쓰기 작업은 예외가 발생하지 않음
* 하드웨어 쓰기 비트가 설정되어 있으므로
* MMU는 불필요한 더티 비트 설정을 하지만 페이지의 쓰여짐 상태는 이미 워킹셋 리스트에 기록되므로 문제가 없음
  
페이지에 대한 첫 쓰기 작업이 예외 핸들링을 강제하는 것
* 오버헤드가 아닌가?
  * 오직 한번만 발생
  * PTE는 처음에 유효하지 않은 상태로 초기화 됨
  * 따라서 어차피 모든 페이지에 대한 첫 접근은 예외 핸들링을 거침
* 페이지에 대한 첫 번째 쓰기 접근이라면 더티 비트 처리는 최초 접근 페이지 폴트 처리 내에서 일어날 것이므로 오버헤드가 작음

이 구현 방법은 플러시되는 각 페이지에 대한 락을 소유하지 않고도 변환 룩 어사이드 버퍼를 플러싱하게 허용

## 변환 룩 어사이드 버퍼(TLB)
각 하드웨어 주소 변환은 세 가지 참조를 필요로 함
* PDPT에서 엔트리를 찾기
* 페이지 디렉터리에서 엔트리 찾기
* 페이지 테이블에서 엔트리 찾기

메모리 검사를 세 번씩 진행?
* 메모리 대역폭 4배, 분명한 성능 저하 발생

변환 룩 어사이드 버퍼(TLB)
* 모든 CPU는 주소 변환을 캐시하여 반복된 접근은 같은 변환이 일어나지 않게 함
* Associative 메모리 배열 형태
* 셀들을 동시에 읽고 대상 값을 비교할 수 있는 일종의 버퍼
* 태그(가상 주소의 일부분)와 데이터 부분으로 이뤄져 있음
* PTE의 전역 비트가 설정되어 있으면 TLB 엔트리는 컨텍스트 스위칭이 일어나도 무효화되지 않음
  * 컨텍스트 스위칭이 일어나도 무효화 되지 않는 경우?
  * 아마도 같은 프로세스 간의 컨텍스트 스위칭인듯함

만약 가상 페이지가 페이지 아웃 혹은 PTE가 변경되면?
* 메모리 관리자는 명시적으로 TLB 엔트리를 무효화해야 함
* 프로세스가 다시 접근하면 페이지 폴트가 발생
  * 메모리 관리자가 다시 메모리로 읽고 PTE 엔트리를 생성함
  * 이때 TLB 내에 엔트리가 만들어짐

## x64 가상 주소 변환
x64에서 주소 변환은 x86과 유사하지만 4번째 단계가 추가
* 각 프로세스는 확장된 최상위 레벨의 페이지 디렉터리를 가짐
  * 페이지 부모 디렉터리(page parent directories)라 불리는 레벨 3 구조체에 대한 512개의 물리 위치를 포함
  * PAE의 PDPT와 유사하지만 1개가 아닌 512개가 있고, 4개가 아닌 512개의 엔트리를 포함하는 완전한 페이지

현재 구현된 x64 아키텍처는 가상 주소를 48비트로 제한

![5-12](https://github.com/user-attachments/assets/6b772fc0-0483-4f1b-8320-f9b581457aa0)

![5-13](https://github.com/user-attachments/assets/ed8b3319-d293-4865-b014-c06195ba42a5)