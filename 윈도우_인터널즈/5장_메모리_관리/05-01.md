# 05 메모리 관리 01
## 메모리 관리자 소개
### 가상 메모리 크기
* 기본 32비트 윈도우 : 2GB
* 큰 주소 인식(Large Address Space Aware)과 특별한 옵션 적용 : 3GB 까지 확장
* 64비트 윈도우 : 4GB 까지 확장
* 64비트 윈도우8, 서버 2012 : 8TB
* 64비트 윈도우 8.1, 서버 2012 R2 이후 : 128TB
* 버전에 따라 다름

### 메모리 관리자의 두 가지 역할
* 프로세스 가상 주소 공간을 물리 메모리로 변환, 매핑
* 물리 메모리가 부족할 경우 디스크로 페이징 아웃, 필요할 때 페이지 인
* 윈도우 환경 서브시스템이 내장하는 메모리 맵 파일, 복사 메모리, 큰 주소 공간, 희소 주소 공간을 사용하는 애플리케이션 지원 등

## 메모리 관리자 컴포넌트
익스큐티브에서 가장 큰 컴포넌트
* 중요하고 복잡함
* 하드웨어 추상화 계층(HAL, Hardware Abstraction Layer)에는 존재하지 않음

### 메모리 관리자의 컴포넌트
* 가상 메모리 할당 해제, 관리의 API,드라이버 인터페이스
* 유효하지 않은 메모리 변환(Translation-not-valid) 액세스 폴트 트랩 핸들러
  * 하드웨어 탐지 메모리 관련 예외 처리
  * 가상 페이지를 물리 메모리에 상주시키기 위함
* 커널 모드 스레드로 동작하는 6개의 최상위 루틴
  * 밸런스 셋 관리자(KeBalanceSetManager, 우선순위 17)
    * 1초에 한 번씩 사용 가능 메모리(Free Memory)의 양이 특정 임계치 이하로 떨어지면 워킹셋 관리자(MmWorkingSetManager)를 호출
    * 워킹셋 관리자는 워킹셋 정동, 에이징, 변경된 페이지 쓰기 작업 등의 메모리 관리 정책 처리
  * 프로세스/스택 스와퍼(KeSwapProcessOrStack, 우선순위 23)
    * 프로세스와 커널 스레드 스택의 스와핑을 수행
    * 밸런스 셋 관리자와 커널 내의 스레드 스케줄링 코드는 필요하면 이 스레드를 깨움
  * 변경된 페이지 기록자(MiModifiedPageWriter, 우선순위 18)
    * 더티 페이지를 적절한 페이징 파일에 기록
    * 변경된 페이지 리스트의 개수가 줄어야 할 때마다 깨어남
  * 맵 페이지 기록자(MiMappedPageWriter, 우선순위 18)
    * 더티 페이지를 매핑된 파일에 적음
    * 변경된 페이지 리스트의 개수가 줄어야하거나 변경된 페이지 리스트에 5분 이상 있다면 깨어남
    * 두 번째 변경된 페이지 기록자 스레드는 프리 페이지에 대한 요청으로 페이지 폴트가 발생할 수 있기 때문에 반드시 필요
    * 변경된 페이지 기록자 스레드가 1개고 프리 페이지가 없다면 시스템은 프리 페이지를 대기하다 데드락에 빠질 수 있음
  * 세그먼트 역참조 스레드(MiDereferenceSegmentThread, 우선순위 19)
    * 캐시 축소 혹은 페이지 파일 확장 축소 작업 진행
  * 제로 페이지 스레드(MiZeroPageThread, 우선순위 0)
    * Free List의 페이지를 0으로 초기화하여 제로 페이지 폴트(Demand-Zero page fault)를 처리하는데 제로 페이지 캐시가 사용될 수 있게 함
    * 일부 경우 메모리 제로화는 MiZeroInParallel이라는 함수에 의해 빨리 이뤄짐

## 큰 페이지와 작은 페이지
페이지(pages)
* 메모리를 관리하는 단위 - 하드웨어에서 보호할 수 있는 최소 단위
* 윈도우는 Small 페이지와 Large 페이지 두 가지를 지원

페이지 크기는 아키텍처마다 다름
* x86, x64 작은 페이지 : 4KB
* x86, x64 큰 페이지 : 2MB

큰 페이지의 장점
* TLB 변환 시 필요한 정보의 크기를 효율적으로 사용 가능
* 큰 페이지가 이 제한된 리소스를 더 잘 사용
* 윈도우는 이런 이점을 활용하기 위해 핵심 운영체제 데이터를 큰 페이지에 매핑시킴

운영체제가 장시간 운영되면 큰 페이지 할당 시도가 실패 가능
* 시스템이 동작함에 따라 단편화 발생

큰 페이지의 단점
* 메모리 보호 속성이 페이지 단위로 적용됨
* 읽기/쓰기 영역과 읽기 영역을 분리하지 못함
  * 취약점이 될 수 있음
  * 쓰기가 허용되면 안되는 영역에 쓰기가 허용된다면 나중에 누군가 손상된 데이터를 사용할 때 크래시가 발생할 수 있음

## 내부 동기화
멀티프로세서 시스템에서 동시 실행을 지원
* 스핀락과 인터락 명령 등의 동기화 메커니즘을 사용

메모리 관리자가 동기화를 수행해야 하는 시스템 전역 자원
* 동적으로 할당되는 시스템 가상 주소 공간의 부분
* 시스템 워킹셋
* 커널 메모리 풀
* 로드된 드라이버 리스트
* 페이징 파일 리스트
* 물리 메모리 리스트
* 이미지 베이스 랜덤화 주소 공간 배치 랜덤화 구조체
* 페이지 프레임 번호 데이터베이스 내의 각 엔트리

프로세스 마다 동기화가 필요한 메모리 관리 구조체
* 워킹셋 락 : 워킹셋에 유지되는 락
* 주소 공간 락 : 주소 공간을 변경할 때 유지되는 락

## 메모리 관리자가 제공하는 서비스
### 윈도우 API가 제공하는 메모리 관리 API
* 가상 API : 페이지 단위로 동작하는 가장 저수준의 API
* 힙 API : 작은 할당을 위한 함수 제공
  * 한 페이지보다 작을 경우 이용함
  * 내부적으로 가상 API를 사용하지만 가상 API 상단에 관리 계층을 추가
* 지역/전역 API : 16비트 시절 잔재, 지금은 힙 API를 사용
* 메모리 맵 파일 : 매핑 파일을 프로세스 간 공유 메모리 또는 메모리로 사용하게 함

![5-1](https://github.com/user-attachments/assets/7ceaf274-f748-47aa-ab6d-b1eec073a3fc)

메모리 관리자는 익스큐티브 내의 다른 커널 모드 컴포넌트에 다양한 서비스 제공
* 물리 메모리 할당 해제
* 직접 메모리 접근 (DMA)
* 페이징 락킹(Locking)
* 이런 함수는 Mm 접두사로 시작

일부 익스큐티브는 시스템 힙에 대한 할당 해제(페이지드 풀, 넌페이지드 풀), 룩 어사이드 리스트 등의 Ex로 시작하는 함수 제공

## 페이지 상태와 메모리 할당
전용 페이지 할당 방법
* VirtualAlloc 계열의 함수로 가능
* 이런 함수는 모두 NtAllocateVirtualMemory 함수가 있는 익스큐티브로 최종적으로 이어짐
* 이런 함수로 메모리 커밋과 예약이 가능

메모리 예약의 의미
* 작은 시스템 자원을 사용해 미래 사용에 대비해 연속적인 가상 주소의 범위를 확보함을 의미
* 미리 요구 사항을 안다면 한번의 함수 호출로 예약과 커밋을 동시에 가능
* 결과적으로 커밋된 페이지는 해당 프로세스의 모든 스레드에 의해 접근 가능
* 해제 혹은 예약된 메모리에 접근을 시도하면 예외를 일으킴

커밋된 페이지는 최초 접근 시 0으로 초기화됨
* 커밋된 페이지는 물리 메모리의 요구에 따라 페이징 파일에 저장될 수 있음

ReadProcessMemory 혹은 WriteProcessMemory
* 프로세스 간 메모리 접근을 허용하는 것처럼 보이지만, 대상 프로세스의 컨텍스트에서 동작하는 커널 모드 코드에 의해 구현됨
* 이런 함수는 대상 프로세스의 보안 기술자에 의해 접근이 허용되어야 함

### 공유 페이지
* 섹션 뷰에 매핑됨
* 파일의 일부 혹은 전체, 페이지 파일 공간의 일부일 수 있음
* 모든 공유 페이지는 다른 프로세스와 공유될 수 있음
* 윈도우 API에서 파일 매핑 객체로 노출
* 최초로 접근될 때 관련된 맵 파일이 읽혀짐
* 이후 물리 메모리에 여전히 존재하면 간단히 사용할 수 있음
* 시스템에 의해 프리패치됐을 수 있음

### 변경된 페이지 쓰기(modified page writing) 메커니즘
* 페이지가 프로세스의 워킹셋에서 변경된 페이지 리스트라는 곳으로 이동하며 발생
* 이 작업으로 페이지는 디스크나 원격 저장소에 써짐
* 원격 페이지의 경우 FlushViewOfFile 혹은 메모리 요청 발생 시 Mapped page writer에 의해 원본 파일에 써짐

### 메모리 해제
* VirtualFree 계열의 함수를 통해 디커밋 가능
* 디커밋과 Release의 차이 - 예약과 커밋의 차이와 동일
* 디커밋된 메모리는 아직 예약된 상태이지만 해제된 메모리는 프리 상태

### 전체 공간을 예약하고 필요할 때마다 커밋하는 방법
* 대표적인 예 : 스레드에 대한 유저 모드 스택
* 기본적으로 첫 번째 페이지는 커밋되고 다음 페이지는 가드 페이지로 설정됨
* 커밋된 영역을 넘어 접근하면 트랩이 발생하고 이때 스택이 확장됨

### 커밋 양과 커밋 제한
커밋 양(Commit charge)
* 메모리 관리자가 커밋된 전용 메모리 사용을 추적하는 것
* 작업 관리자의 성능 탭의 커밋됨의 첫 번째 값

커밋 제한(Commit limit)
* 시스템 전역적인 제한
* 모든 페이징 파일의 전체 크기와 운영체제에 의해 사용 가능한 RAM 양을 합친 것과 동일함
* 작업 관리자의 성능 탭의 커밋됨의 두 번째 값
* 메모리 관리자는 아직 설정된 최대 크기에 도달하지 않았다면 하나 이상의 페이징 파일을 확장함 - 커밋 제한을 자동으로 증가시킴

### 메모리 락킹
페이지 락킹을 통해 물리 메모리 내에 페이지를 남길 수 있음

페이지 락킹을 하는 방법
* VirtualLock 함수를 사용
  * 상주 가능한 페이지 양을 반드시 구하고 사용해야 함
  * 과도한 락킹은 시스템이 크래시될 수 있음
* 디바이스 드라이버에서 커널 모드 함수 사용

## 공유 메모리와 맵 파일
### 공유 메모리(shared memory)
* 하나 이상의 프로세스 가상 주소 공간에 있는 메모리
* 대표적인 예로 DLL이 있음

![5-2](https://github.com/user-attachments/assets/be8f74f1-c4ee-4d5d-a9cb-997f6dbe3f07)

DLL 코드나 변경되지 않는 페이지는 손상없이 공유 가능함
* 코드 페이지는 실행 전용 속성으로만 매핑
* 쓰기 가능 페이지는 쓰기 시 복사 속성으로 매핑됨

### 섹션 객체(Section Object)
* 공유 메모리 구현을 위해 사용되는 메모리 관리자 내부의 프리미티브(Primitives)
* 윈도우 API에서는 파일 매핑 객체로 공개됨
* 가상 주소를 매핑하기 위해 사용
* 섹션은 여러 프로세스에 의해 열릴 수 있음
  * 공유 메모리와 완전히 동일할 필요는 없음

### 페이지-파일-백업-섹션(Page-file-backed-sections)
* 커밋된 메모리에 매핑된 섹션
  * 섹션 객체는 맵 파일이나 커밋된 메모리와 연결될 수 있음
* 물리 메모리 요청이 발생하면 해당 페이지가 페이징 파일로 쓰이기 때문
* 유저 모드에서 보이는 빈 페이지의 경우처럼 커밋된 공유 페이지는 최초 접근 시 0으로 초기화

## 메모리 보호
### 윈도우의 4가지 메모리 보호 기능
* 커널 모드 시스템 컴포넌트에 의해 사용되는 리소스는 커널모드에서만 접근 가능
  * 유저 모드 스레드에서 접근하면 하드웨어는 폴트를 일으키고 메모리 접근 위반 오류를 보고함
* 다른 프로세스에 포함된 스레드에 의한 접근으로부터 보호되는 전용 주소 공간을 가짐
  * 공유 영역 또한 자신의 가상 주소 공간의 일부분으로 사용하기 때문에 예외가 되지 않음
  * 유일한 예외는 ReadProcessMemory 등의 함수
* 일종의 하드웨어 제오 메모리 보호를 지원
  * 다양한 속성을 통해
  * VirtualProtect, VirtualQuery 등의 문서를 참고할 것
* 프로세스가 섹션 객체를 열려고 시도할 때 접근 권한을 갖고 있는지 검사하는 윈도우 접근 제어 목록(ACL)을 가짐
  * 파일 객체에 대해 권한을 가지고 있어야 함(읽기, 쓰기 권한)

## 데이터 실행 방지
### DEP(Data Execution Prevention) 데이터 실행 방지 또는 실행 방지 보호 페이지(no-execute page)
* 실행 방지로 표시된 페이지에서 명령어가 실행될 때 접근 폴트를 발생시킴
* 이 기능으로 데이터 페이지에 코드를 위치시켜 실행하는 악성코드를 차단할 수 있음
* 실행 방지로 설정된 페이지가 실행되면
  * 커널모드에선 ATTEMPTED_EXECUTE_OF_NO_EXECUTE_MOMORTY 버그 체크 코드를 보여주며 크래시됨
  * 유저모드에선 STATUS_ACCESS_VIOLATION 예외가 불법적인 참조를 시도하는 스레드로 전달됨

실행할 필요가 있는 메모리를 할당하는 법
* PAGE_EXECUTE 속성을 포함시켜 메모리 할당함

DEP를 지원하는 32비트 x86 시스템에서 PTE의 63번 비트는 실행 불가 페이지로 표시하는데 사용
* PAE 모드가 사용되지 않을 때 DEP 기능을 사용 가능

### 64비트 윈도우에서 실행 방지 기능
* 스레드 스택(유저 커널 모두)과 실행 가능으로 명시적으로 표시되지 않은 유저 모드 페이지, 커널 페이지드 풀, 커널 세션 풀에 적용됨
* 32비트 윈도우에서는 스레드 스택과 유저 모드 페이지에만 적용됨

## 쓰기 시 복사
### 쓰기 시 복사 페이지 보호
* 메모리 관리자가 물리 메모리를 절약하기 위해 사용하는 최적화 방법

동작
* 메모리 관리자가 페이지에 쓰기 행위가 일어나는 순간까지 페이지 복사를 지연시킴

한 스레드가 페이지에 쓰면 메모리 관리 폴트가 발생
* 이때 엑세스 예외 에러를 보고하는 대신 다음 작업을 수행
  1. 물리 메모리에 읽기/쓰기 속성을 가진 새로운 페이지를 할당
  2. 원본 페이지에 있던 데이터를 새로운 페이지에 복사
  3. 해당 프로세스에서 사용하는 페이지 매핑 정보를 갱신하여 새로운 위치를 가리킬 수 있게 함
  4. 발생한 예외를 취소한 후 예외가 발생한 코드를 다시 수행하게 함

새롭게 복사된 페이지는 쓰기 작업을 수행했던 프로세스의 전용 메모리가 되고, 쓰기 시 복사 페이지를 공유하는 다른 프로세스는 여전히 새롭게 복사된 이 페이지를 볼 수 없음

### 대표적인 예
* 브레이크 포인트의 구현
  1. 해당 페이지를 PAGE_EXECUTE_READWRITE로 변경하고 명령 스트림을 변경
  2. 디버그 브레이크가 설정된 전용 메모리를 새롭게 할당하고, 다른 프로세스 들은 변경되지 않은 코드 페이지를 사용하게 해줌

쓰기 시 복사는 메모리 관리자가 가능한 많이 사용하는 지연 평가 기법 중 하나

## 주소 윈도잉 확장(AWE, Address Windowing Extension)
* 프로세스의 가상 주소 공간으로 표현할 수 있는 것보다 더 많은 물리 메모리를 할당할 수 있게 함
* 프로세스는 다양한 시점에 자신의 가상 주소 공간의 일부를 물리 메모리의 선택된 부분으로 매핑하여 접근 가능

AWE 함수를 이용해 메모리를 할당하는 방법
1. 사용할 물리 메모리 할당 AllocateUserPhysicalPages
2. 물리 메모리에 대한 뷰를 매핑하는 윈도우로 동작할 수 있는 하나 이상의 가상 주소 공간 영역을 생성 VirualAlloc 함수에 MEM_PHYSICAL
3. 1, 2단계는 일반적으로 말하는 초기화 단계, 실제로 사용하려면 가상 영역이나 윈도우 중의 하나로 매핑하기 위해 MapUserPhysicalPages, MapUserPhysicalPagesScatter

AWE 함수에 의해 할당된 메모리의 제약사항
* 페이지는 프로세스 간 공유될 수 없음
* 동일한 물리 메모리는 하나 이상 가상 메모리로 매핑될 수 없음
* 페이지 보호 속성은 읽기/쓰기, 읽기 전용, 접근 금지로 제한됨

## 커널 모드 힙(시스템 메모리 풀)
### 넌페이지드 풀(Nonpaged Pool)
* 항상 물리 메모리 내에 있게 보장되는 시스템 가상 주소 영역으로 구성
* 언제라도 페이지 폴트 없이 접근 가능
  * 어떤 IRQL에서도 접근이 가능함을 의미
  * 넌페이지드 풀이 필요한 이유
    * PC/디스패치 레벨이나 더 상위의 IRQL에서는 페이지 폴트를 처리할 수 없기 때문
    * DPC/디스패치 이상의 레벨에서 접근되는 데이터/코드는 반드시 페이지 아웃되면 안됨

### 페이지드 풀(Paged Pool)
* 페이지 아웃 혹은 페이지 인이 될 수 있는 시스템 가상 주소 영역
* 어떤 프로세스 컨텍스트에서도 접근 가능

두 메모리 풀 모드 시스템 영역 주소 공간에 위치함
* 모든 프로세스 가상 주소에 매핑되어 있음
* 익스큐티브는 이런 풀로부터 할당하거나 해제할 수 있는 서비스를 제공함

시스템은 4개의 페이지드 풀(시스템 전체적인 페이지드 풀을 위해 합쳐짐)과 2개의 넌페이지드 풀로 시작함
* 이외에도 몇개 다른 풀이 있음 - 예를들어 세션풀

### 풀 크기
![5-3](https://github.com/user-attachments/assets/ea97455a-4b0b-4c6d-a95a-c30283411b61)


## 룩 어사이드 리스트(look-aside list)
* 빠른 메모리 할당 메컨니즘
* 풀과의 차이 - 고정된 크기만 할당 가능함
* 스핀락을 사용하지 않아 빠름