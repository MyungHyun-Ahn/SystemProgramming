# Story 06 프로세서 기본 동작

파이프라인과 비순차 실행을 배우기 전 기본적인 프로세서 동작을 알아보자.
* 캐시, 메모리, ALU, 레지스터 등 부품 클래스가 있을 때 어떻게 이 컴포넌트를 엮어 주어진 명령어 흐름을 처리할 것인가.

## 명령어 처리의 기본적인 다섯 단계
마이크로프로세서 == 명령어 집합 프로세서(Instruction Set Processor)
* 명령어 하나하나를 처리하므로

프로세서가 하는 일
* 명령어의 흐름을 지시대로 처리해 컴퓨터 구조적 상태에 반영하는 것

### 우리가 처리할 명령어를 특성에 따라 구분
1. ALU 연산 : 사칙 연산, 비트 논리 연산
2. 메모리 로드 : 메모리 주소의 값을 읽어 레지스터에 쓴다.
3. 메모리 스토어 : 레지스터의 내용을 메모리 주소에 쓴다.
4. 분기문 : 주어진 조건을 계산해(조건 분기문) 다음에 수행될 PC를 얻는다.

명령어를 효율적으로 처리하는 방법
* 중복되는 작업 단계가 있다.
* 최대한 공통적인 세부 단계로 나누어 구현하는 것이 합리적

### 다섯 단계로 나누어 명령어가 처리된다 가정
1. 명령어 인출(Instruction Fetch, IF)
2. 명령어 해독(Instruction Decoding, ID)
3. 피연산자 인출(Operand(s) Fetch, OF)
4. 명령어 실행(Instruction Execution, EX)
5. 결과 저장(Operand Store, OS 또는 Write Back, WB)

### 위 과정으로 프로세서 시뮬레이터를 만들면
~~~C++
while (아직 실행할 명령어가 남아 있는가?)
{
    fecth(...);
    decode(...);
    operands_fetch(...);
    execution(...);
    operand_store(...);
}
~~~
* 실제 파이프라인 프로세서, 비순차 실행 프로세서는 다섯 단계가 아닌 다른 구조
* 전체적인 의미, 명령어를 가져와 해독하고 처리하는 것은 같다.

## 명령어 인출
명령어 인출(instruction fetch, IF) 과정
* 처리할 명령어를 메모리에서 가져온다.
* 현재 처리할 명령어는 PC 혹은 IP 레지스터에 있다.
* 이 주소에 있는 데이터를 읽는 것으로 한 명령어는 본격적으로 실행된다.

거의 모든 프로세서는 명령어 캐시(Instruction Cache)를 두어 명령어 인출 레이턴시를 줄인다.
* L1 캐시에 PC의 내용이 있다면 빠르게 처리
* 없다면 L2 캐시 -> L3 캐시 -> 메인 메모리 순으로 찾는다.

명령어 인출은 명령어 캐시에서 현재 PC가 가리키는 raw byte 데이터 뭉치를 읽어 바이트 큐에 넣는다.


### 위 과정을 코드로 표현 : L1 캐시(IL1)에서 바이트 배열을 읽어 큐에 저장
~~~C++
1:      void CoreFetch::step()
2:      {
3:          /* 명령어 TLB를 읽는 작업을 수행 */
4:          core_->memory_->ITLB_.CacheProcess();
5:          /* 명령어 캐시를 읽는 작업을 수행 */
6:          core_->memory_->IL1.CacheProcess();
7:          /* byteQ를 채우라고 지시 */
8:          byteQ_.Request(pc_, &byteQ_line_mask);
9:
10:         UpdatePC(); // 다음 명령어를 가져올 곳 계산
11:
12:         /* 명령어 TLB와 캐시에 다음 내용을 요청 */
13:         core_->memory_->ITLB_.Enqueue(CACHE_READ, pc_, ITLB_Callback, ...);
14:         core_->memory_->IL1_.Enqueue(CACHE_READ, pc_, IL1_Callback, ...);
15:     }
~~~

라인 4-8
* 캐시가 주어진 일 하도록 진행
* 캐시가 데이터를 불러오면 바이트 큐에 넣는다.
* 명령어 인출 단계에서는 바이트의 흐름만 큐에 넣어주면 된다.

라인 10
* PC를 갱신하는 작업
* RISC라면 PC+=4
* CISC라면 복잡하다. - 명령어 길이 가변적, 직접 계산
* 분기문을 고려 (if, goto, switch, 함수 호출)
  * 다음 명령어가 아닌 분기문이 지정하는 위치가 된다.
  * 좀 더 복잡한 계산과 정보가 필요하다.

대다수의 분기문은 실행하지 않으면 어떻게 될지 모른다.
* Story 13, 14에서 소개

지금은 그냥 어디로 갈지 알려주는 신이 있다고 생각
* 이런 신을 보통 오라클(Oracle)이라 한다.

### 오라클을 사용하여 만든 UpdatePC() 함수
~~~C++
Mop_t *Mop = Oracle_->Execute(pc_);
if (Mop->IsBranchOrCall())
    pc_ = Oracle_.어디로_갈지_알려주세요();
else
    pc_ = pc_ + Mop->Length();
~~~
* Mop_t는 x86 CISC 명령어를 나타내는 매크로옵 자료구조

라인 13-14
* 갱신된 PC의 내용을 읽어오라고 캐시에 의뢰
* 캐시 내에서 이벤트가 발생하면 그것을 처리해야 함
* 이벤트 핸들러 콜백(Callback) 함수를 인자로 전달하여 처리

### TLB
프로그래머가 보는 메모리는 가상 주소, 코드 역시 가상 주소
* 따라서 가상 주소를 실제 물리 주소로 바꿔야 한다.

위 작업을 보통 MMU(Memory Management Unit)에서 처리
* 가장 중요한 작업, 가상 주소에서 물리 주소로 변환하는 일을 한다.

가상 주소 변환 작업
1. 가상 주소에 상위 비트 중 일부, 가상 페이지 번호(VPN)을 가져온다.
2. VPN으로 프로ㅔ스 페이지 테이블에서 대응되는 물리페이지 번호(PPN)을 찾는다.

여기서 VPN 변환이 반복되면 캐시 같은 것을 사용해 줄일 수 있다.
* 여기서 도입된 것이 바로 TLB(Translation Lookside Buffer)
* 간단히 가상 주소 변환을 돕는 캐시 장치 - 구성도 캐시와 같다.
* L1 캐시가 데이터 캐시와 명령어 캐시로 분리하듯, TLB도 명령어 TLB(ITLB)와 데이터 TLB(DTLB)로 나눈다.

### 명령어 인출의 기본적인 작동을 정리
1. 가상 주소 PC를 받아 물리 주소로 바꾼다.
2. 명령어 캐시로부터 raw byte 흐름을 바이트 큐에 저장한다.
3. 다음에 옮겨갈 PC를 구해 갱신하고, 이 내용을 읽으라고 캐시에 의뢰한다.

## 명령어 해독
명령어 해독(instruction decoding, ID)
* 가져온 명령어가 어떤 일을 하는지 열어보는 것

한마디로 파싱(Parsing)
* 옵코드(opcode), 피연산자(operand), 계산 결과가 저장될 목적지, 주소 모드(addressing mode), 간단한 분기문의 분기 목적지를 읽는다.
* 컴파일러처럼 복잡한 문법을 푸는 것이 아닌 기계적인 규칙으로 분석한다.

RISC라면 이것이 훨씬 편리
* 명령어 길이 일정, 옵코드 위치 동일
* 하드웨어의 단순함, 고속화로 이어진다.

x86 CISC는 복잡하다.
* 일부만 해독하여 해독 시간을 단축하기도 함
* 최신 프로세서에서는 CISC 명령어를 마이크로 명령어로 분해
* 프로세서 고속화에 훨씬 유리하기 때문
* 디코더가 uop으로의 변환을 담당

### 메모리 주소를 인자로 받는 연산
1. 메모리를 읽고
2. 연산
3. 메모리에 쓴다.

위 3단계를 한 사이클에 구현하는 것은 상당히 비효율적
* 더 빨리 마칠 수 있는 연산들의 시간을 낭비

따라서 3단계의 uop으로 나눠 각각 한 사이클에 처리되게 한다.
* 간단한 명령은 빨리 완료되어 명령어 처리 시간과 대역폭을 늘릴 수 있다.

명령어 인출과 명령어 해독은 front end라 하기도 한다.
* 실제 처리할 명령의 흐름을 만들기 때문
* 고성능 프로세서는 front end의 성능이 일차적인 조건이다.
  * 분기문, CISC 명령어 처리 등의 어려움이 있다.


### 명령어 해독 과정을 정리
* 인출한 바이트의 흐름이 어떤 일을 하는지 분석
* x86의 경우 대응되는 uop로 바꾼다.


## 피연산자 인출
피연산자는 3가지로 번역될 수 있다.
1. 상수
2. 레지스터
3. 메모리 주소

### 상수
즉시 읽을 수 있는 값(immediate)
* 명령어에 인코딩 되어 있다.

### 레지스터
레지스터 형은 레지스터 파일에서 읽어오면 된다.
* 그러나 최신 프로세서에서 고성능 레지스터 설계는 어렵다.

레지스터 파일 설계의 대표적인 두 가지 문제점
1. 레지스터 파일에 한 사이클만에 원하는 데이터를 읽고 쓸 수 있는가?
2. 동시에 몇 개의 읽기와 쓰기가 지원되는가?

이런 어려운 구현 문제가 있지만
* 그냥 레지스터가 모여있는 배열에 입출력이 지원되는 장치로 생각하면 된다.

### 메모리 주소
메모리 주소를 가리킬 때 해야할 일
~~~asm
st      [sp+4], r1
~~~
1. 가져올 메모리 주소를 구한다. - 유효 주소
2. 데이터를 읽는다.
3. 목적지 레지스터에 저장한다. - 피연산자 인출 단계에서 할일은 아님

유효 주소(effective address)를 계산하려면
* 베이스 레지스터를 읽고, 덧셈, 뺄셈, 쉬프트 연산
* 대다수 프로세서는 주소 계산에 특화된 주소 생성 장치 AGU(Address Generation Unit)을 가진다.

메모리 스토어 명령
1. 메모리에 쓸 소스 레지스터를 읽는다. - 피연산자 인출 단계
2. 유효 주소를 구한다.
3. 메모리 접근

분기문은 피연산자로 보통 레지스터나 상수를 읽는다.


## 명령어 실행 단계

명령어 종류에 따라 작업 내용은 차이가 있다.
1. 산술 연산 : 계산만 수행하면 된다.
2. 조건 분기문 : ISA마다 다르다.
   * x86 : test와 cmp 제공
   * 일반 산술 연산처럼 처리되고, 결과를 플래그(flag) 레지스터가 받는다.
   * 플래그 레지스터를 기반으로 분기 결정
3. 메모리 로드/스토어
   * 책에서 나눈 단계에서는 아무것도 하지 않는다.
   * 실제로는 특정 장치에서 처리된다.


자원 한정 문제 - 연산 장치가 한정적
* 준비된 명령어는 필요한 장치를 사용할 수 있을 때까지 대기한다.

## 연산 결과 저장
지금까지 구한 결과를 레지스터에 쓴다.(Operand Storing, OS 또는 Write Back, WB)

ALU 연산, 메모리 로드
* 명령어에 지시된 목적지 레지스터에 쓴다.

메모리 스토어
* 유효 주소를 계산하고 결과를 메모리 계층으로 전송

분기문
* 직접적으로 저장할 레지스터를 가지진 않음
* 그런데 분기문의 결과로 PC 값이 바뀐다. - 여기서 PC 값을 갱신해야 하는가?
* 현대 프로세서는 분기문 실행 전 서둘러 다음 PC의 내용을 예측해야 한다.

## 예외처리
명령어를 처리하는 프로세서도 예외 상황을 적절히 처리해야 한다.

### 프로세서가 구분하는 예외
1. 예외(exception) : 프로그램 실행 도중 동기적으로 발생
   * 트랩(trap) : 다음 명령어부터 실행
   * 폴트(fault) : 문제를 일으킨 명령어부터 다시 실행
     * 주로 가상 주소가 아직 처리되지 않은 상황에 발생
   * 중단(abort) : 심각한 하드웨어 문제 - 프로세스 종료
2. 인터럽트(Interupt) : 명령어 흐름처리와 관계없는 비동기적인 사건
   * 하드웨어 인터럽트 : ex) 키보드 인터럽트
        1. 명령어 흐름을 멈추고
        2. 인터럽트를 처리하는 함수 루틴(인터럽트 서비스 루틴 혹은 인터럽트 벡터)으로 문맥 전환
        3. 처리가 끝나면 원래 프로그램으로 돌아가 실행 재개
   * 소프트웨어 인터럽트 : 명령어로 인해 발생하는 인터럽트