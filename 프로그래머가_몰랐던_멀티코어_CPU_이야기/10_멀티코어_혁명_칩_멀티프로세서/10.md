# Story 10 멀티코어 혁명 : 칩 멀티프로세서
## 멀티코어 시대
30년 동안 컴퓨터의 속도는 눈부시게 발전
* 무어의 법칙이 말하는 반도체 제조 기술의 발전과 파이프라인이나 비순차 실행 같은 컴퓨터 마이크로아키텍처의 개선이 가능하게 했다.

1978년 Nehalem -> 2008년 Core i7
* 트랜지스터 개수 : 25206배
* 클록 속도 : 586배

소프트웨어가 발전할 수 있었던 것은 결국 컴퓨터의 발전이 있었기 때문
* 뒤집어 보면 소프트웨어의 발전이 하드웨어 발전에 큰 동기 부여
* 소프트웨어가 무거워짐 -> 더 빠른 컴퓨터 요구

따라서 다음과 같은 순환 구조로 컴퓨터 산업 발전

![10-01](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/7e910d0f-9c3e-470e-b40b-2932c6a34207)

그런데 이러한 것은 모두 싱글코어 프로세서 시절 이야기
* 멀티코어 시대에는 이런 단순한 모델이 통하지 않는다.
* 예전에는 2년마다 싱글 스레드 성능이 크게 발전 -> 프로그램을 손보지 않아도 혜택
* 2004년 이후 이런 추세가 느려지고 있다.
* 프로그램을 병렬화하지 않으면 병렬 컴퓨터의 효과를 누릴 수 없다.
* C++ 전문가 허브 서터 "The free lunch is over"
  * 프로그램이 과거처럼 빨라진 컴퓨터의 성능을 활용하려면 적극적으로 멀티코어를 고려해 병렬 프로그래밍을 해야 한다.

무어의 법칙
* 18개월 혹은 24개월마다 저렴한 비용에 집적될 수 있는 트랜지스터의 개수가 두 배씩 증가한다는 법칙
* 지금까지도 유효한 법칙이다.
* 과거에는 실제로 명령어 파이프라인을 개선하고 캐시 양을 늘리는 것으로 늘어난 트랜지스터를 사용
* 2004년 기준으로 더 이상 싱글스레드 성능 향상에 트랜지스터 투입이 어려워짐
  * 에너지 효율이라는 장벽
* 그래서 프로세서 설계자들은 멀티코어로

칩 멀티프로세서(Chip Multiprocessor, CMP)
* 프로세서의 물리 코어 자체를 복제해서 하나의 칩으로 만들어냄

인텔의 x86 CPU 발전 속도
* 트랜지스터 수는 계속 늘어남
* 클록 속도와 파워는 정체
* 싱글프로세서는 2004년부터 정체

## 싱글코어의 한계 : 에너지 장벽
싱글스레드의 성능이 과거처럼 늘기 어려운 이유
* 클록속도와 ILP(명령어 수준 병렬성) 제약
* 이젠 더 이상 클록을 중요하게 생각하지 않는다.
  * 과거에는 클록 속도가 결국 프로세서의 성능을 대변했다.
  * AMD가 최초로 1GHz를 구현하자 
  * 인텔은 온갖 방법을 동원해 NetBurst 마이크로 아키텍처를 만들어 펜티엄 4로 맞섬
  * 클록 수치는 높았으나 실제 성능은 그만큼 차이나지 않았다.

NetBurst 구조의 최고 목표는 클록
* 그 당시에는 클록은 높은 성능을 의미하고, 가장 좋은 마케팅 수단
* 그래서 클록에 대한 집착이 강했고 프로세서 설계에 반영됨

클록을 높이는 방법 두 가지
* 반도체 제조 공정 기술 자체가 발달하는 법
* 마이크로아키텍처 수준에서 하는 일
  * 파이프라인 단계를 더 잘게 나누어야 한다.
  * NetBurst의 기본 전략은 매우 깊은 파이프라인을 이용한 고클록의 구현
  * NetBurst 구조는 20단계부터 시작 -> Prescott 구조에서는 31단계

NetBurst 구조 같은 프로세서에 파이프라인 깊이를 점차 늘렸을 때의 관계

![10-02](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/0c668d08-8887-462d-8049-22ff844574f1)
* 단계가 깊어질수록 클록속도는 계속 증가
* IPC는 줄어든다
* 그런데 명령어 하나를 완료하는데 필요한 작업 자체는 줄지 않는다.
  * 한 명령어를 마치는 데 더 많은 클록이 필요 - IPC가 감소하는 이유
* 성능은 클록이 두 배가 되는 시점 약 1.5배 증가함
  * 결국 클록이 두 배가 되어도 성능은 약 1.5배 증가
  * 이 때 파이프라인은 50단계

여기서 생각하지 못한 것
* 전력 소비와 발열에 관한 에너지 효율
* 1980년대에는 무소음 무발열 그자체 - 발열과 소비 전력을 신경쓸 필요가 전혀 없었다.
* 최근 데이터 센터에서 가장 큰 문제 중 하나가 소비 전력과 온도 조절 문제
  * 펜티엄 4 프레스캇 프로세서는 100와트에 가까운 전력 - 매우 뜨거운 백열전구 하나에 맞먹는 값
  * 엄청난 히트 싱크(heat sink)와 쿨러가 필요
  * 클록 속도를 4GHz에 가깝게 늘리니 에너지 장벽에 부딪힘
* 그래서 결국 인텔은 NetBurst 구조가 아닌 Core i7 부터는 예전의 P6 구조로 돌아옴
  * 클록 속도는 3GHz 정도(펜티엄 4와 비슷), 전력은 훨씬 적게 들며, 싱글스레드 성능도 더 높다.


클록 속도를 4GHz, 6GHz처럼 올리기 어려운 이유
* 발열도 있지만 비순차 알고리즘 자체에도 있다.
* 스케줄링 단계가 병목지점이 되기 때문에
  * 이 단계는 더 세부 파이프라인 단계로 나누기 어렵다.

## 싱글코어의 한계 : ILP의 한계

비순차 슈퍼스칼라 방식의 프로세서 근본 원리는 ILP
* ILP를 찾는 것에도 제약이 있었다.
* 명령어 윈도라는 개념
  * 프로그램의 영역을 나눠 제한적으로 ILP를 찾는다는 뜻
  * 비순차 프로세서는 백여 개의 명령어 사이에서 ILP를 찾을 수 밖에 없다.
* 이론적으로는 상당한 잠재력이 있지만, 지금의 기술로는 찾을 수 있는 값이 그리 높지 않다.


## 병렬 컴퓨터의 개념

멀티코어
* 병렬 컴퓨터 구조의 세로운 제조 형태일 뿐
  * 컴퓨터가 탄생한 초기부터 그 개념이 있었다. - 슈퍼컴퓨터
* 1990년 반도체 기술의 발달로 부동소수점 처리기, 캐시 마이크로프로세서에 집적
  * 이로인해 파이프라인, 비순차 실행 같은 것이 활발히 연구
* 그러다 싱글코어가 과거만큼 발전하지 못하자 병렬 구조로 관심이 옮겨감
* 과거에는 독립적으로 있었던 프로세서들이 반도체 기술이 발전하자 칩 하나에 제조될 수 있다.
  * 멀티코어 프로세서의 탄생

병렬 컴퓨터(parallel computer)의 정의
1. 계산 장치(processing element, PE)를 모아놓은 것
2. 계산 장치가 서로 데이터를 주고받고
3. 협력하여 큰 문제를 빠르게 푸는 것

병렬 컴퓨터의 문제
1. 어떠한 계산 장치를 모을 것인가?
   * 데스크톱의 듀얼/쿼드 코어 - 적지만 매우 강력한 코어를 모은 것
   * 그래픽 계산 장치 GPU - 작지만 그 수가 매우 많은 병렬 구조
   * 이 둘을 합쳐 CPU와 GPU를 합쳐 멀티코어를 만들 수도 있다.
2. 계산 장치 간의 통신 문제
   * 병렬 컴퓨터 내의 프로세서와 계산 장치가 어떻게 서로 데이터를 주고 받느냐의 문제
   * 공유 메모리 구조와 분산 메모리 구조
   * 물리적인 차원에서는 네트워크 문제와 같다.
   * 레이턴시가 빠르고 대역폭이 높은 인터커넥션(interconnection) 장치를 만드는 방법
3. 계산 장치 간의 협력 문제
   * 어떤 방식으로 데이터를 가공할지 그 방법론을 결정
   * 멀티스레드 사이의 동기화 문제

싱글코어가 발전할 수 있었던 것은 ILP


병렬 컴퓨터는 TLP, 스레드 수준 병렬성을 활용

이것을 더 세분화
* 루프 수준 병렬성 - 루프 전이 의존성으로 설명 가능
* 태스크 수준 병렬성
* 프로그램 수준 병렬성

병렬화 가능한 루프와 불가능한 루프
~~~C++
    // 병렬화 가능 - 루프 수준 병렬성이 있다.
1:  for (int i = 0; i < N; ++i)
2:      A[i] = A[i] + B[i];
3:  // 병렬화 불가능 - RAW 의존성에 의해
4:  for (int i = 1; i < N; ++i)
5:      C[i] = C[i - 1] + D[i];
~~~

### 루프 수준 병렬성
과학 및 수학 응용프로그램에서 흔히 찾을 수 있다.
* 이들 프로그램의 수행 시간은 대부분 몇몇 루프에서 소비
* 이런 루프를 집중 공략하여 병렬화 가능성을 찾는 것이 현명
* 많은 수의 뮤텍스로 동기화를 하다 보면 병렬화 이득이 감소할 수도 있다.

### 태스크 수준 병렬성
임의의 코드 영역이 동시에 수행 가능함을 가리킨다.
* 위 소스에서 첫 번째 두 번째 루프는 각각 아무런 연관이 없어 동시 실행 가능하다.
* 이것이 태스크 수준 병렬성

### 프로그램 수준 병렬성
직관적으로 독립적인 프로그램을 동시에 돌리는 것
* C/C++의 컴파일 과정 - 여러 파일을 독립적으로 여러 코어에서 컴파일
* 링킹 과정은 동기화가 필요하다.

## 병렬 컴퓨터 구조

플린의 구분 법으로 나눈 4가지 구조에대해 설명
* 플린(Flynn)은 명령어가 하나이냐 여러 개이냐, 이 명령이 다루는 데이터 흐름이 하나이냐 여러 개냐에 따라 컴퓨터 모델을 구분

플린의 4가지 구조
1. SISD(Single Instruction Single Data)
   * 지금까지 본 컴퓨터
   * 스칼라, 슈퍼스칼라 프로세서가 여기에 해당
   * ALU는 한 번에 하나의 명령과 하나의 데이터만 취해 계산
2. SIMD(Single Instruction Multiple Data)
   * 하나의 명령이 여러 데이터를 취하는 것 - 벡터 연산
   * Story 11에서 다룬다.
3. MISD(Multiple Instruction Single Data)
    * 자료는 하나인데 명령이 여러개
    * 시스톨릭 어레이(systolic array) 구조라고 부른다.
    * 이 책에서는 다루지 않는다.
4. MIMD(Multiple Instruction Multiple Data)
   * 여러 명령어가 여러 데이터를 처리하는 것
   * 일반적인 멀티프로세서 구조
   * 명령어와 데이터는 모두 메모리에 있다.
     * 메모리를 어떻게 여러 프로세서가 보느냐에 따라 구조가 나뉜다.
     * 공유 메모리 구조, 분산 메모리 구조

## 공유 메모리 구조
공유 메모리(Shared Memory) 구조 멀티프로세서
* 우리가 지금 쓰는 멀티코어 컴퓨터
* 프로세서와 코어가 여러 개 있더라도 메모리 주소 공간이 모두 공유된다.
* 다른 프로세서가 쓰는 데이터 공간을 내가 볼 수 있다는 것
* 일반적인 멀티스레드 프로그래밍 방법론이 여기에 해당

공유 메모리 구조는 구성 방식에 따라 나뉜다.
* 칩 멀티프로세서
* 대칭형 멀티 프로세서
* 분산 공유 메모리

### 칩 멀티프로세서(CMP)
칩 멀티프로세서란?
* 멀티코어를 가리킨다.
* 여러 코어가 올라오기 때문에 메모리를 공유하는 것이 합당
* 같은 칩에 있기 떄문에 캐시를 공유할 수 있다는 장점

CMP 구조

![10-03](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/6baf64e7-7b90-4bd9-b64e-0adfeee2933b)
* 프로세서가 메모리와 연결
* 모든 코어는 메모리를 공유

### 대칭형 멀티프로세서(SMP)
대칭형 멀티프로세서란?
* 서버용 메인보드를 보면 보통 프로세서를 두 개, 네 개 장착
* 이때 일반적으로 같은 종류의 프로세서를 꼽는다.
* 이런 멀티프로세서 환경이 SMP

SMP 구조

![10-04](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/cfc07ded-11d5-4345-960a-2cdc4b84a2af)

* 과거에는 하나의 프로세서가 하나의 코어였기 때문에 SMP 구조가 일반적
* 개념적으로 SMP는 공유 캐시를 제외하면 CMP와 완전히 같다.
* 최적화를 고려하지 않는다면 프로그래밍 방법론도 똑같다.
* 그림에서 여러 프로세서가 네트워크 장치에 묶여 있고 이것이 메모리와 연결
  * 네트워크는 여러가지가 될 수 있다.
  * 펜티엄 기반의 프로세서는 이것을 프런트 사이드 버스라는 방식이 담당
  * 이제는 AMD와 인텔 모두 HTT(Hyper Transport Technology)와 QPI(Quick Path Interconnect)로 바꾸었다.
  * 그런데 이 방법은 확장성 문제가 있다.
  * 프로세서가 매우 많아진다면 병목 현상이 발생
  * 여기서 나온 것이 바로 공유 메모리를 분산배치한 NUMA(Non-Uniform Memory Access) 구조
  * 이것의 반대 구조 UMA(Uniform Memory Access)

NUMA 공유 메모리 구조

![10-05](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/bddacc96-17a4-4b53-9253-222bba3f688d)
* 시스템 전체적으로는 메모리 주소를 공유하지만, 물리 메모리 위치는 떨어져 있을 수 있다.
* NUMA의 장점은 바로 확장성
* 메모리 접근 속도가 프로세서와 메모리의 위치에 따라 결정 "비균일" 메모리 접근 속도가 만들어짐
* 따라서 소프트웨어나 운영체제는 이것을 인지해 최적화해야 한다.


## 분산 메모리 구조
다른 말로는 클러스터(cluster) 또는 그리드(grid)라는 표현을 쓴다.
* 독립적인 컴퓨터를 고속의 네트워크로 연결한 것
* 공유 메모리 구조와는 달리 다른 컴퓨터의 메모리를 보려면 메시지 교환이 필요하다.
* 슈퍼컴퓨터가 이런 구조를 따른다.

분산 메모리 시스템

![10-06](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/94d7072e-2476-42b1-b380-d4f5633e9e34)
* 독립된 컴퓨터의 묶음이라 생각하면 쉽다.
* 상대방의 데이터에 접근하려면 반드시 네트워크 메시지를 주고 받아야 하므로 느리다.

## 멀티코어의 구성 방식
호모지니어스(homogeneous) 멀티코어
* 듀얼코어, 쿼드코어 프로세서는 각 코어가 완전히 같다.
* 구조 뿐만 아니라 클록 속도와 캐시 크기도 같다.
* 이러한 멀티코어를 호모지니어스 멀티코어라 한다.

헤테로지니어스(heterogeneous) 멀티코어
* 각 코어가 구조적으로 다르거나, 성능 차이가 있는 코어를 하나의 칩에 만드는 것
* 소니의 플레이스테이션 3에 탑재된 Cell BE 같은 프로세서는
  * 코드 수행을 위한 코어와 보조 연산 코어로 이루어 진다.
  * 각각의 ISA도 다르다.
* 비대칭(asymmetric) 멀티코어
  * ISA는 같지만 클록이나 캐시 크기를 다르게 해 성능차이를 두는 방법
  * 직렬 코드는 빠른 코어가 담당
  * 병렬 코드는 작지만 수가 많은 멀티코어에 맡기는 방식

## 멀티코어의 한계 : 메모리 장벽과 병렬 프로그래밍
정말 멀티코어가 만능일까?
* 4개, 8개, ... , 128개까지 하나의 칩에 집적할 수 있을까?
* 물리적으로는 가능해도 그것이 진짜 성능이 좋을지는 모른다.
* 현재 기술로는 이렇게 많은 멀티코어는 별 효용이 없다고 한다.
* 메모리 장벽(memory wall) 때문

멀티코어 환경에서는 메모리 대역폭이 아주 중요하다.
* 한 코어가 사이클마다 1바이트 데이터를 요청하면 2GHz 프로세서에서는 초당 2GB의 데이터가 필요
* 만약 100코어라면 100GB/s의 대역폭이 필요하다. - 1TB 하드디스크를 10초 내에 읽어야 하는 엄청난 대역폭
* 듀얼 채널 - DRAM 메모리를 꼽을 때 쌍으로 꼽아야 대역폭이 높게 나온다는 것
* 트리플 채널의 대역폭은 최대 32GB/s
  * 이 정도 대역폭은 GPU에서 턱없이 부족 - GPU 성능은 메모리 대역폭에 좌우될 때가 많다.

현재 메모리 기술로는 코어 개수가 많아져도 성능 향상을 기대할 수 없다.

![10-07](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/0fd76a4f-def5-450c-b7c6-036d85d87312)
* 최대 64코어 시스템에서 가상으로 돌려보았을 때의 성능 추정치
* 아래 그래프는 지금 메모리 기술을 가정하고 얻은 결과 값
  * 코어를 늘렸는데 성능이 크게 하락
  * 대역폭의 한계로 오히려 해악만 끼친 것
* 새로운 기술이 도입된다면 위 그래프처럼 성능은 하락하지 않고 증가
  * 3-D 스태킹(stacking) : 칩을 3차원으로 쌓아 올리는 것
* 이상적으로는 DRAM을 한 칩에 넣어 높은 대역폭을 꾀함 - 아직 연구 단계

또 하나 근본적인 문제 - 암달의 법칙
* 프로그램 자체가 직렬로 처리되어야 하는 부분이 많다면 멀티코어가 아무리 많아도 무용지물
 
메모리 장벽 문제는 새로운 것이 아님
* 싱글코어에서도 메모리와 CPU 속도의 차이가 병목 지점
* 멀티코어는 이 문제를 더 가중시키는 것

더욱 큰 문제 병렬 프로그래밍
* 프로그래머가 효율적으로 병렬 프로그래밍을 할 수 없다면 멀티코어는 빛을 발할 수 없다.
* 멀티코어의 미래는 소프트웨어 개발자의 손에 달렸다.

## 여전히 중요한 싱글코어 성능 
프로세서 세대가 바뀌며 10% 정도의 성능 향상은 기대할 수 있다.
* 마이크로아키텍처를 꾸준히 발전시키기 때문에

병렬화되지 않은 프로그램이라도 혜택은 누릴 수 있어야 한다.
* 아무리 병렬화해도 직렬로 실행되어야 하는 부분은 무조건 있다.
* 이 부분을 빠르게할 방법은 싱글코어 성능 향상 말고는 없다.