# Story 02 프로세서의 언어 : 명령어 집합 구조
## 프로그래머가 보는 프로세서
프로그램을 중단점 걸어서 실행이 멈췄을 때 보이는 것들
* 레지스터 상태
* 호출 스택
* 메모리
* 디스 어셈블리

여기서 이제 한 명령 씩 밟아나가면 여러 상태들이 변화
* 이런 외부에서 보이는 현재 프로세서 상태를 컴퓨터 구조적 상태(Architectural Status)라고 함
* 구체적으로 말하면 현재 프로세서가 수행 중인 프로세스의 상태를 지닌 각종 레지스터의 값을 가리킨다.

프로세서는 이런 구조적 상태를 하나 씩 가진다.
* 멀티코어 프로세서는 코어 개수만큼 동시에 가진다.
* 정확히는 하드웨어 스레드 개수 만큼

프로그래머가 만든 코드가 순차적으로 실행되는 것처럼 보이지만
* 실제로 현대 프로세서에서는 순서가 지켜지지 않을 수 있다.
* 이런 복잡함은 프로그래머에게 노출시키지 않는다.
* 아무리 복잡해도 프로세서는 프로그래머와 약속된 컴퓨터 구조적 상태를 정확히 보여준다.

## 프로세서의 언어 : 명령어 집합 구조
컴파일러가 없다면 기계어, 어셈블리어로 컴퓨터에 작업을 지시해야 한다.

기계어가 바로 명령어 집합 구조(Insturction Set Architecture) ISA로 표현한다.
* 프로세서를 설계할 때 첫 번째로 해야하는 것 - ISA를 정의하는 것

인텔과 AMD는 x86이라는 그들만의 언어를 사용
* 둘 사이 호환
* ISA가 다르다면 새로 컴파일하거나 에뮬레이션을 거쳐야 한다.
* JVM이나 .NET 프레임워크는 이런 문제를 해결하려함

인스트럭션(Instruction) : 프로세서가 이해하는 명령어 하나하나 -> 명령어
* C++, Java 등으로 작성한 언어는 컴파일러나 인터프리터에 의해 명령어로 변환

명령어는 성격에 따라 여러 종류로 나눌 수 있다.
1. 기본적인 사칙연산과 논리연산
2. 메모리에 쓰고(store) 읽는(load) 명령
3. 프로그램의 실행 흐름을 제어하는 분기 및 호출 명령(if/goto, call, return)
4. 그외... 시스템 내부를 제어하거나 상태를 관찰하는 명령

하나의 명령어에는 명령어의 종류 피연산자 등의 내용 기술
* 사람의 언어의 주어, 목적어, 동사와 비슷

'A+=7'을 x86 어셈블리로 표현
~~~asm
add     dword ptr [A], 0x07
0x83    0x45  0xF8     0x07
~~~
* 0x83, 0x45, 0xF8 : 실제로 프로세서에 전달될 때 표현되는 값
* 이런 값으로 바꾸는 것 인코딩, 반대는 디코딩

'dword ptr [A]'
* A는 변수 A의 주소값
* dword ptr : 주소값에 있는 데이터를 4바이트 정수형으로 해석하라
* (x86에서 double word는 4바이트)

즉, 프로세서는 ptrA가 A의 주소(&A)를 담고 있을 때
* "*ptrA = *ptrA + 7"로 이해한다.

위의 명령에 세부적인 동작을 지시할 수 있다.

원자성 부여
~~~asm
LOCK add dowrd ptr [A], 0x07
0xF0 0x83 0x45 0xF8     0x07
~~~

ISA는 명령어 종류, 피연산자 타입, 레지스터 개수, 인코딩 방법 등 여러가지를 정의한다.\
그 외에 실제로 프로그램이 실행되려면 ISA 위에 ABI(Application Binary Interface)라는 운영체제 사이의 약속도 필요하다.
* 대표적으로 함수 호출 규약(Calling Convention)이나 바이너리 포멧에 대한 규약이 있다.

## RISC와 CISC로 알아보는 명령어 집합 구조
프로세서 언어인 ISA를 대표적인 두 축 RISC와 CISC를 중심으로 이야기해보자.

프로세서가 처음 등장했을 때, 컴파일러의 도움이 크지 못했다.
* 따라서 프로세서 설계자는 프로그래밍 언어와 1:1 대응이 될 만큼 많은 명령어를 제공하려 노력
    * ex) x87 산술 보조 프로세서의 경우 sin과 exp와 같은 초월 함수도 제공
* 당시 메모리가 비싸기 때문에 조금이라도 명령어 크기를 줄여야 했다.

따라서 최초의 ISA는 복잡한 형태의 CISC(Complex Instruction Set Computer)의 형태
* 대표적으로는 x86이 있다.

x86 ISA
* 1986년에 출시된 인텔 80386의 명령어 집합 구조
* 정확한 명칭 IA-32(Intel Architecture 32 bit) - 16 bit도 호환
* AMD가 제안한 x86-64, AMD64 (x86의 64bit 확장)도 지금은 사실상 표준

CISC의 주요 특징
* 명령어의 길이가 가변적
* 여러 복잡한 형태의 주소 모드 지원
* 범용 레지스터가 적음
  * x86 32bit - EAX, EBX ... 8개
  * x86-64 : 16개

## RISC의 등장
IBM의 연구자들은 실제 사용되는 명령어 종류가 많지 않다는 것을 파악
* 많은 명령어와 주소 모드 중 일부만 자주 사용
* CISC는 너무 과도하게 설계됨

실제로 98%의 프로그램이 13비트면 충분히 상수를 표현 가능했다.
* 분기문의 목적지 또한 상대 위치이므로 크지 않다.

컴퓨터 구조 설계의 첫 번째 원칙
* "Make Common Case Fast" (자주 있는 경우를 빠르게 해라)

결국, 자주 쓰이지 않는 명령어 종류를 줄이고, 상수 표현에서 32bit 모두 사용할 필요가 없다는 결론
* 프로세서 구조의 단순함과 고속화를 위해 명령어를 4바이트 정도로 제한해도 문제가 없다.

RISC 철학이 탄생한 것은 70~80년 대
* 간단한 명령어 -> 회로가 단순 -> 비용이 저렴

대신 컴파일러가 일을 더하게 된다.

RISC(Reduced Instruction Set Computer)
* 명령어 크기 고정
* 명령어 개수 대폭 감소
* 스마트폰에 많이 쓰이는 ARM이나 MIPS가 RISC

## 대표적인 RISC, MIPS 구조
MIPS는 모든 명령어 길이가 32 bit로 고정, 매우 규칙적인 포멧

모든 명령어는 R(Register), I(Immediate), J(Jump) 타입 중 하나로 표현

|              | 31~26  | 25~21  | 20~16  | 15~11       | 10~6  | 5~0      |
|--------------|--------|--------|--------|-------------|-------|----------|
| R(Register)  | opcode | source | target | destination | shift | function |
| I(Immediate) | opcode | source | target | 16비트      | 상수  |          |
| J(Jump)      | opcode | 26비트 | 분기    | 목적지      |       |          |
* opcode : 명령어
  * 항상 최상위 6bit에 존재한다.
  * 임의의 명령어를 분석할 때 간단하게 처리 가능
  * x64의 경우 가변적이기 때문에 힘들다. -> 하드웨어의 복잡

RISC의 단순함의 단점
* CISC가 간단히 처리할 수 있는 것도 여러 단계로 나누어 처리해야 한다.

ex) 큰 상수 읽기(4byte) : 16bit, 16bit 두 번에 나누어 읽어야 한다.
* 혹은 프로그램 어딘가에 쓰고(리터럴) 주소에 접근하여 읽기

## CISC와 RISC의 설계 차이
CISC는 메모리가 귀한 옛날에 설계
* 최대한 작은 공간에 많은 의미를 함축
* 1바이트로도 명령어 표현 가능 (최고 17바이트)

대표적으로 push/pop 같은 명령어
* 프로그램은 함수 호출을 관리하기 위한 정보(activation frames)나 지역 변수를 스택이라는 메모리에 쓰고 읽으며 계산
* x86은 이것을 간단하게 처리 가능(push/pop 명령어 하나로)
* RISC는 함축적인 명령이 없고 명시적으로 처리
  * 직접 sp를 조작하고, 데이터 이동 명령을 지시

주소 모드(addressing mode)의 단순함과 복잡함도 두 명령어 구조의 뚜렷한 특징

주소 모드란?
* 명령어 속에 포함된 피연산자를 어떻게 해석할지를 결정하는 것

가장 큰 차이
* CISC : 피연산자로 메모리 주소 가능
* RISC : 피연산자로 무조건 레지스터

"A+=7"의 RISC 표현
~~~asm
load    r1, dword ptr [A]
add     r1, r1, 0x07
store   dword ptr [A], r1
~~~

CISC로도 충분히 위와 같은 형식으로 코드를 만들 수 있다.
* 단, CISC로 메모리 주소에 접근한다 하더라도 내부적으로는 RISC 처럼 동작

주소 모드는 배열 접근 방식도 정의한다.
* 배열 변수에 접근 : '기준점 + 변위' 와 같은 주소 계산 필요

ex) A[10] -> A의 주소에 변위 10 * sizeof(int)를 더한 값에 접근
* RISC는 '기준점 + 변위'와 같은 단순한 메모리 형태만 지원
* x86 CISC에서는 '기준점+변위+인덱스*스케일'과 같은 복잡한 형태를 지원
  * 즉, 컴파일러는 더 짧은 명령어 생성 가능


CISC와 RISC는 설계 철학에 차이가 있다.

CISC
* CISC는 컴퓨터 프로그램의 복잡함을 하드웨어가 맡아 처리
* 복잡한 수학 함수 지원, 메모리 주소, 피연산자

RISC
* RISC는 하드웨어의 복잡함을 컴파일러로 넘겼다.
* 컴파일러가 번역해주기 때문에 ISA를 다양하게 제공할 수 없다.
* 하드웨어의 복잡함을 덜어 RISC는 성능 향상에 기여할 수 있다.
* 범용 레지스터의 수가 CISC보다 많다. - 32개 이상

결국, 프로그램을 빠르게 실행한다는 목적은 같다.
* 하드웨어와 소프트웨어가 어떻게 일을 분담하고 어떻게 소통하는가를 서로 다르게 접근한다.


## 간단한 코드로 보는 RISC와 CISC의 차이

구조체 배열을 정의하고 한 요소에 접근하는 예제
~~~C++
/* data와 index는 모두 지역 변수. index는 32bit int 형 */
struct Vector
{
    int x;
    int y;
    int z;
} data[10];

data[index].y = 0x87654321;
~~~

ASM(RISC) 어셈블리
~~~asm
ldr     r1, [sp, #4]        ; r1 = index
mov     r3, #0xC            ; r3 = sizeof(Vector)
mul     r2, r1, r3          ; r2 = index * sizeof(Vector)
add     r3, sp, #8          ; r3 = data
add     r3, r3, r2          ; r3 = &data[index]
add     r2, r3, #4          ; r2 = &(data[index].y)
ldr     r3, [pc, #8]        ; r3 = 0x87654321
str     r3, [r2]            ; *(r2) = r3
~~~

* r1, r2, r3 : 레지스터를 뜻함
* ldr : 메모리에 있는 값을 레지스터에 load
* str : 레지스터에 있는 값을 메모리에 store
* mov(이동), mul(곱셈), add(덧셈)

코드에서 궁극적으로 계산해야할 것은
* data[index].y 의 주소 : data + index * sizeof(Vector) + 4

RISC는 코드 한 줄이 복잡하게 번역이 되었음을 알 수 있다.
* "자주 쓰는 적은 수의 명령어를 이용하자"라는 철학
* 코드를 수행하는 데 필요한 공간 : 명령어 8개(32바이트) + 4바이트 데이터 하나 = 총 36바이트

x86-64(CISC) 어셈블리
~~~asm
movsxd      rax, dword ptr [rsp+24h]
imul        rax, rax, 0Ch
mov         dword ptr [rsp+rax+34h], 87654321h
~~~

* 코드는 단 세 덩이
* 필요한 명령의 공간 = 17바이트
* movsxd : mov의 확장, 부호 확장을 의미
  * index는 int - 32비트인데 rax 레지스터는 64비트 레지스터를 사용하므로 부호를 유지하고 비트를 확장(sign extension)

x86의 함축성은 프로그램의 크기를 일반적으로 줄일 수 있어 메모리가 비싸던 시절에는 매력적이었다.
* 반면, 작은 폭에 여러 뜻을 함축하고 있어 해독이 복잡하다.


## 아직도 RISC vs CISC

두 개는 장단점이 명확하다.
* RISC는 레지스터 개수가 더 많다거나 하드웨어 구현이 간단해질 수 있으므로 고성능 프로세서의 기본인 파이프라인 기술 적용이 쉽다.

그러나 이제는 이런 단순 비교가 성립하지 않는다.
* 펜티엄 프로부터 x86 프로세서는 CISC 명령어를 단순한 RISC 처럼 생긴 마이크로 명령어, micro-operator로 쪼개서 처리한다.
* x86 코드가 함축적으로 보이지만, 내부적으로는 여러 개로 나뉜다.
* 결국, 내부적으로 CISC는 RISC 처럼 동작한다.

x86의 범용 레지스터 개수는 8개, x86-64는 16개
* 그러나 실제 물지적인 레지스터는 100개 이상이다.
* 레지스터 리네이밍이라는 테크닉으로 활용한다.

결론, RISC와 CISC의 구분은 무의미해졌다.

그러나 x86 프로세서에서 CISC의 잔재를 찾아볼 수 있다.
* 하드웨어 내부에는 많은 물리 레지스터가 있지만
  * 컴파일러는 여전히 8개, 16개만 있는 것을 가정하고 코드를 만든다.
  * 하위 호환성을 위함
* 그 결과 레지스터 부족을 메우기 위해 x86 코드는 많은 수의 메모리 접근 명령어가 생성된다.
* 임시 계산 결과 값을 담을 레지스터가 부족하므로, 메모리에 잠시 저장한다. (레지스터 스필, register spill)
* 많은 수의 메모리 입출력 -> 성능 저하 (어떻게 효율적으로 처리할 것인가?)

x86의 가변 길이 명령어를 해독 -> 복잡한 회로(트랜지스터 수 증가, 전력 소비 증가)
* 지금이나 예전이나 트랜지스터 수의 큰 차이는 없다.
* 따라서 CISC로 보는 손해는 점점 줄어들어왔다.


즉, 이제는 RISC vs CISC 논쟁은 큰 의미가 없다.
* 서로의 장점을 수용하였다.

그러나 또 다른 명령어 집합 구조가 등장,,,
* VLIW(Very Long Instruction Word) : 하드웨어가 처리할 부담을 소프트웨어로 넘긴다 (Story 17)