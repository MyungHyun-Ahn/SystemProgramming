# Story 07 고성능 프로세서의 시작 : 명령어 파이프라인

## 파이프라인의 기본 개념
파이프라인(pipeline) 소개
* 마이크로프로세서의 성능이 비약적으로 높아지는데 기여한 가장 핵심적인 기술
* 가장 핵심적인 파이프라인 : 명령어 파이프라인
* 산술 연산 장치 등 어느 정도 시간이 걸리는 주요 작업은 파이프라인화(pipelining) 되어있다.

파이프라인이란?
* 연속으로 주어진 어떤 작업을 처리하는 데 있어 처리율(throughput)을 높이는 일반적인 알고리즘
* 파이프라인 알고리즘의 핵심은 재사용과 병렬 실행

### 파이프라인화
* 작업을 여러 세부 단계로 나눈다.
* 먼저 시작된 작업이 다음 단계로 가면, 다음 작업을 받아 수행
* 처리율, 단위 시간 당 처리할 수 있는 일의 양을 크게 높일 수 있다.

세탁과정에 비유한 파이프라인화

![7-01](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/228b8e51-4eb4-4d7a-bad8-113d39469125)


![7-02](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/e6b98061-5708-4ae2-93b7-5a3a73463b02)

위 그림의 절약된 시간을 일반화하면
* 작업 N개 파이프라인 X -> N 시간
* 작업 N개 파이프라인 2개 -> (N-1) / 2 + 1
* 작업 N개 파이프라인 a개 -> (N-1) / a + 1
* N이 만약 충분히 크다면 처리율은 a 배 올라간다.

즉, 파이프라인으로 얻는 이상적인 처리율 증가(speedup)는 파이프라인 단계 수 만큼 된다.
* 그러나 레이턴시는 개선할 수 없다.
* 한 개의 작업을 더욱 빨리 처리할 수는 없다.

## 파이프라인의 효율적인 설계
파이프라인이 이상적인 k 배의 처리율을 얻기 위한 조건
1. 균등한 파이프라인 단계 : 각 단계는 균등한 길이
2. 같은 작업 : 항상 같은 작업만 수행
3. 독립적인 작업 : 투입되는 작업은 서로 의존 관계 없음
4. 파이프라인 유지 비용의 최소화 : 최적의 파이프라인 깊이

### 균등한 파이프라인 단계
* 파이프라인의 효율은 각 단계 중 가장 느린 단계가 결정

파이프라인 단계를 7분, 7분, 16분, 30분처럼 비대칭으로 나누자.

![7-03](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/da349473-e1e9-46c2-87b2-5be7e2f00487)
* 가장 느린 30분 단계가 성능을 결정
* 중간에 작업이 멈추는 시간이 발생 : 파이프라인 스톨(pipeline stall)

따라서 최대한 작업 단계가 비슷한 시간이 되게 설계해야 한다.
* 현실적으로는 힘들다.

### 같은 작업
* 이상적인 파이프라인은 처리하는 작업이 모두 동등하다.

처리하는 작업의 독립성
* 작업간의 의존성이 없어야 차례대로 기다림 없이 진행할 수 있다.
* 실제로는 지켜지기 힘들다.

![7-04](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/464d7d8c-4a4b-4881-86dc-188244e3cedf)
* 이전 작업의 결과에 따라 다음 작업이 진행되어야 하는 상황
* 이전 작업이 끝날 때까지 기다리므로 파이프라인 스톨 발생
* 가장 중요한 문제 중 하나 - 해결 방법 곧 알아봄

### 파이프라인 자체의 비용
파이프라인의 단계가 너무 많아지면?
* 처리율 이득을 상쇄시킬만한 이동 비용이 발생할 수 있다.
* 즉, 레이턴시의 큰 손해를 본다. 

파이프라인 깊이(pipeline depth)
* 파이프 라인이 k단계로 나뉘어 있을 때의 k값
* 너무 깊은 파이프라인은 피해야 한다.
* 채우는데 비우는데 시간이 걸리기 때문

## 파이프라인 프로세서의 구현
명령어 처리율을 높이는 근본 원리 : 병렬 처리
* 이를 위해 먼저 동시에 처리할 수 있는 명령어(병렬성)들을 찾아야 한다.
* 효과적인 하드웨어 자원도 제공되어야 한다. (멀티코어)

멀티 코어가 병렬처리에 이상적인 이유
* 여러 스레드의 명령어는 서로 독립적
* 일부 캐시를 제외, 프로세서 자원을 복제한다.

과거에는 기술이 좋지 못했다.
* 파이프라인은 하드웨어 복제를 조금 하면서 명령어 처리율을 높이는 최초의 병렬 기술로 볼 수 있다.

프로세서는 여러 장치에 파이프라인을 적용
* 대표적으로 명령어 파이프라인(instruction pipeline)

### 명령어 파이프라인
* Story 06에서 본 명령어 사이클을 파이프라인에 적용시킨 것
* 제약 조건 : 한 단계는 한 사이클 이내 완료되어야 한다.
* 사이클마다 파이프라인 단계 진행

따라서 가장 긴 파이프라인 단계가 클록속도 결정
* 5단계 명령어 파이프라인 -> 레이턴시 5사이클
* 명령어 처리율은 클록 당 1개

그러나 이런 것은 잘 지켜지지 않는다.

## 파이프라인의 단편화를 줄이자
이상적인 파이프라인 조건
* 균등한 파이프라인
* 같은 작업이 투입

지켜지기 어려운 이유
* 명령어는 ALU 명령어, 로드, 스토어, 분기문 등 각 명령어의 작업이 다르다.
* ISA 특이성, 실제 프로세서 구현 제약 고려

실제로 균형을 맞추는 방법
* 단계를 합치거나 나누어 균형을 맞춘다.
* 서로 다른 작업도 최대한 같은 부분을 찾아 통합한다.

### 내부 단편화 문제(internal fragmentation)

파이프라인의 내부 단편화

![7-05](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/aa1993a5-e292-43e2-92bb-73f750a51f54)

명령어 인출(IF)과 해독(ID) 단계
* RISC 구조 : 명령어 인출과 해독은 간단해 합칠 수 있다.
* x86 CISC : 상당히 복잡하다. - 이 과정을 나누어 파이프라인 균형을 맞춘다.

피연산자 인출(OF) 단계
* 우리가 정의한 단계 : 레지스터 읽기, 메모리 읽기 작업 포함
* 레지스터 읽기는 빠르지만 메모리 읽기는 느리다.
* 실제 구현에서는 이를 구분한 단계로 처리한다.

실행(EXE) 단계
* 서로 다른 연산(처리시간도 당연히 다르다)을 같은 단계에서 처리하는 것은 비효율적
* 따라서 별도의 파이프라인 단계를 가지는 것이 합당

이런 서로 다른 파이프라인 단계에 의해 스톨이 발생할 수 있다.

### 외부 단편화(external fragmentation) 문제
파이프라인의 외부 단편화

![7-06](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/a5ea00f1-a4e0-426b-9be8-2cb81b79f087)

* 어떤 명령어는 어떤 단계를 필요로 하지 않기 때문에 발생
* 다른 명령어가 중간을 차지하고 있어 명령 수행 불가
  * 구조 해저드(structural hazards) : 자원 부족으로 겪는 현상

### 최적 파이프라인 깊이
파이프라인 깊이가 곧 프로세서의 클록 속도를 결정한다.
* 이것은 곧 깊이가 성능에 큰 영향을 미친다는 것

파이프라인의 이상적인 처리율 상승은 파이프라인 깊이에 비례
* 더불어 클록 속도 또한 높일 수 있다.

파이프라인의 한 단계 -> 한 사이클
* 이걸 더 잘게 쪼개면 일의 양이 줄기 때문에 빠른 클록

현대 프로세서는 보통 10단계 이상의 깊은 파이프라인을 채용
* 파이프라인이 약 50단계가 되면 아무리 클록 속도가 빨라져도 시스템 성능은 하락 (Story 10)