# Story 19 골치 아픈 멀티스레드 버그 : 하이젠버그

## 재현이 어려운 골치 아픈 버그
버그를 잡으려면 가장 먼저 발견한 버그를 확실히 재현할 수 있어야 한다.
* 버그가 어떤 상황에서 발생하는지만 알아도 디버깅의 절반은 성공한 셈
* 여기서 printf 처럼 막강한 디버깅 도구도 없다.
  * 그런데 멀티스레드 프로그램에서 발생하는 버그에서는 무용지물이 된다.
  * 버그 확인이나 재현이 매우 어렵다.
* 이러한 이류로 멀티스레드 버그 또는 병행성 버그를 비결정론적 버그라고 하기도 한다.

재현이 어려운 멀티스레드 버그 중 가장 큰 원인 데이터 레이스(data race)
* 어떤 공유 데이터가 두 스레드 이상에게서 동시에 접근되는 상황을, 단 여기서 적어도 하나의 접근이 쓰기인 것을 가리킨다.
* 만약 모든 스레드가 데이터를 읽기만 같이 한다면 데이터 레이스는 없다.
* 데이터 레이스가 항상 프로그램의 버그를 의미하지는 않는다.
  * 필연적으로 데이터 레이스를 이용해야 할 때도 있다.
  * 대표적으로 뮤텍스 - 락 변수가 경쟁적으로 값을 쓰는데 성공한 스레드가 락을 차지

데이터 레이스가 아주 치명적인 상황
* 단순히 프로그램을 죽이는데 끝나지 않고 끔직한 결과를 유발
* 2003년 미국과 캐나다 동부의 대형 정전 사태
  * 4500만 명이 넘는 사람이 피해, 11명의 인명피해
* Therac-25 방사선 치료 장치 오작동
  * 100배나 많은 방사선이 환자에게 쏘아짐
* 위 두 사례 모두 데이터 레이스가 원인이었다.

데이터 레이스가 일어나는 간단한 코드
~~~C++
1:  #include <windows.h>
2:  #include <tchar.h>
3:  #include <iostream>
4:
5:  __int64 global_data = 0;
6:
7:  // 스레드 함수
8:  DWORD CALLBACK ThreadFunc(void *thread_id)
9:  {
10:     // 어떤 CPU에서 작동할 것인지 친화도 (affinity) 설정
11:     SetThreadAffinityMask(GetCurrentThread(), (DWORD_PTR)thread_id);
12:
13: #if NO_RACE
14:     for (int i = 0; i < 100000000; ++i)
15:         InterlockedIncrement64(&global_data);
16: #else
17:     for (int i = 0; i < 100000000; ++i)
18:         ++global_data;
19: #endif
20: return 0;
21: }
22: int _tmain(int argc, _TCHAR *argv[])
23: {
24:     // 스레드 4개를 만들고 종료될 때까지 기다린다.
25:     HANDLE threads[4];
26:     for (int i = 0; i < 4; ++i)
27:         threads[i] = CreateThread(0, 0, ThreadFunc, (LPVOID)(1<<(i*2)), 0, 0);
28: 
29:     WaitForMultipleObjects(4, threads, TRUE, INFINITE);
30:     std::cout << global_data << std::endl;
31:     return 0;
32: }
~~~
* 64비트 정수를 4개의 스레드가 동시에 각각 1억 회 덧셈하는 코드
* 라인 11 스레드 친화도(thread affinity)를 설정하는 함수
  * 비트 마스크를 이용해 각각 0번 2번 4번 6번 논리 프로세서에서 작동되게 한다.
  * 즉, 물리적으로 다른 코어에 실행되도록 한다.
  * 만약 하이퍼 스레딩이 없거나 쿼드코어가 아니면 적절히 값을 조절해야 한다.
* #define NO_RACE와 함께 컴파일하면 데이터 레이스가 없는 코드가 된다.

데이터 레이스가 있는 경우
* 출력되는 값이 매번 바뀐다.
  * 이랬다 저랬다 하는 멀티스레드 버그의 특징
  * 즉, 데이터 레이스의 발생 순서를 재현하기 어렵다.
* 1.2~1.3억이 나온다는 이야기는 덧셈 중 약 70~80%가 레이스가 발생해 덧셈이 누락되었다는 것
* 멀티코어가 많을 수록 더욱 심하게 발생할 수 있다.

데이터 레이스를 재현하기 어려운 이유
* 물리적인 임의성
* 각 코어가 동시에 데이터 쓰기를 요청해도 아주 미시적인 전자 회로 차원에서 순서가 무작위로 결정되어 결과가 매번 다르게 나오는 것
* 싱글 코어라 해도 값은 매번 다르게 나온다.
  * 다른 스레드나 프로그램이 캐시나 운영체제의 스케줄링에 영향을 주기 때문
  * 그러나 엄밀히 이론적으로 이야기하면 싱글코어의 운영체제 스케줄링은 결정론 적인 알고리즘
  * 멀티스레드의 행동이 완벽히 제현 가능하다. (물론 랜덤 외부 입력은 없다고 가정)
* 멀티코어에서는 비결정론적인 상황 발생
  * 항공기의 블랙박스처럼 멀티코어 컴퓨터에서 일어나는 일을 기록하면 하이젠버그도 재현할 수 있을 것
    * deterministic replay
    * 그러나 이는 아직 개발자가 쓸만한 수준의 도구는 없는 상황

그러나 데이터 레이스는 아주 오래된 문제라 쓸 수 있는 도구가 몇 개 있다.
* 인텔의 Parallel Studio의 Parallel Inspector가 데이터 레이스를 감지
  * 실행 파일을 가져다 실제 실행시켜 수행도중 발견되는 데이터 레이스를 보고하는 프로그램
  * 그러나 이도 완벽하지는 않다.
  * false positive 문제
    * 데이터 레이스가 보고 되었지만 실제로는 아닌 경우
    * 바이러스 검사 도구의 오진과 같은 문제
  * false negative 문제
    * 데이터 레이스가 있는데 도구가 찾지 못하는 경우
    * 데이터 레이스가 있는 코드가 아직 실행되지 못하면 발생할 수 있다.
  * 이것은 동적 데이터 레이스 검출기
    * 즉, 프로파일러처럼 직접 데이터를 주어 돌려보고 데이터 레이스를 찾는 것
  * 가장 큰 단점 - 지나친 분석 시간
* 정적 데이터 레이스 검출기
  * 소스 코드만 보고 잠재적인 데이터 레이스를 찾아주는 기능
  * 찾을 수 있는 범위가 제한적이다.

## 대표적인 병행성 버그 : 원자성 위반과 순서 위반

데이터 레이스가 없어도 문제가 되는 코드
~~~C++
스레드 1
void LoadScript(nsSpt *aspt)
{
    Lock(1);
    gCurrentScript = aspt;
    LaunchLoad(aspt);
    Unlock(1);
}

void OnLoadComplete()
{
    /* LaunchLoad의 콜백 함수 */
    Lock(1);
    gCurrentScript->complie();
    Unlock(1);
}

스레드 2
Lock(1);
gCurrentScript = NULL;
Unlock(1);
~~~
* 실제 모질라 프로그램의 한 소스 코드에서 가져온 버그
* 스레드 1
  * gCurrentScript를 함수 LoadScript에서 설정하고 로딩을 시작
  * 로딩이 끝났을 때 OnLoadComplete 콜백 함수가 불리고
  * 다시 gCurrentScript에 접근해 compile() 함수를 호출
* 스레드 2
  * LoadScript와 OnLoadComplete 사이에 끼어들어 gCurrentScript를 널 값으로 만들 수 있다.
* 위 코드에는 데이터 레이스는 전혀 없다.
* 그러나 스레드 1이 LoadScript를 수행하고 OnLoadComplete가 불리기 전에 스레드 2가 공유 변수를 망가뜨려 프로그램을 죽일 수 있다.

여기서 주의 깊게 살펴볼 것
* 프로그래머가 의도한 것은 데이터 레이스가 없음이 아닌 어떤 일련의 작업이 침범받지 않고 안전하게 실행됨
* 즉, 프로그래머는 LoadScript와 OnLoadComplete가 항상 원자적으로 실행되는 것을 의도
* 그런데 이것을 제대로 코드로 표현하지 못해 버그가 발생한 것

원자성 혹은 직렬성
* 명령어 수준에서 명령어 하나가 더 나누어지지 않고 다른 스레드로부터 안전하게 실행될 수 있는 상태를 가리킴
* 대표적으로 compare-and-swap 명령어
* 원자성은 데이터 레이스와는 다른 측면에서 안전한 멀티스레드 프로그램을 판단할 수 있는 주요 근거가 된다.

최근 발표된 병행성 버그 연구 자료
* 데드락이 아닌 병행성 버그 중 97%가 원자성 위반과 순서 위반
* 데이터 레이스의 유무는 안전한 멀티스레드 프로그램과 크게 연관이 없다.

대표적인 병행성 버그 : 원자성 위반과 순서 위반

![19-01](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/33181fcc-8581-4dab-887d-4b41a2cf9446)

원자성 위반
* 어느 두 작업이 늘 같이 수행되어야 한다고 생각
* 안전하게 보호받지 못해 다른 스레드로부터 침범받아 데이터가 오염되어 결국 프로그램 오류로 나타나는 것

순서 위반
* A 작업 뒤에 B가 실행되어야 함
* 그런데 적절하게 이를 보장하지 못해 순서가 뒤바뀜을 의미

두 버그의 근본 윈인은 메모리 오염
* 원자적 혹은 순서대로 실행되지 못해 프로그래머가 의도한 메모리 읽기 쓰기가 제대로 일어나지 않아서 벌어나는 일

MySQL의 원자성 위반 버그

![19-02](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/ee81ca0d-272c-4f00-acf2-db14017e2963)
* 프로그래머는 S1과 S2가 항상 함께 수행되어야 한다는 원자성을 가정
* 다른 스레드 S3가 S1과 S2 사이에 끼어들어 수행되며 원자성을 위반함
* 이 문제를 해결하려면 동기화 객체를 이용하여 처리해야 한다.

Mozilla의 순서 위반

![19-03](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/b6276e3c-0f9b-4586-a02f-cd986c80b0e7)
* 스레드 1은 PR_CreateThread로 스레드 2를 만든다.
* 스레드 2는 스레드 1이 초기화한 mThread 값을 사용하게 되어 있다.
* 프로그래머는 스레드 2가 생성되기 전에 mThread 값이 초기화될 것이라 믿었다.
* 그러나 스레드 2의 수행이 매우 빠르고 스레드 1이 생성 직후 제어권이 뺏기어 mThread를 갱신하지 못할 수 있다.
* 이 문제를 잡으려면 스레드를 만든 직후 실행되는 것이 아닌 suspended 상태로 만들고 스레드 1이 mThread 값을 쓴 뒤에 스레드 2를 resume 시켜야 한다.

위 버그의 본질은 프로그래머가 의도한 순서가 멀티스레드 상황에서 제대로 지켜지지 못해 발생

MySQL의 원자성 버그도 순서 버그도 아닌 병행성 버그

![19-04](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/709858d1-6458-4853-82b6-4d5aecf44904)
* 모니터 스레드는 데드락을 검사
* 락의 대기 시간이 fatal_timeout 보다 크면 데드락으로 간주하고 강제로 서버를 다시 시작
* 그런데 실제로 스레드가 아주 많이 만들어져 프로그래머가 의도한 값보다 더 큰 시간동안 락이 대기할 수 있었다.
* 그 결과 데드락이 아님에도 서버가 다시 시작되는 문제가 있었다.

병행성 문제의 해결
* 원자성 위반은 간단한 방법 - 락을 이용하여 회피할 수 있었다.
* 순서 위반은 락만 가지고 늘 되는 것이 아니다.
* 추가로 데이터 레이스는 직접적으로 안전한 멀티스레드와 큰 상관이 없다.

흥미로운 사실
* 실제로 수많은 스레드가 만들어져도 버그는 상당히 적은, 단지 두 개의 스레드가 문제를 일으킨다.
* 또, 절반 이상은 하나의 변수에 의해 병행성 버그가 일어났다.

