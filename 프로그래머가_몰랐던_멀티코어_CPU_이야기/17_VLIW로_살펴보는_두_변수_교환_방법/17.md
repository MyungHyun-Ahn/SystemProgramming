# Story 17 VLIW로 살펴보는 두 변수 교환 방법


## VILW의 철학
일반적인 swap 함수와 xor을 이용한 swap
~~~C++
void Swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}

void XorSwap(int *x, int *y)
{
    if (x != y)
    {
        *x ^= *y;
        *y ^= *x;
        *x ^= *y;
    }
}
~~~
* XOR의 특성을 활용하여 임시 변수가 없이 두 변수를 교환할 수 있다.

임시 변수가 필요없는 XOR 방법이 일반적인 변수 교환 방법보다 빠를까?
* VLIW(Very Long Instruction Word)라는 프로세서 설계 방식으로 이야기해보자.

명령어 처리율을 크게 향상할 수 있는 핵심 알고리즘
* 싱글스레드에서도 동시 실행 가능한 명령어를 추출해 처리하는 것
* 비순차, 슈퍼스칼라 프로세서에서
  * 의존성을 파악 후 의존성이 없는 명령은 순서를 바꾸어 실행하여 명령어 완료 레이턴시를 줄임
  * ROB, RS 같은 장치와 스케줄링 로직이 필요했다.
* 그런데 저전력만 사용해야하는 모바일과 임베디드 환경은 비순차 실행 장치를 넣기 어렵다.
  * ARM 기반 프로세서는 순차

비순차 방식의 프로세서가 결코 모든 목적에 적합한 방법이 아니다.
* 이를 제거해서 얻는 전력과 공간상의 이득이 성능 하락에 비해 괜찮은 선택이라면 비순차 방식을 채택할 이유가 없다.

VLIW 프로세서
* ILP를 하드웨어가 찾게 하는 것이 아닌 컴파일러가 찾아 명시적으로 병렬 실행 가능한 명령어를 찾게 한다.
* 매우 긴 명령어라는 이름은 명시적으로 병렬 실행한 명령어 묶음을 긴 워드로 표현했기 때문

비순차 슈퍼스칼라 프로세서
* 하드웨어가 ISA만 노출
* 컴파일러는 ISA에 정의된 명령어와 레지스터만으로 코드를 생성해야 함
  * CISC 방식에서 마이크로 명령어로 바뀌거나 물리 레지스터가 논리 레지스터보다 더 많은 등의 정보
  * 프로그래머가 볼 수 없는 내용
* 즉, ISA는 프로그래머와 프로세서 구현 사이의 인터페이스 역할을 한다.

VLIW에서는
* ILP를 하드웨어에서 찾지 않고 컴파일러가 찾는다.
* 이를 위해 하드웨어의 구체적인 정보까지 모두 노출시킨다.
  * 물리 레지스터의 개수, 연산 장치의 개수와 레이턴시까지 알려준다.
* 컴파일러는 병렬 실행 가능한 명령어를 분석해 프로세서가 아무런 의존성 검사를 하지 않고 바로 실행할 수 있도록 미리 준비해야 한다.
* 모든 것이 컴파일러에 의해 정적으로 스케줄링 된다.
* 따라서 프로세스는 복잡한 비순차 실행 장치를 만들 필요가 없다.

VLIW의 장점
* 컴파일러는 더 큰 명령어 윈도우 단위에서 ILP를 찾을 수 있다.
* 궁극적으로 VLIW 컴파일러는 해당 하드웨어가 제공한 모든 정보로 최적의 병렬 실행 가능한 명령어를 배치해 코드를 생성한다.
* 단순히 ILP 뿐만 아니라 연산 장치의 개수나 레이턴시까지 고려해 스케줄링 한다.
  * 데이터 의존성 뿐만 아니라 실행 장치에 의한 의존성까지 고려

VLIW의 단점
* 하위 호환성이 부족하다.
  * 하드웨어의 사양을 노출시키기 때문에 과거의 바이너리가 제대로 작동하지 않을 수 있다.
* 모든 명령어의 레이턴시가 고정되어 있지 않다.
  * 최적 스케줄링이 결코 간단하지 않다.
  * 실시간 정보는 알 수 없다.
* C/C++ 프로그램은 포인터 사용이 잦다.
  * 컴파일 시간에는 포인터에 어떤 주소 값이 할당되는지 알기 어렵다.
* 프로그램이 규칙적이고 ILP를 쉽게 찾을 수 있는 프로그램은 큰 이득을 볼 수 있다.
  * 그러나 프로그램 정적 분석의 한계로 VLIW의 장점이 슈퍼스칼라를 늘 압도하지 못한다.

## 두 변수를 교환하는 방법에 대한 고찰
Swap 함수가 가지는 ILP
~~~C++
1:  int temp = a;
2:  a = b;
3:  b = temp;
4:  printf(a, b);
~~~
* 1번 명령어와 2번 명령어는 변수 a가 WAR 의존성이 있다.
* 레지스터 리네이밍과 같은 변수 이름 바꾸기로 해결할 수 있다.

WAR 의존성을 제거
~~~C++
1:  int temp = a; a' = b;
2:  b = temp;
3:  printf(a', b);
~~~

슈퍼스칼라 프로세서는 이런 작업을 모두 프로세서가 알아서 실시간으로 진행한다.
* b에 대한 WAR을 제거
~~~C++
1:  int temp = a; a' = b;
2:  b' = temp;
3:  printf(a', b');
~~~

상수 전파를 생각하여 불필요한 temp 변수를 제거
~~~C++
1:  a' = b;
2:  b' = a;
3:  printf(a', b');
~~~

또 다시 상수 전파를 a', b'에 적용하면
~~~C++
1:  printf(b, a);
~~~
* 최종적으로 최적화 된 코드
* 우리가 원하는 매우 이상적인 코드가 되어버린다.

XOR을 이용한 변수 교환 법
~~~C++
1:  a = a ^ b;
2:  b = b ^ a;
3:  a = a ^ b;
4:  printf(a, b);
~~~
* 1번과 2번 명령어 사이에는 변수 b로 인한 WAR 의존성이 있다.
* 이번에는 변수 a에 대한 RAW 의존성도 있다.
* 결국 1, 2, 3번 명령은 순차적으로 실행되어야만 한다.
* 그러니 결국 XorSwap 함수가 temp를 쓴 함수보다 느리다.

최종적으로 컴파일러가 최적화를 수행한 결과도 비슷하다.