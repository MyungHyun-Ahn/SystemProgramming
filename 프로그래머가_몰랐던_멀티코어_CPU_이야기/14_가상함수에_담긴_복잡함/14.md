# Story 14 가상함수에 담긴 복잡함
객체지향 언어의 가상 함수 사용과 가상 머신의 등장으로 스위치 문의 사용 빈도가 늘어남
* 까다로운 분기 목적지 예측이 필요하고 현대 프로세서에서 그 처리가 쉽지 않다.

## 분기 목적지 예측
분기문이 있다면 분기문의 방향과 분기 목적지(branch target)을 예측해야 한다.

분기문의 분류
* 직접 분기문(direct branch)
  * 분기 목적지가 명령어에 인코딩됨
  * 명령어만 해독하면 분기 목적지를 알 수 있다.
  * 그러나 바로 해독은 불가능 - CISC 명령의 경우 2~3 사이클이 지나야 해독 가능
* 간접 분기문(indirect branch)
  * 분기 목적지가 레지스터 혹은 메모리에 있어 한 번 더 참조

직접 분기문과 간접 분기문 모두 분기 목적지의 예측은 필요하다.
* 직접 분기문의 목적지 예측은 간단한 알고리즘으로도 가능
* 간접 분기문의 예측은 쉽지 않다.
  * 경우의 수가 훨씬 많기 때문

직접 분기문과 간접 분기문의 비교

![13-10](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/591896fb-2bee-499e-b6b6-f3d09b84a236)
* 직접 분기문은 목적지 경우의 수 최대 두 가지
* 간접 분기문은 경우의 수가 몇 개가 될지 알 수 없다.
  * N개 중 1개를 예측하는 것이라서 훨씬 어렵다.

간접 분기문의 종류
* 콜백 함수
* 가상 함수
* switch-case
* 함수 리턴

형태에 따라 예측하는 방법도 특화되어 있다.

### 가장 간단한 분기 목적지 예측 - 직접 분기문
그림에서 보듯 TARGET에 해당하는 내용을 미리 예측
* 결국 이것은 캐시와 같다.

동작 과정
* 직접 분기문 A를 예전에 한번 실행
* 그때 알아낸 분기 목적지 TARGET을 어떤 자료구조에 저장
* 분기 방향 예측기와 함께 목적지도 간단히 예측 가능

브랜치 타겟 버퍼(Branch Target Buffer, BTB)
* 주어진 명령어가 분기문이었고 또 분기했다면(taken) 그 목적지를 알려주는 자료구조
* 구조는 캐시와 거의 동일
* 보통 직접 사상(directed mapped) 캐시 구조처럼 만들어지고, 집합 연관 구조로도 만들 수 있다.

만약 BTB 예측이 틀리면
* 투기적 실행 원리로 복구가 되고 다시 문제가 된 분기문부터 실행이 재개
* BTB는 매 사이클 마다 명령어를 인출할 때, 분기 방향 예측기와 함께 불린다.
* 일종의 프리 디코더(pre-decoder) 역할도 한다.
* BTB가 유효한 값을 반환 - 명령어를 해독하지 않아도 분기문인지 예측 가능

BTB는 캐시와 비슷하다.
* 예측하고자 하는 PC를 정확하게 캐시처럼 다룬다.
* 그런데 PC를 정확하게 비교하는 부분은 없다.
* PC값과 분기 히스토리를 XOR 해서 섞어 사용하기도 함
* 이런 방식은 겹침 문제를 피할 수 없다. - 분기 방향 예측기는 이런 문제를 무시
* 운영체제가 컨텍스트 스위칭을 해서 발생하는 문제도 고려하지 않음
* 성능에 큰 영향이 없기 때문
  * 용량에 제한적이다.
  * 종종 이러한 겹침이 좋은 결과를 낳을 수도 있다.

## 간접 분기문의 분기 목적지 예측
고성능 현대 마이크로 프로세서에서 간접 분기문의 분기 목적지 예측을 위해 특화된 장치
* iBTB(indirect BTB)
  * 함수 리턴 예측
* RAS(Return Address Stack)
  * 콜백 함수, 가상 함수, 스위치 케이스 구문 예측


## 함수 리턴과 RAS
함수 리턴의 예
~~~C++
1:  int sum = Compute(detal, data2);
2:  sum += old_data;
3:  int new_data = Compute(val1, val2);
4:  printf("%d\n", new_data);
~~~
* 컴파일러는 함수가 끝나고 원래 불러준 곳으로 돌아갈 수 있게 코드를 생성
* 함수 리턴은 목적지가 정적으로 결정되지 않는다.
* 따라서 함수 리턴 역시 간접 분기문으로 구현된다.

함수 리턴 과정
1. 함수가 호출될 때 스택이나 레지스터에 호출지 주소를 기억
2. 그리고 리턴될 때 기억된 주소를 읽어 분기 목적지로 쓴다.


함수 리턴은 BTB로는 제대로 작동하지 않는다.
* 분기 목적지가 매번 바뀌기 때문

그런데 이 함수가 돌아갈 주소는 간단히 예측 가능
* 스택 형태의 RAS로 아주 높은 정확서을 얻을 수 있다.

RAS 동작과정
1. 함수 콜 명령을 만나면 RAS에 돌아올 주소를 push
2. 리턴할 때 RAS를 pop해서 꼭대기 값을 읽는다.
3. 이 값이 바로 함수가 돌아갈 목적지

함수가 스택 형식으로 동작
* RAS에 아주 적합하다.

실제로 RAS는 16개 정도의 엔트리만 있어도 예측률이 95%가 넘는다고 한다.
* 현대 프로세서에도 16개 정도의 엔트리

운영체제가 문맥 교환을 진행한다면?
* 에측 실패가 일어나도록 방치
* 모든 내용을 비우도록 하는 것
* 어차피 복구하는 기능이 있기 때문에

스택이 넘친다면?
* RAS는 프로세서의 성능을 향상시키기 위한 보조 도구이기 때문에 그냥 무시하는 것도 합리적

## 콜백 함수와 가상 함수
C++ 일반/가상 함수의 호출 차이
~~~C++
      Object *p = new Computer;
      p->NoVirtual();
1:  mov ecx, dword ptr [p]
2:  call Object::NoVirtual
      p->TurnOn(10);
3:  push 0Ah                     ; 함수인자 10
4:  mov eax, dword ptr [p]       ; eax = p
5:  mov edx, dword ptr [eax]     ; edx = *p (vtable 주소)
6:  mov eax, dword ptr [edx+8]   ; eax = *(*p + 8)
7:  mov ecx, dword ptr [p]       ; this = p
8:  call eax
~~~

일반 함수
* 그냥 명시적으로 함수를 호출

가상 함수
* 상속 구조를 고려해야 한다.
  * 부모 함수? 자식 함수?
  * 다이나믹 디스패치(dynamic dispatch)
* 컴파일러가 이것을 어떻게 구현할지는 컴파일러마다 다르다.
  * 일반적으로 vtable 기법으로 구현
  * TurnOn의 위치를 얻고 호출

## 점프 테이블
컴파일러는 특정 조건이 만족하면 switch-case문을 점프 테이블로 대체
* 일종의 해시 테이블
* switch 값에 대한 분기할 주소를 미리 테이블로 만들어두어 비교없이 바로 목적지로 간다.
* 간접 분기문으로 구현

switch-case문 점프 테이블 의사코드
~~~C++
jump_table = { 0x0100, 0x0200, 0x0300, 0x0000, 0x0400, ...};
1:  temp = dir->dir->type;
2:  if (temp > 12) goto default;
3:  goto jump_table[temp];

0x100:  // case 1 코드
0x200:  // case 2 코드
...
~~~
* switch에 쓰이는 변수를 먼저 얻고 이 값이 case 값의 범위에 들어오는지 검사
* 범위를 벗어나면 default 구문으로
* 미리 저장된 점프 테이블을 참조해 간접 분기문으로 바로 분기
* 점프 테이블은 case 구문의 코드 위치를 배열로 표현한 것

## iBTB : 간접 분기문을 위해 특화된 BTB
히스토리 기반으로 예측 (Story 13)
* 가상 함수 목적지는 다른 분기문의 실행 내역과 관련이 깊다.
* 따라서 히스토리에 기반한 간접 분기문의 목적지 예측은 잘 작동할 수 있다.