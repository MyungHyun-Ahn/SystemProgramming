# Story 05 프로그램의 의미를 결정짓는 의존성
올바른 병렬 프로그램은 순서를 지켜가며 실행된다.
* 이 순서를 결정짓는 요소 : 의존성
* 병렬 프로그래밍의 기초를 이해하는데 매우 중요한 요소

## 데이터 의존성
데이터 의존성(data dependence)
* 명령어들 사이에서의 데이터 흐름
* 프로그램의 문맥을 결정하는 매우 중요한 요소

컴파일러가 최적화 할 때 의존성 파악은 가장 중요한 작업
* 명령어의 순서를 바꾸는 최적화, 의존성 반드시 고려
* 의존성이 있는 명령어 : 순서대로 실행되어야 함을 의미

두 명령어 사이에서 데이터 의존성\
읽기/쓰기 순서에 따라 RAW, WAR, WAW로 구분

### RAW 의존성
~~~C++
1: x = y + 1;
2: z = x * 2;
~~~
* 1번 명령이 계산 결과를 만들면 2번 명령이 이를 사용
* 당연히 2번 명령이 먼저 수행될 수 없다.

Read-After-Write 의존성, 즉 RAW 의존성이라 부른다.
* 컴퓨터 구조에 한정, 의존성을 해저드(hazard)라 표현하기도 함
* 컴파일러 분야에서는 흐름 의존성(flow dependence)이라 함
* 이름 때문에 발생한다 해서 이름 의존성(name dependence)라고 하기도 함

### WAR 의존성
~~~C++
1: z = x + 2;
2: x = y + 1;
~~~
* 변수 x가 먼저 읽힌 뒤에 값이 쓰인다.

Write-After-Read 의존성, 즉 WAR 의존성이라 부른다.
* 컴파일러에서 반의존성(antidependence)이라는 표현을 쓴다.

### WAW 의존성
~~~C++
1: x = z * 2;
2: x = y + 1;
~~~
* 같은 대상에 쓰여지기에 의존성 유발

Write-After-Write 의존성, 즉 WAW 의존성이라 부른다.
* 출력 의존성(output dependence)이라 하기도 한다.

### 의존성 정리 표

![Story05-1](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/13b9985d-d27a-44a6-9da6-615c4cdf6d6e)

* RAW는 진짜(true) 의존성, WAR, WAW는 가짜(false) 의존성으로 분류

위 세가지 데이터 의존성 중 하나라도 있으면 일단 순서대로 실행해야 정확한 결과를 얻을 수 있다.

### WAR/WAW 의존성은 약간의 속임수로 없앨 수 있다.
변수명 바꾸기
~~~C++
1: z = x * 2;
2: x = y + 1;
3: a = x / 2;

1': z = x * 2;
2': x1 = y + 1;
3': a = x1 / 2;
~~~
* 1', 2'의 WAR 의존성 제거
* 2', 3'의 RAW 의존성은 이름 바꾸기로 해결 불가
* WAW 역시 이름 바꾸기로 해결 가능하다.

RAW 의존성이 있는 명령어는 순서대로 실행되어야 한다.


## 컨트롤 의존성
~~~C++
1: if (a == 10)
2:     b = 10;      // 1번 명령과 컨트롤 의존성
3: else
4:     b = 20;      // 1번 명령과 컨트롤 의존성
5: a = b + 10;      // 2, 4번 명령과 RAW 의존성
6: z = x / y;       // 어떠한 의존성도 가지지 않는다.
7: k = a + z;       // 6번 명령과 RAW 의존성
~~~
컨트롤 의존성 : 조건 분기문으로 결정
* 명시적인 데이터 의존성은 1, 2, 4번 명령 사이에 없지만 실행 흐름(control flow) 때문에 의존성 생성
* 이것을 컨트롤 의존성(control dependence)이라 한다.

참고로, 무조건(조건이 없는) 분기문(uncondition branch)은 컨트롤 의존성을 만들지 않는다.

또다른 분기문 함수 호출의 경우
* 내부 제어 흐름에 의해 결정된다.
* 판단이 쉽지 않다.
* 프로시저 간(interprocedural) 분석 : 함수 호출을 추적하며 분석하는 것

컴파일러 최적화
* 간단한 최적화는 한 함수 내에서만 이루어진다.
* 고차원 최적화는 프로시저 간 최적화, IPO(Interprocedural Optimization) 수행

이런 컨트롤 의존성 파악 문제는 프로세서와 컴파일러를 넘어 소프트웨어 테스팅에서도 중요하다.

컨트롤 의존성은 PC(Program Counter) 레지스터에 의한 RAW 데이터 의존성
* 분기문의 경우, 명령어를 실제 실행해야 최종 PC 값을 쓸 수 있다.
* 명령어를 실행 -> PC 레지스터를 읽는 것
* 따라서 컨트롤 의존성은 PC 레지스터에 의한 RAW 의존성

## 메모리 의존성
지금까지의 의존성은 모두 비포인터 형
* 기계어 수준으로 이야기하면 모두 레지스터 형

만약 포인터 형이라면 의존성이 달라진다.
~~~C++
1: *x = *y + 1;
2: *a = *b + 2;
~~~
* 위 정보만으로는 의존성 판단 불가
* 모두 다른 정보를 가리키면 문제는 없다.
* 같은 정보를 가리키는게 있다면 의존성을 유발한다.

이런 경우 포인터 변수가 가리키는 목적지를 정확히 알아야 파악 가능


위 문제를 기계어로 표현
~~~C++
1: mov      [esi+0], eax    ; *(esi+0) = eax (쓰기)
2: mov      ebx, [edi+8]    ; ebx = *(edi+8) (읽기)
3: mov      [ebp-8], ecx    ; *(ebp-8) = ecx (쓰기)
4: add      ebx, 1          ; ebx = ebx + 1;
~~~
이 때 메모리 의존성을 파악하려면 esi+0, edi+8, ebp-8이 어떤 값을 가지는지 모두 계산
* (edi+8) == (esi+0) : 1, 2번 사이 RAW 의존성
* (ebp-8) == (edi+8) : 2, 3번 사이 WAR 의존성
* (ebp-8) == (esi+0) : 1, 3번 사이 WAW 의존성

메모리 명확화 문제(memory disambiguation problem)
* 주어진 명령어 사이 메모리 의존성을 밝혀내는 것
* 프로세서와 컴파일러에게 모두 중요
* 포인터 분석(pointer analysis)이라 하기도 함

데이터 의존성은 레지스터 이름만 비교해도 파악 가능
* 메모리 의존성은 로드/스토어 대상을 실행 전에는 모른다.
* 즉, 컴파일러는 컴파일 타임에 모른다. 
  * 컴파일러는 보수적으로 의존성이 있다고 판단할 때가 많다.
* 코드를 실행하기 전까지는 알아내지 못하는 문제 : 포인터 분석 문제(Story 15)

컴퓨터 용어에서 보수적(convervatively) : 최악의 상황을 가정하고 최대한 안전한 방향으로 선택하는 것

지금까지의 정리
* 의존성이 있는 두 명령어는 반드시 순서대로 실행
* 의존성이 없는 경우, 순서가 바뀌거나 병렬로 실행돼도 상관없다.

의존성 분석을 하면 컴파일러나 프로세서는 최적의 명령어 실행 순서를 정의할 수 있다.
* 명령어 재배치(instruction reordering) 최적화
* 명령어 스케줄링(instruction scheduling) 최적화

메모리 로드 연산은 캐시 미스 유발 가능
* 메모리 로드 후 RAW 의존성을 갖는 명령이 줄줄이 있다.
* 최대한 빨리 메모리 로드를 마치는 것이 효과적
* 이 때 컴파일러나 프로세서는 메모리 로드 앞의 명령을 살펴본다.

아무런 의존성 없는 명령이 있다면?
* 메모리 로드를 이들 앞에 배치 가능
  * 단일 프로세서라는 가정이 필요하다.
  * 멀티 코어라면 의존성 없는 메모리 로드/스토어라도 CPU나 컴파일러가 순서를 바꾸면 예측하기 힘든 동작이 발생 가능
    * 메모리 컨시스턴시(memory consistency) 혹은 메모리 모델(memory model)에서 관련 내용을 찾을 수 있다.
  * 메모리 장벽(memory barrier), 메모리 펜스(memory fence)를 통해 멀티코어 환경에서 순차적인 메모리 작업을 보장하도록 강제 지정 가능
* 일종의 레이턴시 감추기(latecy hiding) 같은 기술 : 메모리 로드 시간을 줄이기 위한 노력

## 루프에서의 데이터 의존성
루프 전이 의존성(Loop-carried dependence)
* 데이터 의존성은 루프에서 특별한 형태로 나타날 수 있다.

~~~C++
1: for (int i = 1; i < N; ++i)
2:     A[i] = A[i - 1] + 1;

// 루프 순환에 따른 2번 구문의 메모리 접근
i=1: A[1] = A[0] + 1;
i=2: A[2] = A[1] + 1; // A[1]에 대해 RAW 의존성
i=3: A[3] = A[2] + 1; // A[2]에 대해 RAW 의존성
~~~
* 루프가 1번, N이 2라면 어떤 의존성도 생기지 않는다.
* 여러번 반복되면 RAW 의존성이 만들어진다.
* 이 때 이 루프에 대해 루프 전이 RAW 의존성을 가진다고 한다.

루프 무관 의존성(loop-independent dependence)
* 루프 순환 외부에서 발생하는 의존성
* 루프 전이/무관 의존성은 데이터 의존성의 부분 집합

### 루프 전이 WAR 의존성
~~~C++
1: for (int i = 0; i < N - 1; ++i)
2:     A[i] = A[i + 1] + 1;

// 루프 순환에 따른 2번 구문의 메모리 접근
i=0: A[0] = A[1] + 1;
i=1: A[1] = A[2] + 1; // A[1]에 대해 WAR 의존성
i=2: A[2] = A[3] + 1; // A[2]에 대해 WAR 의존성
~~~
* 루프 전이 RAW 의존성과 비슷, WAR 의존성을 루프에 걸쳐 가진다.
* 명시적으로 이름을 바꾸는 것이 아닌, 복사본을 통해 의존성 극복 가능

배열 복제로 루프 전이 WAR을 제거 : 임시 배열 사용
~~~C++
1: int oldA[N];
2: memcpy(oldA, A, sizeof(int) * N);
3: for (int i = 0; i < N - 1; ++i)
4:     A[i] = oldA[i + 1] + 1;

// 루프 순환에 따른 4번 구문의 메모리 접근
i=0: A[0] = oldA[1] + 1;
i=1: A[1] = oldA[2] + 1;
i=2: A[2] = oldA[3] + 1;
~~~
* 간단히 배열 A 합을 배열 oldA에 복사하여 루프 전이 WAR을 피했다.
* 프로그램 형태에 따라 더 효율적인 방법으로 루프 전이 WAR을 해결할 수도 있다.

### 억지로 만들어낸 루프 전이 WAW
~~~C++
1: for (int i = 0; i < N; ++i) // 루프 전이 WAW가 B[0]에서 발생
2:     B[0] = A[i] + 1;

// 루프 전이 WAW 제거
1': for (int i = 0; i < N; ++i)
2':     tempB[i] = A[i] + 1;
3': B[0] = tempB[N - 1];
~~~
* 변수를 따로 선언하여 쉽게 회피 가능

루프 전이 의존성이 제거되면 가지는 성질
* 루프가 병렬화 가능해진다.

RAW 의존성은 알고리즘 수정 없이 없앨 수 없다.
* 완화하는 방법은 존재 : value prediction
  * 값을 미리 예측해서 미리 수행
  * 기본적인 아이디어 : 예전에 수행한 과거 이력을 보고 예측
  * 만약 예측이 틀리면 다시 수행 -> 투기적 실행(speculation, story 13)

루프 전이 WAR/WAW는 프로그래밍 태크닉으로 회피할 수 있다.

컴파일러는 루프에 의존성이 없다면 자동으로 병렬화
* 루프 병합(Loop Fusion), 루프 바꾸기(Loop Interchange) 같은 최적화 기법도 의존성 분석을 반드시 해야 가능