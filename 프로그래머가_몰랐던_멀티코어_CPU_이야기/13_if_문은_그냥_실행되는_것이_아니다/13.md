# Story 13 if 문은 그냥 실행되는 것이 아니다.

분기문 처리가 중요한 이유와 분기문의 결과를 미리 예측하는 알고리즘에 대해 이야기한다.

## 분기문 명령어와 프로그래밍 언어
파이프라인 프로세서에서 분기문
* 골치 아픈 컨트롤 해저드를 만들었다.
* 이 해저드를 해결하는 좋은 방법 - 분기 예측 기번

분기문(branch)
* 프로그램의 실행 흐름
* 즉, PC의 값이 바뀔 수 있는 명령어
* 분기문은 두 가지 기준으로 분류할 수 있다.

분기 여부를 따지는 방법에 따라 분류
* 조건 분기문(conditional branch)
  * 특정 연산 결과가 어떤 조건을 만족할 때 분기, 그렇지 않으면 다음 명령으로 진행
  * 프로그래밍 언어의 for, while, do, until 등의 문법
  * 기계어에서는 이런 문법이 바로 지원되지 않는다.
  * 컴파일러는 언어의 분기문을 조건 분기문 또는 간접 분기문으로 바꿔준다.
* 무조건 분기문(unconditional branch)
  * goto, jump로 항상 해당 목적지로 분기한다.

분기 목적지를 얻는 방식에 따라 분류
* 분기 목적지를 바로 얻을 수 있느냐 아니면 한 번 메모리를 참조하느냐에 따라 분류
* 직접 분기문(direct branch)
  * 명령어 자체에 바로 분기 목적지가 인코딩
  * 명령어 해독 단계에서 분기 목적지를 알아낼 수 있다.
* 간접 분기문(indirect branch)
  * 분기 목적지가 메모리 어딘가에 있어 메모리 참조가 필요하다

C/C++에서의 대표적인 간접 분기문
1. 콜백(callback, 함수 포인터로 인한) 함수
2. 프로시저 리턴
3. 가상 함수 호출
4. 스위치-케이스를 위한 점프 테이블

C#의 delegate
* 함수 포인터를 추상화한 것으로 간접 분기문

디자인 패턴 중 간접 분기문
* 옵저버와 Strategy 패턴

## 분기 예측이 필요한 이유
분기문은 컨트롤 의존성을 만들고 컨트롤 해저드가 되어 파이프라인의 효율적인 진행을 방해한다.

분기문이 EXE 단계에서 밝혀질 때 파이프라인 스톨

![13-01](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/aa63a78b-ef2c-4b8b-bcd3-d8a8b7250eae)
* 조건 분기문이 일으킬 수 있는 파이프라인 스톨
* 그래서 MIPS 프로세서는 분기문 해결을 최대한 앞 단계에서 해결
* 스톨이 생긴 자리에 컴파일러가 분기문의 결과와 상관없는 명령어를 배치할 수도 있다.
  * 지연슬롯


간접 분기문이 일으키는 컨트롤 해저드

![13-02](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/ab258ee4-f8b0-4d62-b20b-4ad9563b797a)
* 메모리에 있는 내용을 읽는 작업이 필요하다.
* OF 단계까지 기다려야 한다.


무조건 분기문과 직접 분기문은 다소 쉽다.
* 명령어만 해독하면 분기 지점 알 수 있다.
  * 무조건 분기문 : 계산이 필요없다.
  * 직접 분기문 : 메모리 참조가 필요 없다.
* 그렇다고 해도 CISC 처럼 복잡한 명령어에서는 이 작업도 바로 이루어지기 어렵기에 스톨이 생길 수 있다.

이상적으로 분기문이 파이프라인의 첫 단계에서 결과가 알려진다면 스톨 없이 작동할 수 있다.
* 그러나 파이프라인을 해결하는 작업은 일반적인 정수 연산에 버금감

분기 예측(branch prediction) 기법
* 이 기법을 사용하여 컨트롤 해저드에 의한 파이프라인 스톨을 최소화
* 분기문의 결과가 나오지 않았음에도 분기문의 결과를 예측하여 파이프라인을 진행

![13-03](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/69a1a193-63e0-43fd-901a-18e75c86c5d5)
* 분기 예측기가 있다고 가정
* 첫 번째 케이스
  * 분기를 예측하고
  * 5번 명령어를 스톨없이 파이프라인에 넣는다.
  * 이런 분기 방향뿐 아니라 분기 목적지도 예측해야 한다.
* 두 번째 케이스
  * IF 단계에서 어디로 분기할지 알 수 없지만
  * 분기 목적지 예측기의 도움으로 20번으로 분기한다는 것을 알고
  * 파이프라인을 쉬지 않게 한다.

정리하면 분기 예측은 두 가지 속성을 예측
* 분기 방향 예측
  * 주어진 조건 분기문이 분기하느냐(taken) 아니면 분기하지 않느냐(not taken)를 예측한다.
  * 0과 1 두 가지 중 하나를 고르는 것
* 분기 목적지 예측
  * 분기문이 어디로 분기할지 목적지(target)를 예측한다.
  * 훨씬 더 많은 대상 가운데 예측해야 하는 어려움이 있다.

분기 예측은 순차든 비순차든 상관없다.
* 컨트롤 해저드로 인한 스톨이 발생하면 분기 예측은 항상 필요하다.
* 분기 예측은 당연히 틀릴 때를 대비해야 한다.

## 분기 예측에 기반한 투기적 실행
투기적 실행(speculative execution)
* 불확실한 예측을 기반으로 더 나은 성능을 가져오는 방향으로 명령어를 처리하는 개념
* 대표적인 투기적 실행은 분기 예측에 기반한 것

분기 예측 기반으로 파이프 라인에 들어간 명령어 그림

![13-04](https://github.com/MyungHyun-Ahn/SystemProgramming/assets/78206106/d10c45ac-966f-4ca1-95ff-44e17e7b3f75)
* 예측에 기반한 명령어는 점선 - 명령어가 옳은 것인지 모른다는 의미
* 예측값과 EXE 단계에서 알게된 결과 값이 같다면 이는 명령어 완료 사이클을 단축시킨다.
* 예측이 빗나간다면 잘못 처리된 명령어를 모두 무효화 시킨다.
  * 파이프라인을 비운다(flush, drain)
* 그리고 다시 옳은 명령을 다시 수행한다.
* 투기적 실행은 틀릴 수 있으므로 되돌리기(undo)를 준비해야 한다.
* 분기문의 결과가 밝혀질 때까지 그 상태가 외부로 노출되면 안 된다.

투기적 실행에 필요한 것
1. 결과를 예측하는 장치
   * 앞으로 알아봄
2. 결과가 불확실해도 계속 실행을 진행시킬 수 있는 장치
   * 비순차 실행의 ROB(리오더 버퍼) 같은 장치로 해결
3. 예측이 틀렸을 때 원상태로 복수하는 장치
   * undo 와 같다
   * 체크포인트(checkpoint)를 두어 해결할 수 있다.

투기적 실행은 메모리 로드에서도 빈번히 발생
* Story 15

## 기본적인 분기 예측 방법
이번 문제에서는 분기문의 방향, 분기 여부만 고려
* 맞출 확률이 0 아니면 1, 50%나 된다.
* 분기된 분기문은 taken branch라 한다.
* 분기하지 않는 분기문은 not-taken branch라 한다.

분기 예측의 방식
* 정적 방식
  * 정해진 규칙에 따라서 움직임, 실시간으로 프로그램을 분석하지는 않음
  * 과거 프로세서에 장치를 많이 넣을 수 없던 시절에는 이 방법을 이용
* 동적 방식
  * 실제 프로그램의 실행 내역으로 분기를 예측
  * 캐시의 원리와 비슷하다. - 과거 정보를 활용

분기문의 결과에도 지역성을 찾을 수 있다.
~~~C++
1:  for (int i = 0; i < 10000; ++i)
2:      if ((i % 100) != 0)
3:          sum += i * i;
4:      else if ((i % 2) != 0)
5:          sum += i;
~~~
* for문은 i가 10000일 때를 제외하면 항상 같은 결과를 만든다.
* 첫 번째 if문은 100번 중 99번은 분기 결과가 같다.
* 여기서 분기 여부는 이전 결과와 연관이 크다는 것을 알 수 있다.

C++로 만드는 분기 예측기
~~~C++
class VerySimpleBranchPredictor : public BranchPredictor
{
private:
    bool *table_; // True: taken, False: not taken
    size_t size_; // 분기 예측기의 크기

public:
    virtual void Initialize(size_t predictor_entry_size)
    {
        table_ = new bool[(size_ = predictor_entry_size)];
        // 분기문의 모든 결과를 not taken으로 설정한다.
        memset(table_, 0, sizeof(predictor_entry_size));
    }

    virtual bool DoPrediction(uint64_t branch_pc)
    {
        // 주어진 분기문의 PC 주소에 해당하는 값을 읽어 예측한다.
        return table_[branch_pc % size_];
    }

    virtual void UpdatePredictor(uint64_t branch_pc, bool taken)
    {
        // 분기문의 실제 결과를 반영한다.
        table_[branch_pc % size] = taken;
    }
}
~~~
* 분기 예측기는 크게 세가지 인터페이스, 초기화, 예측, 갱신을 생각할 수 있다.
* 캐시처럼 크기가 제한되므로 어떤 크기를 갖는다.
* 분기 예측기는 과거의 분기 여부만 기록하기에 1비트만 저장하면 된다.
* 주어진 분기문의 PC 주소에 대응되는 table_의 내용을 읽는다.
* DoPrediction 함수는 IF 단계에서 불린다.
* 만일 분기문의 결과가 실제로 밝혀지면 분기 예측기를 갱신한다. (훈련이라고도 한다.)
* 분기문이 밝혀지면 결과를 쓰는 작업을 UpdatePredictor에서 한다.

위 간단한 예측기의 성능
* 별로 좋지 않아보인다.
* 어쩌다 한 번씩 발생하는 분기 결과 값으로 빗나간 예측을 할 수 있다.

이런 단점을 극복하는 방법
* 분기 여부와 추가로 강도를 기억하는 것
* 분기 테이블을 2비트로 4가지 경우를 도입